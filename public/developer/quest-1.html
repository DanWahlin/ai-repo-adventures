<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: The Gate of MCP Tools - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Mythic Repository Chronicles</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: The Gate of MCP Tools</h1>
<hr>
<p>In this quest, you audit the MCP gateway that exposes tools for initiating, choosing, and progressing through developer adventures. Your focus is the server interface and its tool registry: how requests are validated, routed, and executed, and how transport and lifecycle concerns are handled. This guide is an exploration path, not a prerequisite checklist. Study the implementations to understand how code becomes an interactive interface for repository-guided learning, and how argument schemas, error handling, and background preprocessing align to deliver reliable, tool-driven workflows.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Gateway Map: How does <code class="inline-code">RepoAdventureServer.setupHandlers</code> produce dynamic tool listings with per-tool schemas, and what pattern ensures JSON Schema compatibility?</li>
<li>‚ö° Transport Cadence: In <code class="inline-code">RepoAdventureServer.run</code>, how is the stdio transport initialized and why is pre-generation invoked without awaiting completion?</li>
<li>üõ°Ô∏è Fault Ward: In <code class="inline-code">main</code>, how do signal handlers and unhandled rejection listeners ensure resilience without premature termination?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> MCP server setup, tool routing, transport, and lifecycle orchestration</h3>
<p>This file defines the MCP server that publishes tools and executes them on demand. The <code class="inline-code">RepoAdventureServer</code> encapsulates a <code class="inline-code">Server</code> instance configured with a name, version, description, and <code class="inline-code">tools</code> capability. The critical <code class="inline-code">setupHandlers</code> method registers request handlers for both <code class="inline-code">ListToolsRequestSchema</code> and <code class="inline-code">CallToolRequestSchema</code>. For listing, it enumerates <code class="inline-code">tools</code> and converts each Zod <code class="inline-code">schema</code> to JSON Schema using <code class="inline-code">zodToJsonSchema</code> with <code class="inline-code">target: &#39;jsonSchema7&#39;</code> and <code class="inline-code">$refStrategy: &#39;none&#39;</code>. This ensures clients receive fully inlined schemas that are straightforward to validate client-side. For execution, it validates input via <code class="inline-code">tool.schema.safeParse(args)</code>, aggregates Zod error messages if invalid, and throws typed <code class="inline-code">McpError</code> instances with <code class="inline-code">ErrorCode</code> values for predictable client handling. Successful validation leads to invoking <code class="inline-code">tool.handler(validatedArgs)</code> and returning its result.</p>
<p>The <code class="inline-code">run</code> method wires a <code class="inline-code">StdioServerTransport</code>, connects, logs readiness, then triggers <code class="inline-code">repoAnalyzer.preGenerate(projectPath)</code> to warm caches in the background. It deliberately does not await this to avoid blocking tool availability. The <code class="inline-code">main</code> function constructs the server, registers graceful shutdown for <code class="inline-code">SIGINT</code>/<code class="inline-code">SIGTERM</code> via <code class="inline-code">gracefulShutdown</code> that includes <code class="inline-code">repoAnalyzer.cleanup()</code>, and installs an <code class="inline-code">unhandledRejection</code> listener that logs and continues, preserving uptime unless startup fails. Fatal startup errors are caught, logged, and cause exit with status 1. This design balances robustness with responsiveness, ensuring tool listing and calling are reliable while background preprocessing optimizes later operations.</p>
<h4>Highlights</h4>
<ul>
<li>Dynamic tool listing with JSON Schema generation for every registered tool</li>
<li>Input validation using Zod with aggregated error messaging mapped to <code class="inline-code">McpError</code></li>
<li>Background pre-generation of analysis to improve subsequent interactions</li>
</ul>
<h3><span class="header-prefix">packages/mcp/src/tools.ts:</span> Tool registry and re-exports for MCP integration</h3>
<p>This module aggregates and exports the MCP tools that the server exposes. It imports <code class="inline-code">adventureManager</code> for shared state across tools, then imports four tool modules (<code class="inline-code">start-adventure</code>, <code class="inline-code">choose-theme</code>, <code class="inline-code">explore-quest</code>, <code class="inline-code">view-progress</code>) and re-exports them under MCP-friendly snake_case names: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, <code class="inline-code">view_progress</code>. The final <code class="inline-code">tools</code> object is a flat registry keyed by these names and is what <code class="inline-code">server.ts</code> enumerates for listing and calling. This structure separates tool implementation detail from registration, enabling the server to remain generic. The comments document the recommended flow: starting an adventure, selecting a theme, exploring quests, and viewing progress. While handlers for each tool are implemented in their respective files, their presence here ensures that <code class="inline-code">server.ts</code> can reference a single source of truth for available tools, their <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code>. This design supports scalable addition or removal of tools without altering server routing logic, and encourages schema-first definitions for reliable validation and discoverability through the MCP protocol.</p>
<h4>Highlights</h4>
<ul>
<li>Clear registry pattern mapping tools to MCP-exposed names</li>
<li>Centralized export <code class="inline-code">tools</code> consumed by server listing and execution</li>
<li>Documentation of tool flow supports client-side orchestration</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
</code></pre>
<p>Like a receptionist who both prints a directory and validates appointments before letting visitors in.</p>
<pre><code class="language-typescript">  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
</code></pre>
<p>Like opening the shop doors, greeting customers, and quietly prepping supplies in the back room without blocking the front.</p>
<pre><code class="language-typescript">async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<p>Like assigning staff to handle fire alarms and complaint logs, keeping the store open unless the opening routine fails.</p>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<p>Like a catalog that standardizes product names and displays an index for easy checkout.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Validate schemas at the boundary: use Zod <code class="inline-code">safeParse</code> and convert to JSON Schema for client discoverability.</li>
<li>Keep transport setup minimal: initialize <code class="inline-code">StdioServerTransport</code> and return quickly to avoid blocking tool usage.</li>
<li>Optimize warm paths: trigger background preprocessing to improve first-response latency without delaying startup.</li>
</ul>
<hr>
<p>Adventure checkpoint reached. You have mapped the MCP gateway‚Äôs listing, validation, and lifecycle. Continue with tool implementations to complete the interface.</p>
<p>Quest 1: The Gate of MCP Tools successfully merged‚Äîgreat job initializing your toolchain and validating the integration pipeline; keep iterating toward the remaining milestones with clean commits, strong test coverage, and continuous delivery momentum üöÄ‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>