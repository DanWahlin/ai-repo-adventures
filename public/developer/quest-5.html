<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Cartographer‚Äôs Toolkit - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Codex: Navigating the Repository Constellation</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Cartographer‚Äôs Toolkit</h1>
<hr>
<p>In this final mission brief, you consolidate the command deck that turns raw configuration into an actionable itinerary. Your role is to verify how configuration text is loaded, parsed, sifted for valid file paths, and compacted into LLM-ready prompts. Treat the following objectives as exploration guides while reviewing the code sections. You will trace the pipeline from file reads to structured prompt formatting, ensuring stable behavior under missing files, invalid JSON, and sparse configs. By completing this, you finalize the scan-synthesize-present loop across your operable command deck.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">parseAdventureConfig</code> centralize JSON parsing and gracefully handle malformed or missing configs without throwing?</li>
<li>‚ö° Route Plotter: In <code class="inline-code">extractUniqueFilePaths</code>, what traversal strategy collects <code class="inline-code">path</code> fields anywhere in the config, and how does it verify actual file existence against <code class="inline-code">projectPath</code>?</li>
<li>üõ°Ô∏è Reactor Safeguards: How does <code class="inline-code">formatAdventureConfigForPrompt</code> validate shape (adventure, quests, files, highlights) and minimize output while avoiding unsafe assumptions?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration loading, parsing, file path extraction, and prompt formatting utilities</h3>
<p>This module supplies a cohesive set of utilities for reading <code class="inline-code">adventure.config.json</code>, parsing it safely, extracting valid file paths referenced by <code class="inline-code">path</code> fields embedded anywhere in the configuration, and producing a compact prompt-friendly representation. The design separates concerns: <code class="inline-code">loadAdventureConfig</code> performs a pure file read with non-fatal handling; <code class="inline-code">parseAdventureConfig</code> is the single entry for JSON parsing, ensuring errors yield <code class="inline-code">null</code> instead of exceptions; <code class="inline-code">extractUniqueFilePaths</code> crawls the parsed object via an explicit stack to find any <code class="inline-code">path</code> fields, deduplicates with a <code class="inline-code">Set</code>, and includes only paths that exist on disk relative to <code class="inline-code">projectPath</code>; <code class="inline-code">formatAdventureConfigForPrompt</code> transforms the high-level <code class="inline-code">adventure</code> structure into a minimal text format that lists quest titles, file paths, and function names. This approach reduces coupling, improves resilience under missing or malformed config, and aligns with prompt-size constraints. Input validation is defensive: both parsing and formatting return empty outputs when preconditions are not met, which prevents upstream failures. The stack-based traversal avoids recursion pitfalls and handles arbitrary nested shapes. Together, these functions provide a stable foundation for higher-level systems to calibrate themes, validate inputs, manage timeouts, and produce consistent mission briefs.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> centralizes JSON parsing and returns <code class="inline-code">null</code> on failure, ensuring downstream callers can rely on a safe tri-state: valid object, empty, or invalid.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> scans nested structures using a stack, checks <code class="inline-code">path</code> fields for non-empty strings, resolves them against <code class="inline-code">projectPath</code>, and includes only existing files, guaranteeing actionable references.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> emits a compact representation of quests, files, and functions by validating structure step by step, minimizing token usage for LLM prompts and avoiding noisy descriptions.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">/**
 * Parses the adventure config into an object (or null on error/missing).
 * Single point of JSON parsing and validation.
 */
export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Centralizes parsing to one function, simplifying error handling across the codebase.</li>
<li>Uses <code class="inline-code">loadAdventureConfig</code> for the raw read, then wraps <code class="inline-code">JSON.parse</code> in a <code class="inline-code">try/catch</code> to avoid thrown errors.</li>
<li>Returns <code class="inline-code">null</code> for missing or malformed inputs, enforcing a predictable contract for callers.</li>
<li>Encourages callers to check for falsy values before use, preventing runtime exceptions.</li>
<li>Supports progressive enhancement: validation can be extended here without changing callers.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Extracts all unique, existing file paths referenced by &quot;path&quot; fields anywhere in the config.
 */
export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Implements non-recursive DFS with a stack to traverse arbitrary nested object and array structures.</li>
<li>Validates <code class="inline-code">path</code> fields as non-empty strings, resolves relative paths against <code class="inline-code">projectPath</code>, and includes only existing files via <code class="inline-code">fs.existsSync</code>.</li>
<li>Uses a <code class="inline-code">Set</code> to deduplicate references discovered in multiple locations.</li>
<li>Returns an empty array for invalid or missing configs, preserving safety and simplicity for callers.</li>
<li>Decouples path extraction from schema specifics, making it robust to shape changes.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Formats adventure config into a minimal format for LLM prompts
 * OPTIMIZED: Reduced from 7,279 to ~2,000 characters (72% reduction)
 * Eliminates redundant descriptions since LLM can infer from actual code
 */
export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Produces a concise string representation that lists quests, file paths, and function names only.</li>
<li>Validates each structural layer before accessing properties, preventing runtime errors.</li>
<li>Reduces token usage for LLM prompts by excluding verbose descriptions, focusing on essentials.</li>
<li>Uses functional array patterns (<code class="inline-code">map</code>, <code class="inline-code">flatMap</code>, <code class="inline-code">filter</code>, <code class="inline-code">join</code>) for clear data shaping.</li>
<li>Returns an empty string for non-conforming configs, keeping upstream prompt assembly predictable.</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>Prefer calling <code class="inline-code">parseAdventureConfig</code> before any deeper access to ensure robust error handling.</li>
<li>When extending structure, keep <code class="inline-code">extractUniqueFilePaths</code> schema-agnostic by maintaining object/array traversal via the stack.</li>
<li>To add fields to prompt output, extend <code class="inline-code">formatAdventureConfigForPrompt</code> after validating shapes to avoid unexpected exceptions.</li>
</ul>
<hr>
<p>You have mastered all the secrets of this project context! Your adventure is complete.</p>
<p>Quest 5: Cartographer‚Äôs Toolkit successfully merged into main‚Äîstellar geospatial mapping patterns, precise coordinate handling, and data-layer abstractions achieved; progress at 80% with clean commits, passing tests, and robust docs‚Äîkeep shipping with this momentum üöÄüó∫Ô∏è‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>