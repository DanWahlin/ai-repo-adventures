<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: The Archive of Adventure Configs - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Mythic Repository Chronicles</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: The Archive of Adventure Configs</h1>
<hr>
<p>This guide examines how configuration runes shape developer adventures. You will study how configuration files are discovered, parsed, validated, and distilled into prompt-ready summaries. The investigation targets the foundation utilities that load raw configuration, safely parse it, extract referenced file paths, and generate an optimized prompt view. These exploration guides are not prerequisites; they are questions to answer as you read the code below. Focus on implementation details, error-tolerant patterns, and how the system balances resilience with utility.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">parseAdventureConfig</code> guard against malformed JSON and non-object results while centralizing parsing concerns?</li>
<li>‚ö° Runic Flow Mapping: In <code class="inline-code">extractUniqueFilePaths</code>, how does the traversal stack handle nested arrays/objects and ensure only existing paths are included?</li>
<li>üõ°Ô∏è Validator‚Äôs Aegis: In <code class="inline-code">formatAdventureConfigForPrompt</code>, what conditions short-circuit formatting, and how are functions and files compacted to reduce prompt size without losing structure?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration utilities for loading, parsing, extracting references, and prompt formatting</h3>
<p>This module centralizes configuration handling for adventures. <code class="inline-code">loadAdventureConfig</code> reads raw text from <code class="inline-code">adventure.config.json</code> using <code class="inline-code">readFileIfExists</code>, returning <code class="inline-code">null</code> for any file errors to keep failures non-fatal. <code class="inline-code">parseAdventureConfig</code> is the single parsing point, wrapping <code class="inline-code">JSON.parse</code> with a try/catch and returning <code class="inline-code">null</code> on invalid JSON, which prevents exceptions from propagating across the system. <code class="inline-code">extractUniqueFilePaths</code> performs a non-recursive traversal using an explicit <code class="inline-code">stack</code>, walking any nested object/array structures in the parsed config. It identifies <code class="inline-code">path</code> properties, trims them, resolves them relative to <code class="inline-code">projectPath</code>, and includes them only if <code class="inline-code">fs.existsSync</code> confirms they exist, storing them in a <code class="inline-code">Set</code> to ensure uniqueness. <code class="inline-code">formatAdventureConfigForPrompt</code> creates a compact prompt string focusing on structure: it validates presence of <code class="inline-code">adventure.quests</code>, emits quest titles, joined file paths, and function names from <code class="inline-code">highlights</code>, and omits verbose descriptions. It returns an empty string early if any essential structure is missing or if parsing fails. This composition supports robust downstream usage in LLM-driven flows by providing minimized yet structurally informative content.</p>
<h4>Highlights</h4>
<ul>
<li>Centralized parse with <code class="inline-code">parseAdventureConfig</code> to avoid duplicated JSON handling</li>
<li>Iterative traversal and existence checks in <code class="inline-code">extractUniqueFilePaths</code></li>
<li>Early-return guards and compaction strategy in <code class="inline-code">formatAdventureConfigForPrompt</code></li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<p>Like opening a scroll carefully: if the ink is smudged, you close it quietly and move on.</p>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<p>Like mapping a dungeon: you walk every corridor, note each door that truly exists, and list it once.</p>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths - LLM can see descriptions in actual code
    const filePaths = quest.files
      .filter((f: any) =&gt; f.path)
      .map((f: any) =&gt; f.path);
    if (filePaths.length &gt; 0) {
      formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    }
    
    // Just function names - LLM can understand purpose from implementation
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .filter((h: any) =&gt; h.name)
      .map((h: any) =&gt; h.name);
    if (functions.length &gt; 0) {
      formatted += `Functions: ${functions.join(&#39;, &#39;)}\n`;
    }
    
    formatted += `\n`;
  }

  return formatted;
}
</code></pre>
<p>Like summarizing a blueprint: you capture rooms, doorways, and key mechanisms without reprinting every mural.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Validate assumptions about structure before access to avoid runtime errors; mirror the early-return guards used here.</li>
<li>When traversing unknown shapes, favor iterative stacks over recursion to avoid call stack limits and to maintain explicit control.</li>
<li>For LLM prompts, minimize verbosity by emitting structural signals (titles, files, function names) while omitting redundant descriptions.</li>
</ul>
<hr>
<p>Quest archived. Proceed to integrate configuration insights into your adventure tooling.</p>
<p>Quest 5: The Archive of Adventure Configs successfully merged into main‚Äîconfig schemas validated, versioned, and documented‚Äîpushing your progress to 4/5 (80%) with production-grade rigor and momentum toward final delivery, stellar work! ‚≠êüöÄ</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>