<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Chart the Adventure Map - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Spacebound Repository Odyssey</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Chart the Adventure Map</h1>
<hr>
<p>This guide focuses your bridge crew on the foundation utilities that map project galaxies into navigable charts. The goal is to understand how configuration text is loaded, parsed, and compacted into prompts that the LLM reactor can safely consume. Use this as an exploration guide while reading the code; these are not prerequisites. You will analyze how configuration faults are handled gracefully, how file references are discovered reliably, and how the mission computer formats minimal, high-signal summaries for downstream systems.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">parseAdventureConfig</code> ensure that failures in loading or parsing are non-fatal and return <code class="inline-code">null</code> consistently?</li>
<li>‚ö° Navigation Plotting: In <code class="inline-code">extractUniqueFilePaths</code>, what traversal strategy is used to collect <code class="inline-code">path</code> fields, and how does it validate file existence relative to <code class="inline-code">projectPath</code>?</li>
<li>üõ°Ô∏è Safety Shields: How does <code class="inline-code">formatAdventureConfigForPrompt</code> guard against malformed structures and produce a minimal, stable output without throwing?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Foundation utilities for configuration loading, parsing, path extraction, and prompt formatting</h3>
<p>This module provides read and parse functions that gracefully handle missing or invalid configuration without interrupting the mission flow. <code class="inline-code">parseAdventureConfig</code> is the single point of JSON parsing and returns <code class="inline-code">null</code> on any failure, establishing a predictable contract for callers. <code class="inline-code">extractUniqueFilePaths</code> performs a stack-based traversal over the configuration object graph to find all <code class="inline-code">path</code> fields, filtering out non-existent files using <code class="inline-code">fs.existsSync</code> against <code class="inline-code">path.resolve(projectPath, rel)</code>. It returns a de-duplicated array via <code class="inline-code">Set</code>, ensuring the scanner only processes valid targets once. <code class="inline-code">formatAdventureConfigForPrompt</code> constructs a minimal prompt section by extracting quest titles, file paths, and function names when present, while defensively handling missing structures. This reduces verbosity and aligns with prompt budget constraints, delivering consistent structure even when optional fields are absent. The design emphasizes resilience: helpers return empty strings or arrays on invalid input, avoiding exceptions and supporting safer pipeline composition across the analyzer and story generator. Observing how input is validated, normalized, and compacted will help you calibrate the scanner, tune safety checks, and confirm predictable outputs for downstream LLM usage.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> centralizes JSON parsing and returns <code class="inline-code">null</code> for any error, simplifying error handling across the system.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> traverses the entire config graph, collects <code class="inline-code">path</code> fields, validates existence, and returns a unique set, ensuring accurate scanning targets.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> emits minimal structured text with quest titles, files, and functions, protecting prompt budgets and resisting malformed configs.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Centralized parser: All JSON parsing occurs here, standardizing error behavior across consumers.</li>
<li>Defensive programming: Returns <code class="inline-code">null</code> for missing file or parse error, avoiding thrown exceptions.</li>
<li>Clear contract: Callers can branch on <code class="inline-code">null</code> to apply defaults or skip optional features.</li>
<li>Decoupling: Relies on <code class="inline-code">loadAdventureConfig</code> for I/O, keeping parsing logic isolated.</li>
<li>Maintains stability for downstream steps like extraction and prompt formatting.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Stack-based traversal: Iteratively walks arrays and objects without recursion, preventing stack overflow on large configs.</li>
<li>Validation: Uses <code class="inline-code">fs.existsSync</code> with <code class="inline-code">path.resolve</code> to ensure reported files exist relative to <code class="inline-code">projectPath</code>.</li>
<li>De-duplication: <code class="inline-code">Set</code> guarantees unique results, removing repeated references across the graph.</li>
<li>Robust against shape variance: Treats both arrays and objects uniformly via <code class="inline-code">Object.values</code>.</li>
<li>Safe defaults: Returns an empty array if config is missing or not an object.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Minimal prompt shaping: Outputs only key structure to conserve tokens and reduce redundancy.</li>
<li>Defensive guards: Early returns on invalid or incomplete structures maintain stability.</li>
<li>Iteration pattern: Filters for presence of <code class="inline-code">title</code>, <code class="inline-code">files</code>, and <code class="inline-code">highlights</code> before emitting lines.</li>
<li>Separation of concerns: Formatting depends on <code class="inline-code">parseAdventureConfig</code> contracts, not raw I/O.</li>
<li>Predictable structure: Consistent headings and lists aid deterministic downstream parsing.</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>Validate assumptions: Always check for <code class="inline-code">null</code> from <code class="inline-code">parseAdventureConfig</code> before accessing properties.</li>
<li>Confirm coverage: Use <code class="inline-code">extractUniqueFilePaths</code> to verify that referenced files exist before scanning.</li>
<li>Optimize prompts: Prefer <code class="inline-code">formatAdventureConfigForPrompt</code> output to keep LLM inputs concise and consistent.</li>
</ul>
<hr>
<p>You have mastered all the secrets of project navigation and configuration! Your adventure is complete.</p>
<p>Quest 5: Chart the Adventure Map successfully integrated into your sprint backlog with a validated feature branch and merged deliverables, elevating your progress to 4/5 quests (80%)‚Äîstellar execution of mapping logic and data flow orchestration, keep shipping with confidence! üöÄüó∫Ô∏è‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>