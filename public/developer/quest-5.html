<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: The Keeper of Config – Guardianship of the Repository’s Blueprint - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'developer' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Codex Chronicles: Guardians of the Repository</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: The Keeper of Config Guardianship of the Repository’s Blueprint</h1>
<hr>
<p>The Repository&#39;s whispers grew louder as you unlocked the door to Quest 5. The Keeper of Config stood poised to reveal its secrets—a guardian of pathways, dependencies, and structural integrity within the realm of code. This time, your mission was to explore the very heart of configuration—the blueprint guiding every quest. Beneath layers of JSON and logic awaited the true narrative of how adventures come alive. As the Keeper’s labyrinth of configuration structure unraveled, one thing was certain: even the smallest misstep could rewrite the Repository’s fate.</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Centralizes Adventure Configuration</h3>
<p>The file <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a> encapsulates logic for the <code class="inline-code">adventure.config.json</code> file. It is the cornerstone for orchestrating adventures, enabling the system to read, validate, and explore configurations that define quests. The critical functionalities include loading the raw configuration file (<code class="inline-code">loadAdventureConfig</code>), parsing its content into structured data (<code class="inline-code">parseAdventureConfig</code>), and ensuring a cohesive structure for LLM prompt generation. Parsing safeguards like JSON validation prevent errors from derailing the system, while <code class="inline-code">extractUniqueFilePaths</code> deeply scans the configuration for all file paths referenced within the &quot;path&quot; properties of the configuration object.</p>
<p>For example, <code class="inline-code">extractUniqueFilePaths</code> isn&#39;t just a basic parser; it traverses deeply nested objects to ensure that all file references are viable. It also ensures paths exist, preventing scenarios where invalid paths could lead to dead links in quest files. Meanwhile, the <code class="inline-code">formatAdventureConfigForPrompt</code> function converts this structured data into digestible text guidelines for language models—a critical link between configuration and the quest narrative. Together, these functions create a modular system that transforms static configuration files into actionable data, making adventures dynamic and resilient.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadAdventureConfig</code>: Reads raw configuration data from the <code class="inline-code">adventure.config.json</code> file.</li>
<li><code class="inline-code">parseAdventureConfig</code>: Validates and converts JSON data into a structured object for use within the adventure system.</li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Scans the configuration for &quot;path&quot; properties, validates their existence, and ensures no duplicate or invalid paths.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code>: Converts configuration data into structured guidelines for LLM-driven quest generations.</li>
<li>Central to ensuring the stability of quests and structure of adventures.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">import * as fs from &#39;fs&#39;;
import * as path from &#39;path&#39;;

const ADVENTURE_CONFIG_FILE = &#39;adventure.config.json&#39;;

function readFileIfExists(filePath: string): string | null {
  try {
    return fs.readFileSync(filePath, &#39;utf-8&#39;);
  } catch {
    // Missing or unreadable file is non-fatal
    return null;
  }
}

/**
 * Loads the raw adventure config text if present.
 * Pure file read - no parsing here.
 */
export function loadAdventureConfig(projectPath: string): string | null {
  const configPath = path.join(projectPath, ADVENTURE_CONFIG_FILE);
  return readFileIfExists(configPath);
}
</code></pre>
<p>This code is like a gatekeeper that ensures the adventure begins only when its guiding map—<code class="inline-code">adventure.config.json</code>—is accessible.</p>
<pre><code class="language-typescript">/**
 * Extracts all unique, existing file paths referenced by &quot;path&quot; fields anywhere in the config.
 */
export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<p>When preparing for an adventure, this function ensures that no path leads to a dead end by validating all file paths referenced across the entire config.</p>
<pre><code class="language-typescript">/**
 * Formats adventure config into a readable format for LLM prompts
 * This ensures structured sections always appear in quest content
 */
export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure Guidelines\n\n`;
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    formatted += `${quest.description}\n\n`;
    formatted += `**Required File Analysis Sections:**\n`;

    for (const file of quest.files) {
      if (!file.path || !file.description) continue;

      formatted += `\n**File: \`${file.path}\`**\n`;
      formatted += `- Description: ${file.description}\n`;
      
      if (Array.isArray(file.highlights)) {
        formatted += `- Key Functions/Areas to Highlight:\n`;
        for (const highlight of file.highlights) {
          if (highlight.name &amp;&amp; highlight.description) {
            formatted += `  • **${highlight.name}**: ${highlight.description}\n`;
          }
        }
      }
    }
    formatted += `\n`;
  }

  formatted += `\n**FORMATTING INSTRUCTIONS:**\n`;
  formatted += `- Each file mentioned in the quest structure above MUST have its own dedicated analysis section\n`;
  formatted += `- **MANDATORY**: Include at least 2-3 separate code snippet sections (## filename) with real code blocks\n`;
  formatted += `- Show actual function signatures, imports, class definitions, or key methods from the files\n`;
  formatted += `- Include real code snippets from the actual files (never invent code)\n`;
  formatted += `- Provide practical explanations using real-world analogies\n`;
  formatted += `- End with helpful hints and next steps\n`;

  return formatted;
}
</code></pre>
<p>This function is like a translator, taking dense configuration data and converting it into a clear, structured set of instructions for language models to craft compelling adventures.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Regularly validate your configuration files to ensure they are not corrupted and align with expected schema.</li>
<li>If designing new quests, follow prompts&#39; structured formatting and use <code class="inline-code">formatAdventureConfigForPrompt</code> to create consistent story elements.</li>
<li>For enhanced debugging, build additional logging into functions like <code class="inline-code">parseAdventureConfig</code> to identify invalid paths or fields.</li>
</ul>
<p>The repository’s configuration schema has been refactored and safely committed—our systems are now 80% battle-hardened for production deployment; onwards to the final merge! 🚀⚡💎</p>

</div>


    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>