<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: The Foundations of Configuration - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Repository of Infinite Adventures</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: The Foundations of Configuration</h1>
<hr>
<p>Embarking on Quest 5, you arrive at the heart of the Repository of Infinite Adventures: the Configuration Chamber. This sacred space fuels the repository&#39;s ability to generate adaptive and unique adventures. Here, the Keeper of Code must decipher the layered complexities of configuration files to wield their power effectively. Delve into the secrets of <code class="inline-code">adventure-config.ts</code>, the cornerstone of configuration logic, and uncover how quests are structured, formatted, and optimized for otherworldly LLM-driven storytelling.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:  </p>
<ul>
<li>üîç <strong>Configuration Scanner</strong>: How does the <code class="inline-code">parseAdventureConfig</code> function ensure safe handling of JSON and missing files?  </li>
<li>‚ö° <strong>Path Extraction Ritual</strong>: In what way does <code class="inline-code">extractUniqueFilePaths</code> traverse nested objects to find paths?  </li>
<li>üõ°Ô∏è <strong>Optimization Enchantment</strong>: How does <code class="inline-code">formatAdventureConfigForPrompt</code> optimize quest configuration for LLM analysis?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration Logic</h3>
<p>The <code class="inline-code">adventure-config.ts</code> file serves as the core logic for handling adventure configurations. It reads, parses, validates, and formats the required JSON data, offering critical functionality for the overarching quest system configuration. Each highlighted function plays a unique role in transforming raw data into actionable insights for generating quests:</p>
<ol>
<li><strong><code class="inline-code">parseAdventureConfig</code></strong>: Handles JSON parsing and validation through a combination of file loading and built-in error management. Its modularity reduces risk by isolating raw file reading from parsing logic.  </li>
<li><strong><code class="inline-code">extractUniqueFilePaths</code></strong>: Processes nested objects in configuration files to extract valid, unique file paths. It employs a traversal mechanism to ensure comprehensiveness while filtering invalid or nonexistent paths.  </li>
<li><strong><code class="inline-code">formatAdventureConfigForPrompt</code></strong>: Prepares quest data to be concise and readable for language model prompts. Using formatting reductions, it optimizes data for high-efficiency transmission without losing structural integrity.</li>
</ol>
<h4>Highlights</h4>
<ul>
<li>File handling and JSON parsing strategy in <code class="inline-code">parseAdventureConfig</code>.  </li>
<li>Recursive traversal for path extraction in <code class="inline-code">extractUniqueFilePaths</code>.  </li>
<li>Optimization logic and design practices in <code class="inline-code">formatAdventureConfigForPrompt</code>.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">/**
 * Parses the adventure config into an object (or null on error/missing).
 * Single point of JSON parsing and validation.
 */
export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<p>This function is like an initial filter mechanism, transforming raw JSON text into usable objects while gracefully handling errors or empty states.</p>
<pre><code class="language-typescript">/**
 * Extracts all unique, existing file paths referenced by &quot;path&quot; fields anywhere in the config.
 */
export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<p>The recursive traversal here mirrors a search party combing through complex terrains, identifying and validating paths to include in the quest.</p>
<pre><code class="language-typescript">/**
 * Formats adventure config into a minimal format for LLM prompts
 * OPTIMIZED: Reduced from 7,279 to ~1,763 characters (76% reduction)
 */
export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths - LLM can see descriptions in actual code
    const filePaths = quest.files
      .filter((f: any) =&gt; f.path)
      .map((f: any) =&gt; f.path);
    if (filePaths.length &gt; 0) {
      formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    }
    
    // Just function names - LLM can understand purpose from implementation
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .filter((h: any) =&gt; h.name)
      .map((h: any) =&gt; h.name);
    if (functions.length &gt; 0) {
      formatted += `Functions: ${functions.join(&#39;, &#39;)}\n`;
    }
    
    formatted += `\n`;
  }

  return formatted;
}
</code></pre>
<p>This approach compresses the intricate architecture into a readable format, like a wizard condensing their spell book into short incantations.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Modularize configuration handling to separate concerns and improve readability.  </li>
<li>Use recursion strategically when working with nested data structures.  </li>
<li>Optimize LLM inputs to balance brevity with structural integrity.</li>
</ul>
<hr>
<p>Congratulations! You have uncovered the foundational mechanisms powering configuration in the Repository of Infinite Adventures. Use your newfound knowledge wisely to craft adaptive and dynamic quests for explorers across the realms.</p>
<p>Your mastery of configuration fundamentals has unlocked a new feature branch of knowledge‚Äî80% of the codebase to ultimate success has been committed; keep refactoring your skills and push toward the final deploy! üöÄüíé‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>