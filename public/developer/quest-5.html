<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Foundation & Utilities - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Repository of Ancient Adventures</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Foundation &amp; Utilities</h1>
<hr>
<p>The ancient repository holds secrets buried in layers of abstraction and thoughtful code. Quest 5, &quot;Foundation &amp; Utilities,&quot; beckons as an exploration into the elemental groundwork of the system. Armed with the map to <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a>, adventurers will uncover mechanisms to read and parse configurations, extract unique file paths, and format data for streamlined AI usage. Wisdom awaits those who tread carefully through these foundational utilities, where every function conceals its purpose in the architectural flow of the codebase.  </p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:  </p>
<ul>
<li>üîç <strong>Config Scanner</strong>: How does <code class="inline-code">parseAdventureConfig</code> ensure the correct configuration parsing and validation across projects?  </li>
<li>‚ö° <strong>Pathfinder</strong>: What techniques does <code class="inline-code">extractUniqueFilePaths</code> use to navigate nested structures and find valid paths?  </li>
<li>üõ°Ô∏è <strong>Streamlined Formatter</strong>: How does <code class="inline-code">formatAdventureConfigForPrompt</code> optimize data output for AI consumption while preserving essential details?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> A closer look at the foundation</h3>
<p>This file is integral to handling adventure configuration files across projects. The functions within it enable developers to process JSON files, extract meaningful data from nested structures, and optimize configurations for AI-driven adventures. These utilities are critical for maintaining both flexibility and performance when interacting with dynamic project files.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code>: Parses raw config files into structured objects and includes built-in error handling for invalid or missing configurations. This ensures robust and reliable parsing across diverse projects.  </li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Recursively searches nested config data to collect and validate unique file paths, leveraging path-traversal logic that enables integration with dynamically referenced files.  </li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code>: Formats configuration data to reduce unnecessary details, ensuring compatibility and performance when consumed by AI systems, especially for LLM prompts.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">/**
 * Parses the adventure config into an object (or null on error/missing).
 * Single point of JSON parsing and validation.
 */
export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>This function reads raw data from the config file and attempts to parse it into a usable object.  </li>
<li>Ensures resilience by returning <code class="inline-code">null</code> for missing files or invalid JSON.  </li>
<li>Centralizes key validations, making errors predictable and simplifying troubleshooting.  </li>
<li>Bridges file-handling operations with runtime behavior by interpreting loaded raw data.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Extracts all unique, existing file paths referenced by &quot;path&quot; fields anywhere in the config.
 */
export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Implements recursive traversal through nested JSON structures using a stack-based approach for path extraction.  </li>
<li>Validates file existence and ensures collected paths are reliable and actionable.  </li>
<li>The <code class="inline-code">Set</code> data structure is used to prevent duplicates, optimizing result integrity.  </li>
<li>Establishes strong ties between configuration and runtime file validation for seamless project interaction.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Formats adventure config into a minimal format for LLM prompts
 * OPTIMIZED: Reduced from 7,279 to ~2,000 characters (72% reduction)
 */
export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Streamlines adventure configuration into concise summaries for LLM models, optimizing data consumption.  </li>
<li>Reduces redundancy while preserving necessary details, striking a balance between minimalism and informativeness.  </li>
<li>Dynamically generates structured output based on the available quests, files, and highlights.  </li>
<li>Enhances integration with AI pipelines while maintaining comprehensibility for developers.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Validate parsed data immediately to safeguard against runtime errors caused by malformed input files.  </li>
<li>Explore recursive traversal techniques to deepen understanding of nested JSON structures.  </li>
<li>Experiment with optimization approaches when structuring outputs for AI tools.</li>
</ul>
<hr>
<p>Congratulations, adventurer! You have unearthed the foundational utilities that power the quest engine, an elemental force in transforming files into intricate adventures. Continue onward and master the repository!</p>
<p>Quest 5: Foundation &amp; Utilities has been successfully committed and deployed üéâ‚Äîan incredible 80% progress milestone, proving you&#39;re debugging complexities, refactoring excellence, and architecting your path to ultimate mastery! üöÄüíé‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>