<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Foundation & Utilities - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Repository Chronicles: The Codebase Codex</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Foundation &amp; Utilities</h1>
<hr>
<p>Delve deep into the foundational components that shape the adventure&#39;s groundwork. This quest will guide you through the <code class="inline-code">adventure-config.ts</code> file, which provides critical utilities for loading, parsing, and formatting configuration data that powers the storytelling engine. By exploring these utilities, you&#39;ll uncover how the system interacts with project files, extracts meaningful data, and shapes configuration for seamless adventure generation.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Data Parsing Protocols</strong>: How does the system safely read and parse external configuration files while handling potential errors?</li>
<li>‚ö° <strong>Dynamic Path Extraction</strong>: What technique is used to extract unique file paths from the configuration, and how does it ensure validity?</li>
<li>üõ°Ô∏è <strong>Configuration Optimization</strong>: How is the formatting of the adventure configuration optimized for efficiency in downstream processes?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration Utilities</h3>
<p>This file contains utility functions that handle reading, parsing, and processing adventure configuration files. These utilities are central to ensuring the system can dynamically adapt configurations while gracefully handling invalid or incomplete inputs. By examining the functions in this file, you&#39;ll learn how the system validates paths, processes hierarchical data, and formats the configuration for use in machine learning prompts.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code>: Safely parses the adventure configuration file into a JSON object, ensuring resilience against missing or malformed data.</li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Scans the configuration, identifying and validating all unique file paths referenced in the &quot;path&quot; fields.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code>: Generates a streamlined version of the configuration, optimized for large language models, focusing on minimal yet critical information.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>This function begins by calling <code class="inline-code">loadAdventureConfig</code> to read the raw configuration file.</li>
<li>It uses a <code class="inline-code">try-catch</code> block to safely parse the JSON content while handling any parsing errors gracefully.</li>
<li>If the file is missing or invalid, it returns <code class="inline-code">null</code>, ensuring that downstream processes do not encounter undefined behavior.</li>
<li>This approach demonstrates the importance of fail-safe mechanisms when interacting with external files.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>This function analyzes the parsed configuration object to identify unique file paths listed in &quot;path&quot; fields.</li>
<li>A <code class="inline-code">Set</code> is used to ensure uniqueness, while <code class="inline-code">fs.existsSync</code> validates the existence of each path.</li>
<li>A depth-first approach, using a stack, is employed to traverse and process nested objects and arrays.</li>
<li>This implementation ensures robustness when parsing deeply nested or complex configurations.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>This function generates a concise structure of the adventure configuration, focusing on quest titles, files, and function names.</li>
<li>By omitting verbose descriptions, it significantly reduces the size of the data passed to machine learning systems.</li>
<li>This optimization is critical for improving response times and reducing processing overhead.</li>
<li>It provides an excellent example of tailoring configuration data for specific use cases, such as integration with AI.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">parseAdventureConfig</code> as a blueprint for safely working with JSON data in other parts of the system.</li>
<li>Study the use of <code class="inline-code">Set</code> in <code class="inline-code">extractUniqueFilePaths</code> to learn effective methods for handling unique data in large configurations.</li>
<li>When designing machine learning interfaces, consider how data can be formatted, as shown in <code class="inline-code">formatAdventureConfigForPrompt</code>, to balance detail and efficiency.</li>
</ul>
<hr>
<p>You have mastered all the secrets of this developer tool! Your adventure is complete.</p>
<p>Core systems initialized and utilities optimized‚ÄîQuest 5 achievement unlocked with 80% progress in the deployment pipeline; you&#39;re coding your way to the final milestone like a true architect of the stack! üöÄ‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="summary.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>