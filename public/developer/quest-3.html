<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Code Analysis & Content Pipeline - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Repository Chronicles: The Codebase Codex</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: Code Analysis &amp; Content Pipeline</h1>
<hr>
<p>In this quest, you will delve into the modular underpinnings of the Code Analysis &amp; Content Pipeline. These components ensure structured source code inspections, process automation, and dynamic responses from an integrated language model interface. By investigating these files, you will gain insights into how project structures are validated, code is analyzed, and optimized content flows through the system.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Pipeline Initialization</strong>: How does the code ensure that the project path and target files meet validation requirements before processing?</li>
<li>‚ö° <strong>Request Flow</strong>: What mechanisms are used to construct, execute, and handle AI-based interactions in the content pipeline?</li>
<li>üõ°Ô∏è <strong>Error Management</strong>: How is error handling implemented to manage validation failures, timeouts, or unexpected API responses effectively?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Repo analysis and content optimization</h3>
<p>This file contains the <code class="inline-code">RepoAnalyzer</code> class, which extracts and processes the project context for targeted or optimized analysis using <code class="inline-code">repomix</code>. Key methods offer caching support, input validation, security checks, and asynchronous pipelines.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">validateProjectPath</code>: Verifies the project directory is valid, well-formed, and secure.</li>
<li><code class="inline-code">generateTargetedContent</code>: Produces specific content for validated files, enforcing security and caching the results.</li>
<li><code class="inline-code">captureRepomixStdout</code>: Runs the <code class="inline-code">repomix</code> subprocess to gather codebase metadata for further analysis.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }
  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<ul>
<li>Ensures the provided directory path is not empty or malformed.</li>
<li>Guards against potential security vulnerabilities such as null byte injections.</li>
<li>Prevents invalid inputs that could disrupt file system operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  if (!targetFiles || targetFiles.length === 0) {
    throw new Error(&#39;Target files array cannot be empty&#39;);
  }
  const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
  if (safeFiles.length === 0) {
    throw new Error(&#39;No valid target files found after validation&#39;);
  }
  
  const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    const cliOptions: CliOptions = {
      style: &#39;markdown&#39;,
      compress,
      include: safeFiles.join(&#39;,&#39;),
      noDirectoryStructure: true
    };
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Targeted repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li>Generates content for a subset of files, ensuring the files are validated and sanitized first.</li>
<li>Implements caching to reduce redundant file system operations for frequently requested inputs.</li>
<li>Interfaces with <code class="inline-code">repomix</code> to produce formatted outputs while preventing unnecessary directory data inclusion.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [...directories, &#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
    if (options.compress) args.push(&#39;--compress&#39;);
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd });
    let stdout = &#39;&#39;;
    let isResolved = false;
    const timeout = setTimeout(() =&gt; {
      if (!isResolved) {
        isResolved = true;
        repomix.kill(&#39;SIGTERM&#39;);
        reject(new Error(`Repomix subprocess timed out`));
      }
    }, REPOMIX_SUBPROCESS_TIMEOUT);
  
    repomix.stdout.on(&#39;data&#39;, (data) =&gt; stdout += data.toString());
    repomix.on(&#39;close&#39;, (code) =&gt; {
      clearTimeout(timeout);
      if (!isResolved) {
        isResolved = true;
        code === 0 ? resolve(stdout) : reject(new Error(&#39;Repomix failed&#39;));
      }
    });
    repomix.on(&#39;error&#39;, (error) =&gt; reject(new Error(`Spawn error: ${error.message}`)));
  });
}
</code></pre>
<ul>
<li>Utilizes a child process to execute <code class="inline-code">repomix</code>, capturing its output asynchronously.</li>
<li>Ensures subprocesses have memory and timeout controls for fail-safe operations.</li>
<li>Converts raw process data into formatted and consumable content.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> AI integration for content generation</h3>
<p>The <code class="inline-code">LLMClient</code> class enables the system to interact with language models like OpenAI. It constructs requests, validates responses, and employs specific configurations for different models.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">constructor</code>: Configures the client, sets API parameters, and initializes model-specific settings.</li>
<li><code class="inline-code">generateResponse</code>: Processes prompt inputs and handles AI interactions, managing timeouts and errors robustly.</li>
<li><code class="inline-code">getApiKey</code>: Determines the correct API key based on the service provider for secure integration.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key.&#39;);
  }
  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({
      endpoint: azureEndpoint,
      apiKey,
      apiVersion: LLM_API_VERSION,
      deployment: this.model
    });
  } else {
    this.client = new OpenAI({
      apiKey,
      baseURL: LLM_BASE_URL
    });
  }
}
</code></pre>
<ul>
<li>Configures the language model client based on project environment variables.</li>
<li>Abstracts Azure and OpenAI-specific connection details under a universal interface.</li>
<li>Ensures improper configurations are caught and directly reported to the user.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li>Orchestrates prompt-to-response handling by building API requests through reusable components.</li>
<li>Validates critical response elements such as text content and token usage metrics, ensuring robustness.</li>
<li>Introduces advanced error logging for diagnostic transparency and remediation guidance.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for GitHub Models.&#39;);
    }
    return GITHUB_TOKEN;
  }
  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li>Retrieves API keys dynamically by detecting the associated service provider environment.</li>
<li>Differentiates between GitHub and OpenAI token requirements.</li>
<li>Simplifies secret management by encapsulating validation workflows.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Validate your project paths early to detect any configuration issues.</li>
<li>Reference the <code class="inline-code">generateResponse</code> method for best practices in constructing reusable prompts.</li>
<li>When working with third-party subprocesses like <code class="inline-code">repomix</code>, implement timeouts to safeguard against indefinite hangs.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>You‚Äôve deployed a rock-solid function to parse through the labyrinth of logic in Quest 3‚Äîcode patterns dissected, pipelines optimized; onward to the next milestone with üöÄ precision and ‚ö° determination!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>