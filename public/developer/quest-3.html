<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Analyzer's Lens - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Adventures in the Repository Realms</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Analyzer&#39;s Lens</h1>
<hr>
<p>Among the Repository Realms, the Analyzer&#39;s Lens unveils secrets of the interconnected code. This artifact, wielded by the RepoAnalyzer and powered by the enigmatic LLMClient, performs critical investigations to probe system integrity. The Lens reveals not only the details of file structures but also untangles complex connections between APIs and subsystems to ensure the Archive remains functional. As an Archivist Adventurer, your mastery of this quest ensures efficient pipelines and informed decision-making.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Analyzer Calibration</strong>: How does <code class="inline-code">RepoAnalyzer.validateProjectPath</code> ensure safety measures for project paths before processing?</li>
<li>‚ö° <strong>Content Extraction</strong>: What techniques does <code class="inline-code">RepoAnalyzer.generateRepomixContext</code> use to optimize token usage without sacrificing output quality?</li>
<li>üõ°Ô∏è <strong>LLM Invocation</strong>: How does <code class="inline-code">LLMClient.generateResponse</code> handle errors during API interactions and ensure robust execution flow?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Responsible for analyzing repository content and generating optimized code outputs.</h3>
<p>The <code class="inline-code">RepoAnalyzer</code> implements methods to process and validate project paths and target files securely, preventing invalid or unsafe inputs such as null bytes and path traversal attacks. It also caches results for efficiency, avoids redundant computation, and integrates repomix directly for content extraction. Through key methods like <code class="inline-code">generateRepomixContext</code> and <code class="inline-code">captureRepomixStdout</code>, it ensures memory safety and timeout handling while leveraging subprocesses.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAnalyzer.validateProjectPath</code>: Validates project paths for null bytes and unsafe patterns.</li>
<li><code class="inline-code">RepoAnalyzer.generateRepomixContext</code>: Optimizes code extraction while ensuring performance and compression.</li>
<li><code class="inline-code">RepoAnalyzer.captureRepomixStdout</code>: Captures output safely from subprocesses, managing memory and time limits.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> Manages communication with various LLM providers to generate responses for the Repository Realms.</h3>
<p>The <code class="inline-code">LLMClient</code> interfaces with OpenAI and Azure OpenAI APIs, dynamically configuring requests based on available keys and environment details. This class prioritizes robust error handling and clear logging, ensuring failures are reported comprehensively. Functions like <code class="inline-code">generateResponse</code> orchestrate requests while parameters such as verbosity and reasoning effort fine-tune LLM output.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">LLMClient.constructor</code>: Initializes client with dynamic API key and model selection.</li>
<li><code class="inline-code">LLMClient.getApiKey</code>: Determines the correct API key based on the provider.</li>
<li><code class="inline-code">LLMClient.generateResponse</code>: Handles API requests with validation, retries, and error logging.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<p>This validation method acts as the gatekeeper, ensuring paths are sanitized before further processing.</p>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);
  
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    // Configure repomix options
    const cliOptions: CliOptions = {
      style: options.style || &#39;markdown&#39;,
      compress: true,
      ignore: [&#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;],
      removeComments: true,
      noDirectoryStructure: true
    };

    // Capture stdout during repomix execution
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);

    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<p>This snippet highlights dynamic adjustments for repomix execution, optimizing efficiency and cache usage.</p>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    // Spawn repomix as subprocess
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] });

    let stdout = &#39;&#39;;
    let stdoutSize = 0;

    // Set timeout
    const timeout = setTimeout(() =&gt; {
      repomix.kill(&#39;SIGTERM&#39;);
      reject(new Error(&#39;Repomix subprocess timeout&#39;));
    }, REPOMIX_SUBPROCESS_TIMEOUT);

    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      const chunk = data.toString();
      stdoutSize += chunk.length;

      if (stdoutSize &gt; REPOMIX_MAX_BUFFER_SIZE) {
        repomix.kill(&#39;SIGKILL&#39;);
        reject(new Error(&#39;Repomix output too large&#39;));
      }

      stdout += chunk;
    });

    repomix.on(&#39;close&#39;, (code) =&gt; {
      clearTimeout(timeout);
      code === 0 ? resolve(stdout) : reject(new Error(&#39;Repomix failed.&#39;));
    });
  });
}
</code></pre>
<p>This function safeguards against oversized output and excessive timeout during subprocess execution.</p>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  const apiKey = this.getApiKey();

  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required.&#39;);
  }

  this.client = LLM_BASE_URL.includes(&#39;.azure.com&#39;)
    ? new AzureOpenAI({ endpoint: LLM_BASE_URL, apiKey, apiVersion: LLM_API_VERSION })
    : new OpenAI({ apiKey, baseURL: LLM_BASE_URL });
}
</code></pre>
<p>Dynamic client initialization ensures compatibility with multiple LLM providers.</p>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;azure.com&#39;)) {
    if (!GITHUB_TOKEN) throw new Error(&#39;GITHUB_TOKEN required for Azure.&#39;);
    return GITHUB_TOKEN;
  }
  if (!LLM_API_KEY) throw new Error(&#39;LLM_API_KEY required.&#39;);
  return LLM_API_KEY;
}
</code></pre>
<p>Here, the method intelligently picks API keys based on provider configuration.</p>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    const content = this.validateResponse(completion);
    
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }

    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error.message}`);
  }
}
</code></pre>
<p>At the heart of request handling, this method validates responses and applies formatting for optimal results.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Use strict path validation to avoid potential security vulnerabilities.</li>
<li>Experiment with varying compression levels for optimizing repomix outputs.</li>
<li>When debugging API failures, leverage <code class="inline-code">logDetailedError</code> to trace misconfigurations effectively.</li>
</ul>
<hr>
<p>Congratulations, Archivist Adventurer! You have grasped the secrets of the Analyzer&#39;s Lens. Use its insights to navigate deeper into the Repository Realms!</p>
<p>Quest 3: The Analyzer&#39;s Lens has been successfully debugged and deployed with precision‚Äîyou&#39;re 40% into your epic codebase adventure, forging algorithms like a champion and optimizing brilliance one function at a time! üöÄüëÅÔ∏è‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>