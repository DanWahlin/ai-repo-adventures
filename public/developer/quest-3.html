<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Quest Generation Engine - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-developer">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Architecture of Adventures: An Exploration of a Developer's Toolkit</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest Generation Engine</h1>
<hr>
<p>Explore the technical depths of the Quest Generation Engine, a vital module that powers dynamic story creation and quest execution within your codebase. This engine handles the initialization of adventures, story generation, and configuration parsing to deliver rich interactive experiences. With a focus on modular design, this quest unveils how the components interact to create scalable narratives.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:  </p>
<ul>
<li>üîç <strong>Initialization Framework</strong>: How does <code class="inline-code">AdventureManager.initializeAdventure</code> set up the project context and configure key components for adventure generation?  </li>
<li>‚ö° <strong>Quest Execution Flow</strong>: What is the role of <code class="inline-code">AdventureManager.exploreQuest</code> in validating user choices and executing quests?  </li>
<li>üõ°Ô∏è <strong>Config Parsing Mechanisms</strong>: How do <code class="inline-code">parseAdventureConfig</code> and <code class="inline-code">extractUniqueFilePaths</code> process configuration files and extract actionable data for quest generation?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Adventure Initialization and Execution</h3>
<p>This file defines the <code class="inline-code">AdventureManager</code> class, which manages the lifecycle of interactive adventures, including initializing adventures and exploring quests. It centralizes logic related to user input validation, state management, and story/quest content generation, ensuring seamless integration with other modules.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code>: Resets state, sets up project/theme context, and generates quests using collaborative LLMS. Integrates configuration data for enhanced quest accuracy.  </li>
<li><code class="inline-code">exploreQuest</code>: Validates user input, retrieves quest data, executes the quest, and updates progress tracking. Optimizes completed quests with caching for efficiency.  </li>
<li><code class="inline-code">AdventureState.progressPercentage</code>: Computes percentage progress based on completed quests to dynamically track adventure milestones.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo,
  theme: AdventureTheme,
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();

  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);

  this.state.title = storyResponse.title;
  this.state.story = storyResponse.story;

  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  return this.formatStoryWithQuests({ ...storyResponse, quests: this.state.quests });
}
</code></pre>
<ul>
<li>Handles state resets for new adventures, ensuring clean initialization.  </li>
<li>Integrates custom themes by applying user-defined data during story generation.  </li>
<li>Uses LLMs to dynamically create stories and quests, leveraging configuration integration for tailored quest design.</li>
</ul>
<hr>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);

  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }

  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }

  return await this.executeQuest(quest);
}
</code></pre>
<ul>
<li>Validates and sanitizes user input to mitigate invalid or unsafe adventure choices.  </li>
<li>Enables progress tracking and retrieval based on user queries.  </li>
<li>Uses caching for completed quests to optimize execution and minimize redundant generation.</li>
</ul>
<hr>
<pre><code class="language-typescript">get progressPercentage(): number {
  return this.quests.length &gt; 0 
    ? Math.round((this.completedQuests.size / this.quests.length) * 100) 
    : 0;
}
</code></pre>
<ul>
<li>Calculates and updates adventure progress as quests are completed.  </li>
<li>Simplifies user feedback with dynamic percentage tracking for milestones.  </li>
<li>Highlights modularity by encapsulating a specific feature within <code class="inline-code">AdventureState</code>.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration Parsing</h3>
<p>This file handles reading, parsing, and extracting data from configuration files that define quest structures. It focuses on efficient file operations and JSON validation to ensure data integrity.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code>: Parses JSON configuration files to extract adventure-related definitions, ensuring quests align with project requirements.  </li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Recursively searches configuration files for unique file paths to facilitate code analysis during quest generation.  </li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code>: Prepares readable quest structure and file definitions for LLM-guided adventures, reducing verbosity while retaining key data.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Centralizes JSON parsing logic, minimizing risks of malformed data for interactive quests.  </li>
<li>Returns clean or null responses to prevent downstream errors during configuration analysis.  </li>
<li>Emphasizes reliability and abstraction for configuration handling.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Implements recursive exploration of object paths to extract meaningful code references for quests.  </li>
<li>Uses safe file-system operations to validate existence and accuracy of extracted paths.  </li>
<li>Highlights modular design by segregating parsing logic and path validation.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;

    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Reduces verbose descriptions in configuration files for streamlined parsing by LLMs.  </li>
<li>Outputs structured details about quest files and functions to enhance prompt clarity.  </li>
<li>Improves modular systems by separating summary generation from core file parsing.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/adventure/story-generator.ts:</span> Story Creation</h3>
<p>This file encapsulates logic for generating the overarching narrative and quests, leveraging LLM APIs and configuration-guided exploration.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateStoryAndQuests</code>: Creates comprehensive adventure narratives, enriched with modular quest generation for thematic consistency.  </li>
<li><code class="inline-code">generateQuestContent</code>: Produces in-depth content for individual quests, adapting to project requirements and context-specific data.  </li>
<li><code class="inline-code">parseMarkdownToStoryResponse</code>: Converts markdown results into structured story and quest objects for seamless adventure integration.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
  this.currentProject = projectInfo;
  this.projectPath = projectPath;

  const validatedTheme = this.validateTheme(theme);
  return await this.generateWithLLM(projectInfo, validatedTheme);
}
</code></pre>
<ul>
<li>Validates theme specifications and generates structured narratives for quests.  </li>
<li>Centralizes LLM-driven generation for project-specific adventures.  </li>
<li>Highlights modularity by decoupling story generation from initialization workflows.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateQuestContent(config: QuestGenerationConfig): Promise&lt;QuestContent&gt; {
  const { quest, theme, codeContent, questPosition, totalQuests } = config;

  let adventureGuidance = &#39;&#39;;
  let customInstructions = &#39;&#39;;

  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }

    const customInstructionsFromConfig = extractCustomInstructions(this.projectPath);
    if (customInstructionsFromConfig) {
      customInstructions = customInstructionsFromConfig;
    }
  }

  const prompt = loadQuestContentPrompt({
    theme,
    adventureTitle: quest.title,
    codeContent,
    storyContent: this.currentStoryContent || &#39;No story context available.&#39;,
    adventureGuidance: adventureGuidance || &#39;&#39;,
    ...(customInstructions &amp;&amp; { customInstructions }),
    questPosition,
    totalQuests,
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  });

  const response = await this.withTimeout(
    this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_QUEST })
  );

  return {
    adventure: response.content.trim(),
    fileExploration: &#39;&#39;,
    codeSnippets: [],
    hints: []
  };
}
</code></pre>
<ul>
<li>Dynamically generates quest prompts enriched with configuration data.  </li>
<li>Defines fallback mechanisms for missing project paths or malformed prompts.  </li>
<li>Validates responses for consistency and integrates them seamlessly into quests.</li>
</ul>
<hr>
<pre><code class="language-typescript">function parseMarkdownToStoryResponse(markdownContent: string): StoryResponse {
  const tokens = marked.lexer(markdownContent);

  const title = extractTitle(tokens);
  let story = &#39;&#39;;
  const quests: Quest[] = [];

  let currentSection = &#39;&#39;;
  let currentQuest: Partial&lt;Quest&gt; = {};
  let titleFound = false;

  for (const token of tokens) {
    if (token.type === &#39;heading&#39;) {
      if (token.depth === 1) {
        titleFound = true;
        currentSection = &#39;story&#39;;
      } else if (token.depth === 2) {
        currentSection = token.text.toLowerCase();
      } else if (token.depth === 3 &amp;&amp; isQuestSection(currentSection)) {
        if (currentQuest.title &amp;&amp; currentQuest.description) {
          quests.push(createQuest(currentQuest, quests.length));
        }
        currentQuest = { title: token.text, description: &#39;&#39;, codeFiles: [] };
      }
    } else if (token.type === &#39;paragraph&#39;) {
      if (isStorySection(currentSection, titleFound)) {
        story += token.text + &#39;\n\n&#39;;
      } else if (currentQuest.title) {
        currentQuest.description += token.text + &#39;\n\n&#39;;
      }
    } else if (token.type === &#39;list&#39; &amp;&amp; currentQuest.title) {
      extractCodeFilesFromList(token, currentQuest);
    }
  }

  if (currentQuest.title &amp;&amp; currentQuest.description) {
    quests.push(createQuest(currentQuest, quests.length));
  }

  return { title, story, quests };
}
</code></pre>
<ul>
<li>Uses token-based parsing to extract key sections from markdown results.  </li>
<li>Maps structured data into story and quest objects for accuracy and clean integration.  </li>
<li>Implements error handling for invalid or incomplete markdown tokens.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Experiment with configuration files to add custom quests and enhance adventure narratives.  </li>
<li>Use modular patterns to isolate feature-specific logic for maintainability.  </li>
<li>Focus on optimizing caching mechanisms to reduce performance overhead during quest revisits.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Congratulations on successfully deploying the Quest Generation Engine‚Äîyour architecture is scaling beautifully through the codebase; keep refactoring forward, developer champion! üöÄ‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>