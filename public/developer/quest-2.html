<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: The Forge of Story and State - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Mythic Repository Chronicles</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: The Forge of Story and State</h1>
<hr>
<p>This guide examines how story generation and quest progression are implemented in a developer-oriented adventure engine. We focus on state handling, LLM integration, configuration-driven behavior, and file-scoped content targeting. The objective is to understand concrete implementation patterns by reviewing selected files and their highlighted functions. Use the objectives as exploration guides while reading the code sections. All examples are drawn directly from the two core modules responsible for narrative production and runtime state operations that govern adventure flow and configuration integration.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">AdventureManager.initializeAdventure</code> merge configuration-driven quest files and enforce quest counts before presenting the initial story and choices?</li>
<li>‚ö° Flow Weaving: In <code class="inline-code">AdventureManager.exploreQuest</code>, when and how does the manager decide to serve cached content versus generating fresh quest output?</li>
<li>üõ°Ô∏è Safety Seals: How do <code class="inline-code">AdventureState.progressPercentage</code> and validation calls ensure robust behavior across progress queries and quest execution?</li>
<li>üîç Prompt Alchemy: In <code class="inline-code">StoryGenerator.generateStoryAndQuests</code>, how is formatted configuration context included in prompts, and how does <code class="inline-code">parseMarkdownToStoryResponse</code> structure results?</li>
<li>‚ö° Timeout Ward: Where does <code class="inline-code">StoryGenerator.withTimeout</code> wrap LLM calls, and what is the effect on reliability and error pathways?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Orchestrating state, choices, and quest execution</h3>
<p>This module manages lifecycle, state, and user-driven quest selection. <code class="inline-code">AdventureManager.initializeAdventure</code> resets <code class="inline-code">AdventureState</code>, configures the theme, calls <code class="inline-code">StoryGenerator.generateStoryAndQuests</code>, and then merges configuration-defined file scopes by invoking <code class="inline-code">mergeQuestFilesFromConfig</code>. It also enforces the quest count based on <code class="inline-code">adventure.config.json</code> using <code class="inline-code">enforceConfigQuestCount</code>. On selection, <code class="inline-code">exploreQuest</code> validates input with <code class="inline-code">validateAdventureChoice</code>, detects progress requests via <code class="inline-code">isProgressRequest</code>, and finds a quest through <code class="inline-code">findQuest</code>. Execution flows through <code class="inline-code">executeQuest</code>, which checks prerequisites (<code class="inline-code">projectInfo</code>, <code class="inline-code">currentTheme</code>) and either retrieves cached quest content or generates new content using <code class="inline-code">generateQuestContent</code> and <code class="inline-code">generateCompletionSummary</code>. For targeted context, <code class="inline-code">generateQuestContent</code> calls <code class="inline-code">repoAnalyzer.generateTargetedContent</code> when <code class="inline-code">codeFiles</code> are specified, otherwise it uses the complete <code class="inline-code">repomixContent</code>. The state‚Äôs completion tracking influences <code class="inline-code">progressPercentage</code> and result formatting for subsequent choices. The manager returns structured narratives via <code class="inline-code">formatStoryWithQuests</code> and <code class="inline-code">formatQuestResult</code>, and surfaces a uniform choice list that marks completed items with a checkmark. This pattern demonstrates a clean separation of concerns: input validation, selection logic, content generation, caching, and output formatting.</p>
<h4>Highlights</h4>
<ul>
<li>State reset and initialization, story/quests generation, config merge, and quest count enforcement</li>
<li>Input validation, progress detection, quest lookup, caching vs. fresh LLM generation</li>
<li>Progress computation and robust preconditions preventing invalid execution</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  // Reset state for new adventure
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  
  // Set custom theme data if provided
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  // Generate the overall story and quests using LLM
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  
  this.state.title = storyResponse.title;
  this.state.story = typeof storyResponse.story === &#39;string&#39; ? storyResponse.story : storyResponse.story.content;
  
  // Merge files from adventure config into the generated quests
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  
  // Enforce quest count from adventure.config.json if it exists
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  // Return the story with available quests
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<p>Think of this like setting up a workshop: clear the bench, load the materials, apply configuration fixtures, and present a plan to follow.</p>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);
  
  // Check if this is a progress request
  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }
  
  // Find the quest based on the choice
  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }

  // Execute the quest
  return await this.executeQuest(quest);
}
</code></pre>
<p>This functions like a dispatcher: validate, detect special routes, locate the item, and pass it to the executor.</p>
<pre><code class="language-typescript">get progressPercentage(): number {
  return this.quests.length &gt; 0 
    ? Math.round((this.completedQuests.size / this.quests.length) * 100)
    : 0;
}
</code></pre>
<p>This is a completion gauge, turning progress into a simple percentage.</p>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
  this.currentProject = projectInfo;
  this.projectPath = projectPath;
  
  const validatedTheme = this.validateTheme(theme);
  return await this.generateWithLLM(projectInfo, validatedTheme);
}
</code></pre>
<p>This is a controller that validates inputs and hands off to an LLM-backed generator.</p>
<pre><code class="language-typescript">private async withTimeout&lt;T&gt;(promise: Promise&lt;T&gt;, timeoutMs: number = LLM_REQUEST_TIMEOUT): Promise&lt;T&gt; {
  const timeoutPromise = new Promise&lt;never&gt;((_, reject) =&gt; {
    setTimeout(() =&gt; reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
  
  return Promise.race([promise, timeoutPromise]);
}
</code></pre>
<p>This acts like a circuit breaker to prevent calls from hanging indefinitely.</p>
<pre><code class="language-typescript">private async generateWithLLM(projectInfo: ProjectInfo, theme: AdventureTheme): Promise&lt;StoryResponse&gt; {
  const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
  
  // Use formatted adventure config instead of raw JSON
  let adventureGuidance = &#39;&#39;;
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
  }

  const prompt = loadStoryGenerationPrompt({
    theme,
    repomixContent,
    ...(adventureGuidance &amp;&amp; { adventureGuidance }),
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  });

  const response = await this.withTimeout(
    this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY })
  );
  
  if (!response.content || response.content.trim() === &#39;&#39;) {
    throw new Error(&#39;LLM returned empty response&#39;);
  }
  
  let parsed;
  try {
    // Preprocess response to remove markdown code block wrapper if present
    let cleanContent = response.content.trim();
    if (cleanContent.startsWith(&#39;```markdown&#39;)) {
      cleanContent = cleanContent.replace(/^```markdown\s*/, &#39;&#39;).replace(/\s*```$/, &#39;&#39;);
    }
    
    parsed = parseMarkdownToStoryResponse(cleanContent);
    // Validate with Zod schema for safety
    StoryResponseSchema.parse(parsed);
    
    // Store the story content for consistency in quest generation
    this.currentStoryContent = typeof parsed.story === &#39;string&#39; ? parsed.story : parsed.story.content;
  } catch (error) {
    console.error(&#39;üí• Parsing error:&#39;, error instanceof Error ? error.message : &#39;Unknown error&#39;);
    console.error(&#39;üí• Full response:&#39;, response.content);
    throw new Error(`Invalid LLM response for story: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}. Response: ${response.content.substring(0, 200)}...`);
  }
  return parsed;
}
</code></pre>
<p>This is a pipeline: build prompt, call LLM with a timeout, sanitize, parse into structure, validate, and persist story context.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Validate the chosen theme and inputs early to avoid ambiguity in downstream calls.</li>
<li>Use <code class="inline-code">mergeQuestFilesFromConfig</code> and <code class="inline-code">enforceConfigQuestCount</code> to align generated quests with configuration.</li>
<li>Prefer targeted content generation when <code class="inline-code">codeFiles</code> are available to keep prompts focused and actionable.</li>
</ul>
<hr>
<p>Quest 2 complete. Proceed to examine configuration-driven file selection and targeted content generation in your implementation.</p>
<p>Quest 2: The Forge of Story and State successfully merged into main‚Äîexcellent commit advancing narrative architecture and system governance patterns to 20% completion; keep iterating with high test coverage and scalable abstractions to propel the roadmap forward üöÄ‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-1.html" class="prev-quest-btn">‚Üê Previous: Quest 1</a>
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>