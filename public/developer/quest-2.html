<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: Forge of Stories and Quests - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Codex: Navigating the Repository Constellation</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h2>Quest 2: Forge of Stories and Quests</h2>
<p>In this guide, you will operate the story engine that converts repository context into operable developer quests. You will examine how initialization, quest execution, and configuration-aware merging work together to produce actionable content. You will also review the generation pipeline that validates themes, orchestrates LLM prompts, parses markdown into structured data, and applies timeouts for stability. These exploration guides are questions to pursue while reading the code, helping you trace flows, recognize patterns, and understand design decisions that power the mission briefs and quest logs.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">AdventureManager.initializeAdventure</code> inject config-driven files into LLM-generated quests, and in what order of precedence?</li>
<li>‚ö° Reactor Spin-up: What timeout and validation safeguards does <code class="inline-code">StoryGenerator.generateWithLLM</code> apply when prompting and parsing?</li>
<li>üõ°Ô∏è Safety Shields: How does <code class="inline-code">AdventureManager.exploreQuest</code> route choices, detect progress requests, and avoid invalid selections before executing a quest?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Orchestrates story initialization, quest selection, execution, caching, and config merging</h3>
<p>This manager coordinates the end-to-end flow from story creation to quest exploration. The <code class="inline-code">initializeAdventure</code> method resets state, assigns project context and theme, optionally sets <code class="inline-code">customThemeData</code>, requests the story/quests from <code class="inline-code">StoryGenerator</code>, merges config-defined files via <code class="inline-code">mergeQuestFilesFromConfig</code>, enforces quest counts with <code class="inline-code">enforceConfigQuestCount</code>, and formats the initial listing. Quest execution starts in <code class="inline-code">exploreQuest</code>, which sanitizes input through <code class="inline-code">validateAdventureChoice</code>, branches to progress reporting via <code class="inline-code">isProgressRequest</code>, resolves the target quest by number or fuzzy title/ID, and handles a not-found path. The execution path <code class="inline-code">executeQuest</code> validates prerequisites, leverages a cache for previously completed quests (including a revisit indicator), otherwise generates content and completion summary, caches results, marks completion, and returns a formatted response with updated choices and progress. The manager also integrates repo analysis for targeted content in <code class="inline-code">generateQuestContent</code>, falling back to full <code class="inline-code">repomixContent</code> on errors. Configuration is incorporated through <code class="inline-code">parseAdventureConfig</code> enabling deterministic quest-file bindings and quest count enforcement. Collectively, this module demonstrates robust input validation, deterministic output control via config, caching for responsiveness, and user-centric progress reporting.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code> sets project context, theme, and uses <code class="inline-code">StoryGenerator.generateStoryAndQuests</code>, then merges and enforces config-based quest structure to produce a stable mission brief.</li>
<li><code class="inline-code">exploreQuest</code> validates choices, supports progress queries, resolves quests by index or title/ID, and funnels execution through a consistent path.</li>
<li><code class="inline-code">generateQuestContent</code> selects targeted file context via <code class="inline-code">repoAnalyzer.generateTargetedContent</code> with fallback to <code class="inline-code">repomixContent</code>, ensuring relevant payloads for LLM prompts.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
  ): Promise&lt;string&gt; {
  // Reset state for new adventure
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  
  // Set custom theme data if provided
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  // Generate the overall story and quests using LLM
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  
  this.state.title = storyResponse.title;
  this.state.story = storyResponse.story;
  
  // Merge files from adventure config into the generated quests
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  
  // Enforce quest count from adventure.config.json if it exists
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  // Return the story with available quests
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<ul>
<li>Initializes a fresh state and binds <code class="inline-code">projectInfo</code>, <code class="inline-code">theme</code>, and <code class="inline-code">projectPath</code>.</li>
<li>Integrates <code class="inline-code">customThemeData</code> for the <code class="inline-code">custom</code> theme path via <code class="inline-code">setCustomTheme</code>.</li>
<li>Delegates story and quest generation to <code class="inline-code">StoryGenerator.generateStoryAndQuests</code>.</li>
<li>Applies config-driven file merging and quest count enforcement for deterministic outputs.</li>
<li>Returns a formatted story with a curated list of available quests.</li>
</ul>
<hr>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);
  
  // Check if this is a progress request
  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }
  
  // Find the quest based on the choice
  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }

  // Execute the quest
  return await this.executeQuest(quest);
}
</code></pre>
<ul>
<li>Validates and normalizes user input through <code class="inline-code">validateAdventureChoice</code>.</li>
<li>Branches to an immediate progress response when applicable via <code class="inline-code">isProgressRequest</code>.</li>
<li>Resolves quests via number or ID/title search and provides a graceful not-found result.</li>
<li>Centralizes quest execution flow, enabling caching, summaries, and progress updates.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async generateQuestContent(quest: Quest): Promise&lt;QuestContent&gt; {
  let codeContent: string;
  
  // Use targeted content if quest has specific files, otherwise use full repomix content
  if (quest.codeFiles &amp;&amp; quest.codeFiles.length &gt; 0 &amp;&amp; this.state.projectPath) {
    try {
      console.log(`üéØ Generating targeted content for ${quest.codeFiles.length} files`);
      codeContent = await repoAnalyzer.generateTargetedContent(
        this.state.projectPath,
        quest.codeFiles,
        false  // Use uncompressed content for detailed quest exploration
      );
    } catch (error) {
      console.warn(`Failed to generate targeted content, falling back to full repomix content:`, error);
      codeContent = this.state.projectInfo!.repomixContent;
    }
  } else {
    // Fallback to full repomix content
    codeContent = this.state.projectInfo!.repomixContent;
  }

  // Calculate quest position for completion message guidance
  const questPosition = this.state.quests.findIndex(q =&gt; q.id === quest.id) + 1;
  const totalQuests = this.state.quests.length;

  return await this.storyGenerator.generateQuestContent(
    quest,
    this.state.currentTheme!,
    codeContent,
    questPosition,
    totalQuests
  );
}
</code></pre>
<ul>
<li>Prefers focused repository slices using <code class="inline-code">repoAnalyzer.generateTargetedContent</code>, with robust fallback to full content.</li>
<li>Computes positional metadata for improved completion messaging.</li>
<li>Delegates LLM content synthesis to <code class="inline-code">StoryGenerator.generateQuestContent</code> with the selected code context.</li>
<li>Balances precision and resilience to keep the content pipeline reliable.</li>
<li>Highlights a pattern of guarded I/O with meaningful fallbacks.</li>
</ul>
<hr>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
  this.currentProject = projectInfo;
  this.projectPath = projectPath;
  
  const validatedTheme = this.validateTheme(theme);
  return await this.generateWithLLM(projectInfo, validatedTheme);
}
</code></pre>
<ul>
<li>Stores project context and path for downstream prompt construction.</li>
<li>Normalizes the theme via <code class="inline-code">validateTheme</code> to ensure supported modes are used.</li>
<li>Delegates to <code class="inline-code">generateWithLLM</code> for the end-to-end prompt, response, and parsing process.</li>
<li>Encapsulates a clean API for callers without leaking LLM specifics.</li>
<li>Demonstrates separation of validation and generation responsibilities.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async generateWithLLM(projectInfo: ProjectInfo, theme: AdventureTheme): Promise&lt;StoryResponse&gt; {
  const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
  
  // Use formatted adventure config instead of raw JSON
  let adventureGuidance = &#39;&#39;;
  let customInstructions = &#39;&#39;;
  
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
    
    const customInstructionsFromConfig = extractCustomInstructions(this.projectPath);
    if (customInstructionsFromConfig) {
      customInstructions = customInstructionsFromConfig;
    }
  }

  const prompt = loadStoryGenerationPrompt({
    theme,
    repomixContent,
    ...(adventureGuidance &amp;&amp; { adventureGuidance }),
    ...(customInstructions &amp;&amp; { customInstructions }),
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  });

  const response = await this.withTimeout(
    this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY })
  );
  
  if (!response.content || response.content.trim() === &#39;&#39;) {
    throw new Error(&#39;LLM returned empty response&#39;);
  }
  
  let parsed;
  try {
    // Preprocess response to remove markdown code block wrapper if present
    let cleanContent = response.content.trim();
    if (cleanContent.startsWith(&#39;```markdown&#39;)) {
      cleanContent = cleanContent.replace(/^```markdown\s*/, &#39;&#39;).replace(/\s*```$/, &#39;&#39;);
    }
    
    parsed = parseMarkdownToStoryResponse(cleanContent);
    // Validate with Zod schema for safety
    StoryResponseSchema.parse(parsed);
    
    // Store the story content for consistency in quest generation
    this.currentStoryContent = parsed.story;
  } catch (error) {
    console.error(&#39;üí• Parsing error:&#39;, error instanceof Error ? error.message : &#39;Unknown error&#39;);
    console.error(&#39;üí• Full response:&#39;, response.content);
    throw new Error(`Invalid LLM response for story: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}. Response: ${response.content.substring(0, 200)}...`);
  }
  return parsed;
}
</code></pre>
<ul>
<li>Builds prompts with <code class="inline-code">repomixContent</code>, formatted config via <code class="inline-code">formatAdventureConfigForPrompt</code>, and optional <code class="inline-code">customInstructions</code>.</li>
<li>Enforces responsiveness and stability using <code class="inline-code">withTimeout</code> wrapped LLM calls.</li>
<li>Parses markdown responses through <code class="inline-code">parseMarkdownToStoryResponse</code> and validates with <code class="inline-code">StoryResponseSchema</code>.</li>
<li>Stores canonical story text for consistent quest generation context.</li>
<li>Contains robust error propagation with truncated response echoing for diagnostics.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateQuestContent(
  quest: Quest,
  theme: AdventureTheme,
  codeContent: string,
  questPosition?: number,
  totalQuests?: number
): Promise&lt;QuestContent&gt; {
  // Include formatted adventure config as context if available
  let adventureGuidance = &#39;&#39;;
  let customInstructions = &#39;&#39;;
  
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
    
    const customInstructionsFromConfig = extractCustomInstructions(this.projectPath);
    if (customInstructionsFromConfig) {
      customInstructions = customInstructionsFromConfig;
    }
  }

  const prompt = loadQuestContentPrompt({
    theme,
    adventureTitle: quest.title,
    codeContent,
    storyContent: this.currentStoryContent || &#39;No story context available.&#39;,
    adventureGuidance: adventureGuidance || &#39;&#39;,
    ...(customInstructions &amp;&amp; { customInstructions }),
    questPosition,
    totalQuests,
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  }) + &#39;\n\nIMPORTANT: Respond with ONLY markdown content between explicit delimiters.\n\nFormat your response EXACTLY like this:\n\n---BEGIN MARKDOWN---\n[Your markdown content here starting with the quest title]\n

Milestone unlocked: Quest 2: Forge of Stories and Quests completed‚Äîcommit merged to main with 20% progress achieved, test suite green, velocity trending up, and your narrative architecture refactor delivers robust, scalable quest logic‚Äîkeep shipping ‚≠êüöÄ‚ö°.
</code></pre>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-1.html" class="prev-quest-btn">‚Üê Previous: Quest 1</a>
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>