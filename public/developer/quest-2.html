<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: The Quest Architect – Forging Adventures from Lore - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'developer' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Codex Chronicles: Guardians of the Repository</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: The Quest Architect – Forging Adventures from Lore</h1>
<hr>
<p>As the Repository&#39;s secrets unfurl before you, this quest beckons. You are charged with the noble task of sculpting pathways for future adventurers, weaving lore into code-fueled journeys that enrich the archive. Armed with the configuration tools of creation, and the dynamic energy of the Generator’s magic, you&#39;ll roam deep into the core of story architecture. The Repository pulses with narratives yet unexplored—forge them, Guardian, and give shape to boundless adventures awaiting discovery!</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Adventure orchestration managing state, themes, and interactions</h3>
<p>The <code class="inline-code">adventure-manager.ts</code> file serves as the command center of the adventure system, orchestrating every phase of interaction and narrative flow within the Repository. Its dual pillars are the <code class="inline-code">AdventureManager</code> and <code class="inline-code">AdventureState</code> classes. <code class="inline-code">AdventureManager</code> is the engine behind quest execution, handling initialization, generating quests with the <code class="inline-code">StoryGenerator</code> class, and managing state updates with precision. The <code class="inline-code">AdventureState</code> class complements this by maintaining real-time progress tracking, such as percentage completion (<code class="inline-code">progressPercentage</code>) and caching the content of completed quests for efficiency. Key methods like <code class="inline-code">initializeAdventure()</code> set the stage by constructing themes and quests through logical analysis, while <code class="inline-code">exploreQuest()</code> enables users to dive into quests via validated choices. The code offers collaboration between modern <code class="inline-code">LLMClient</code> responses and repository insights, blending technical exploration with narrative wonder. The file is designed robustly—resilient against invalid input and reliant on <code class="inline-code">validateAdventureChoice()</code> to ensure seamless user experiences.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure()</code>: Merges repository context into quests and begins story generation.  </li>
<li><code class="inline-code">exploreQuest()</code>: Guides users into chosen quests with validation and retrieval logic.  </li>
<li><code class="inline-code">progressPercentage</code>: Tracks adventure progress dynamically with precision.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration system for guided adventures</h3>
<p>The <code class="inline-code">adventure-config.ts</code> file serves as the Repository&#39;s guiding compass, delving deep into the adventure.config.json file to deliver structured configurations for quest generation. Its central role lies in loading, parsing, and formatting this configuration. Functions like <code class="inline-code">loadAdventureConfig()</code> and <code class="inline-code">parseAdventureConfig()</code> ensure the seamless integration of external project setups, enabling quests to adapt to the user&#39;s context while securely validating paths. As a powerful ally to the <code class="inline-code">StoryGenerator</code>, <code class="inline-code">formatAdventureConfigForPrompt()</code> translates raw configuration data into structured prompts, making LLM responses inherently more insightful and tailored. This file also extracts key highlights from quests, saving users from sifting through dense files by pinpointing code areas demanding exploration.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig()</code>: Parses JSON with validation for consistency and correctness.  </li>
<li><code class="inline-code">formatAdventureConfigForPrompt()</code>: Structures data for LLM interaction using adventure themes.  </li>
<li><code class="inline-code">extractUniqueFilePaths()</code>: Produces secure, singular paths for analysis-ready files.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/adventure/story-generator.ts:</span> LLM-powered story creation</h3>
<p>The <code class="inline-code">story-generator.ts</code> file is a technological marvel, blending modern AI&#39;s computational storytelling with human-readable adventure outputs. At its core, the file utilizes the <code class="inline-code">StoryGenerator</code> class to craft lore-driven narratives. Functions like <code class="inline-code">generateStoryAndQuests()</code> use the Repository’s codebase to extract coherent journeys, while <code class="inline-code">generateCompletionSummary()</code> adds artistic flair to progress updates using designed prompts. Key schemas like <code class="inline-code">QuestSchema</code> and <code class="inline-code">StoryResponseSchema</code> ensure reliable structure to data flowing between internal components. Its ability to generate quest-specific content (<code class="inline-code">generateQuestContent()</code>) reflects a dynamic approach—transforming code files into playable adventures, while validating inputs with <code class="inline-code">parseMarkdownToStoryResponse()</code> to create streamlined paths of exploration. The generator ties each adventure into its theme seamlessly, providing configurable options that map genres to Repository characteristics.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateStoryAndQuests()</code>: Converts Repository context into playable quests and narratives.  </li>
<li><code class="inline-code">generateQuestContent()</code>: Fuses project details, Repository lore, and user prompts efficiently.  </li>
<li><code class="inline-code">QuestSchema</code>: Ensures structured format to quests with defined fields like <code class="inline-code">id</code>, <code class="inline-code">title</code>, and <code class="inline-code">description</code>.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">export class AdventureManager {
  private state: AdventureState = new AdventureState();
  private storyGenerator: StoryGenerator;

  constructor() {
    this.storyGenerator = new StoryGenerator();
  }

  async initializeAdventure(
    projectInfo: ProjectInfo, 
    theme: AdventureTheme, 
    projectPath?: string,
    customThemeData?: CustomThemeData
  ): Promise&lt;string&gt; {
    this.state.reset();
    this.state.projectInfo = projectInfo;
    this.state.currentTheme = theme;
    this.state.projectPath = projectPath || process.cwd();
    
    if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
      this.storyGenerator.setCustomTheme(customThemeData);
    }

    const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
    this.state.title = storyResponse.title;
    this.state.story = typeof storyResponse.story === &#39;string&#39; ? storyResponse.story : storyResponse.story.content;
    this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
    this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

    return this.formatStoryWithQuests({
      ...storyResponse,
      quests: this.state.quests
    });
  }
}
</code></pre>
<p>This class is like the director of a play, setting up scenes, managing the cast, and ensuring the story flows smoothly for every viewer.  </p>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure Guidelines\n\n`;
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    formatted += `${quest.description}\n\n`;
  }

  return formatted;
}
</code></pre>
<p>This function acts as the translator, ensuring the adventure’s blueprint is ready for dynamic interpretation.  </p>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">export class StoryGenerator {
  async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
    const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
    let adventureGuidance = &#39;&#39;;
    if (this.projectPath) {
      const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
      if (formattedConfig) {
        adventureGuidance = formattedConfig;
      }
    }

    const prompt = loadStoryGenerationPrompt({
      theme,
      repomixContent,
      ...(adventureGuidance &amp;&amp; { adventureGuidance }),
    });
    const response = await this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY });
    
    if (!response.content || response.content.trim() === &#39;&#39;) {
      throw new Error(&#39;LLM returned empty response&#39;);
    }
    
    const parsed = parseMarkdownToStoryResponse(response.content.trim());
    StoryResponseSchema.parse(parsed);
    return parsed;
  }
}
</code></pre>
<p>This method is akin to an author transforming raw research and notes into a gripping novel draft.  </p>
<h2>Helpful Hints</h2>
<ul>
<li>Use the <code class="inline-code">AdventureManager</code> class to create intelligent state-aware adventures with efficient caching.  </li>
<li>Leverage <code class="inline-code">parseAdventureConfig()</code> and <code class="inline-code">formatAdventureConfigForPrompt()</code> for structured prompts developers can build on.  </li>
<li>Explore <code class="inline-code">generateStoryAndQuests()</code> in-depth to understand AI-driven quest crafting within coded narratives.</li>
</ul>
<hr>
<p>Quest 2 complete: You&#39;ve successfully refactored raw lore into a scalable quest framework—your narrative SDK just hit its first milestone; onward to 100% deployment! 🚀💎</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3: The Analyzer Engine – Decoding ... →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>