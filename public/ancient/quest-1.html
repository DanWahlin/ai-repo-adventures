<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: MCP Tool Interface - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Code Pyramid</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: MCP Tool Interface</h1>
<hr>
<p>Beneath the sand, you open the antechamber of the code pyramid. Obsidian panels hum with the Model Context Protocol, while bronze conduits whisper to tool idols. These gates coordinate the expedition: one panel lists sacred implements, another validates offerings, a third awakens transports to carry messages through the chamber‚Äôs breath. Carved beside them, a final tablet commands orderly closure of the site. Study these inscriptions to learn how the MCP antechamber marshals tools and breathes life into your journey through the repository‚Äôs buried wisdom.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Catalog Stones: How does <code class="inline-code">setupHandlers</code> transform Zod schemas into JSON Schemas for dynamic tool listing, and what pattern is used to map tool registry entries to protocol responses?</li>
<li>‚ö° Antechamber Awakening: In <code class="inline-code">run</code>, why is <code class="inline-code">repoAnalyzer.preGenerate</code> called after establishing the <code class="inline-code">StdioServerTransport</code>, and how does this background step change the expedition‚Äôs readiness?</li>
<li>üõ°Ô∏è Guardian Seals: How do <code class="inline-code">setupHandlers</code> and <code class="inline-code">main</code> divide responsibility for parameter validation, error normalization with <code class="inline-code">McpError</code>, and safe shutdown during unexpected signals and rejections?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> MCP antechamber that lists, validates, executes tools, then opens the transport and prepares repository caches</h3>
<p>This chamber initializes a <code class="inline-code">Server</code> from the MCP SDK and equips it with handlers to both list tools and execute them securely. Within <code class="inline-code">setupHandlers</code>, the code dynamically enumerates all available tools from <code class="inline-code">tools</code>, converting each tool‚Äôs Zod <code class="inline-code">schema</code> into a JSON Schema using <code class="inline-code">zodToJsonSchema</code>. This ensures MCP clients receive precise <code class="inline-code">inputSchema</code> definitions at runtime. For execution, it validates incoming arguments via <code class="inline-code">schema.safeParse</code>, gathers all validation issues into a single <code class="inline-code">McpError</code> with <code class="inline-code">ErrorCode.InvalidParams</code>, and otherwise dispatches to the tool‚Äôs <code class="inline-code">handler</code>. Unknown tools are guarded with <code class="inline-code">ErrorCode.MethodNotFound</code>, and any unexpected exceptions are normalized into <code class="inline-code">ErrorCode.InternalError</code>, preserving a consistent protocol surface. The <code class="inline-code">run</code> method constructs a <code class="inline-code">StdioServerTransport</code> and connects, then triggers <code class="inline-code">repoAnalyzer.preGenerate(process.cwd())</code> to warm caches in the background, reducing future latency for repository analysis while not blocking the server. The <code class="inline-code">main</code> function sets signal traps for <code class="inline-code">SIGINT</code> and <code class="inline-code">SIGTERM</code> that perform <code class="inline-code">repoAnalyzer.cleanup()</code> before exit, and logs unhandled promise rejections without forcing shutdown, favoring resilience. Together, these inscriptions form a robust entryway: capability discovery, strict parameter validation, safe execution, transport binding, precomputation for performance, and graceful lifecycle control.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">setupHandlers</code> builds dynamic tool discovery and safe execution, converting Zod schemas to JSON Schema and enforcing strict parameter validation with unified MCP errors.</li>
<li><code class="inline-code">run</code> activates the stdio transport and warms repository analysis caches via <code class="inline-code">repoAnalyzer.preGenerate</code>, improving responsiveness without blocking the gate.</li>
<li><code class="inline-code">main</code> orchestrates lifecycle: constructs the server, attaches graceful shutdown on signals, logs unhandled rejections, and boots the antechamber with resilience.</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
</code></pre>
<ul>
<li>This code enumerates <code class="inline-code">tools</code> to construct protocol-compliant tool listings, translating each Zod <code class="inline-code">schema</code> via <code class="inline-code">zodToJsonSchema</code> for accurate <code class="inline-code">inputSchema</code>.</li>
<li>It validates inputs with <code class="inline-code">schema.safeParse</code>, aggregating all Zod issues into a single <code class="inline-code">McpError</code> for clear client feedback.</li>
<li>It normalizes errors using MCP <code class="inline-code">ErrorCode</code> values, ensuring consistent error semantics across unknown tools, invalid parameters, and internal failures.</li>
<li>The handlers are registered with <code class="inline-code">this.server.setRequestHandler</code>, binding MCP request schemas to logic for discovery and execution.</li>
<li>The approach centralizes validation and error handling in one chamber, reducing duplication and improving reliability.</li>
</ul>
<hr>
<pre><code class="language-typescript">  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
</code></pre>
<ul>
<li>Core function that activates the stdio transport and connects the MCP server, making the antechamber responsive.</li>
<li>Uses <code class="inline-code">repoAnalyzer.preGenerate</code> after connection to warm caches without blocking initial readiness, improving later tool performance.</li>
<li>Logs status to <code class="inline-code">stderr</code>, suitable for keeping protocol stdout channels clean.</li>
<li>Separates transport activation from background preparation, clarifying responsibilities.</li>
<li>Illustrates a performance-conscious design: non-blocking precomputation that benefits subsequent operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<ul>
<li>Entrypoint that constructs the server, attaches signal-based shutdown hooks, and begins execution with <code class="inline-code">server.run()</code>.</li>
<li>Uses <code class="inline-code">gracefulShutdown</code> to ensure <code class="inline-code">repoAnalyzer.cleanup()</code> is called, preserving the site‚Äôs order when the chamber closes.</li>
<li>Logs unhandled rejections without stopping the process, favoring uptime unless truly fatal errors occur.</li>
<li>Double guards failures with both try/catch and a trailing <code class="inline-code">.catch</code>, ensuring no silent startup errors.</li>
<li>Demonstrates operational resilience patterns common to long-running protocol servers.</li>
</ul>
<hr>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<ul>
<li>This code serves as the registry tablet for the antechamber, re-exporting tool entries with MCP-safe names (<code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, <code class="inline-code">view_progress</code>).</li>
<li>The <code class="inline-code">tools</code> object is the single source for discovery and execution in <code class="inline-code">setupHandlers</code>, enabling dynamic listing and invocation.</li>
<li>By exporting <code class="inline-code">adventureManager</code>, tool handlers share a common expedition context, avoiding duplication.</li>
<li>The modular imports (<code class="inline-code">./tools/*.js</code>) allow each tool to maintain its own schema and handler logic while remaining easy to register centrally.</li>
<li>The registry pattern decouples transport-level logic from tool definitions, keeping the chamber maintainable.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Trace the tool lifecycle: listing via <code class="inline-code">ListToolsRequestSchema</code>, validation through Zod, then execution with consistent MCP errors.</li>
<li>Compare how errors are surfaced to clients: <code class="inline-code">MethodNotFound</code>, <code class="inline-code">InvalidParams</code>, and <code class="inline-code">InternalError</code> reflect distinct fault lines.</li>
<li>Notice how cache warming in <code class="inline-code">run</code> can improve the first-use experience without delaying server readiness.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hail, seeker of wisdom‚Äîwithin the sanctum of learning, thou hast unveiled the sacred workings of the MCP Tool Interface, a triumph worthy of temple annals, and though the great odyssey counts 0/5 quests complete, let this first illumined mystery be thy shining obelisk, a portent of greater victories to come ‚≠ê‚ö°.</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>