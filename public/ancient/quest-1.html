<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: The Ritual of Themes - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-ancient">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Code of Lost Civilizations</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: The Ritual of Themes</h1>
<hr>
<p>In the depths of an undiscovered jungle, you stumble upon the crumbled remnants of an ancient civilization. Their wisdom, encoded in sacred artifacts, holds the key to a long-lost system of knowledge. From deciphering ritual glyphs to reconstructing majestic temples, you must unravel their secrets to awaken the dormant power of their advanced technologies. Each artifact represents a fragment of their mastery‚Äîtreasure them well in your quest for understanding. For this chapter, you will explore the secrets of the Ritual of Themes, discovering how this civilization orchestrated their creations and imbued them with meaning.</p>
<p><strong>Adventure Awaits</strong> ‚Äì Begin your exploration of this wondrous mystery!</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Glyph Decoding</strong>: How does <code class="inline-code">renderPage</code> in the <code class="inline-code">TemplateEngine</code> class assemble and combine disparate fragments of templates into cohesive results?</li>
<li>‚ö° <strong>Power Awakening</strong>: What is the orchestration process behind the <code class="inline-code">generateAllThemes</code> method in <code class="inline-code">HTMLAdventureGenerator</code>, and how does it enable simultaneous multi-theme creation?</li>
<li>üõ°Ô∏è <strong>Artifact Preservation</strong>: How are shared assets managed during the <code class="inline-code">copyGlobalAssets</code> operation in <code class="inline-code">AssetManager</code> to prevent redundancy and ensure seamless access across themes?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/generator/src/cli/template-engine.ts:</span> Thematic Assembly</h3>
<p>The <code class="inline-code">TemplateEngine</code> class is the cornerstone for deciphering and reassembling fragments of meaning (templates) into coherent forms (HTML pages). It combines flexibility and efficiency with its template caching mechanisms and placeholder substitution functionality.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadTemplate</code>: This method retrieves a template from cache, or fetches it directly from the file system if it isn&#39;t already cached. Ensures repeated access is efficient and reliable.</li>
<li><code class="inline-code">replacePlaceholders</code>: This function performs placeholder substitution, replacing template markers, <code class="inline-code">{{key}}</code>, with corresponding data, enabling dynamic content generation.</li>
<li><code class="inline-code">renderPage</code>: Combines a base template and a content-specific template while injecting the necessary variables to produce fully realized HTML outputs.</li>
</ul>
<h2>Code</h2>
<h3>packages/generator/src/cli/template-engine.ts</h3>
<pre><code class="language-typescript">private loadTemplate(templateName: string): string {
  if (this.templateCache.has(templateName)) {
    return this.templateCache.get(templateName)!;
  }

  const templatePath = path.join(this.templatesDir, templateName);
  
  try {
    const content = fs.readFileSync(templatePath, &#39;utf-8&#39;);
    this.templateCache.set(templateName, content);
    return content;
  } catch (error) {
    throw new Error(`Failed to load template ${templateName}: ${error}`);
  }
}
</code></pre>
<ul>
<li>Retrieves templates from the cache or loads them from disk if not cached.</li>
<li>Ensures repeated use of templates is efficient by mitigating redundant file I/O operations.</li>
<li>Introduces error-handling for scenarios where templates are unavailable or fail to load effectively.</li>
</ul>
<hr>
<pre><code class="language-typescript">private replacePlaceholders(template: string, variables: TemplateVariables): string {
  let result = template;
  
  for (const [key, value] of Object.entries(variables)) {
    const placeholder = `{{${key}}}`;
    result = result.replace(new RegExp(placeholder, &#39;g&#39;), value || &#39;&#39;);
  }
  
  return result;
}
</code></pre>
<ul>
<li>Scans and replaces placeholders (e.g., <code class="inline-code">{{key}}</code>) in a template with the provided variable data.</li>
<li>Empowers dynamic content generation across the codebase by modularizing data injection.</li>
<li>Demonstrates clear looping patterns for traversing input objects and applying changes consistently.</li>
</ul>
<hr>
<pre><code class="language-typescript">renderPage(contentTemplate: string, variables: TemplateVariables): string {
  const baseTemplate = this.loadTemplate(&#39;base-template.html&#39;);
  const contentHtml = this.loadTemplate(contentTemplate);
  
  // First render the content template
  const renderedContent = this.replacePlaceholders(contentHtml, variables);
  
  // Then render the base template with the content
  const pageVariables = {
    ...variables,
    CONTENT: renderedContent
  };
  
  return this.replacePlaceholders(baseTemplate, pageVariables);
}
</code></pre>
<ul>
<li>Coordinates the assembly of a full HTML page by combining a base layout with content-specific fragments.</li>
<li>Highlights design modularity with its two-pass substitution system: first for content, then for the base template.</li>
<li>Utilized in broader systems where theme structures and content data must harmonize seamlessly.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/generator/src/cli/html-generator.ts:</span> Technological Orchestration</h3>
<p>This file encapsulates the <code class="inline-code">HTMLAdventureGenerator</code>, a master orchestrator for creating themed HTML adventures. Of note is its capability to manage simultaneous multi-theme generation, reflecting the civilization‚Äôs mastery of parallel creations.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateAdventure</code>: Manages the end-to-end process of generating HTML for a selected theme, from analysis to file generation.</li>
<li><code class="inline-code">generateAllThemes</code>: Oversees the concurrent generation of multiple themes across separate directories, demonstrating the civilization&#39;s knowledge of parallelism.</li>
<li><code class="inline-code">startHttpServer</code>: Initiates a lightweight HTTP server to serve generated content, exemplifying modular deployment strategies.</li>
</ul>
<h2>Code</h2>
<h3>packages/generator/src/cli/html-generator.ts</h3>
<pre><code class="language-typescript">async generateAdventure(): Promise&lt;void&gt; {
  console.log(chalk.yellow.bold(&#39;üöÄ Generating Adventure...&#39;));
  
  const repomixContent = await repoAnalyzer.generateRepomixContext(this.projectPath);
  const projectInfo = createProjectInfo(repomixContent);

  console.log(chalk.dim(&#39;‚ú® Generating themed story and quests...&#39;));
  const storyContent = await this.adventureManager.initializeAdventure(
    projectInfo, 
    this.selectedTheme, 
    this.projectPath,
    this.customThemeData
  );

  this.extractQuestInfo();

  const questsToGenerate = this.maxQuests !== undefined ? Math.min(this.maxQuests, this.quests.length) : this.quests.length;

  console.log(chalk.dim(&#39;üìñ Generating quest pages...&#39;));
  await this.generateQuestPages(questsToGenerate);

  console.log(chalk.green.bold(&#39;üéâ Adventure website generated successfully!&#39;));
}
</code></pre>
<ul>
<li>Coordinates all key steps required to produce a themed HTML adventure.</li>
<li>Demonstrates how modularity supports the integration of storytelling, content generation, and HTML synthesis.</li>
<li>Contains logic to prune quests if a maximum limit is imposed.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateAllThemes(): Promise&lt;void&gt; {
  console.log(chalk.green(&#39;‚úÖ Generating all themes&#39;));
  
  const themes: AdventureTheme[] = [&#39;space&#39;, &#39;mythical&#39;, &#39;ancient&#39;, &#39;developer&#39;];
  
  const themePromises = themes.map(async (theme) =&gt; {
    const themeDir = path.join(this.outputDir, theme);
    fs.mkdirSync(themeDir, { recursive: true });
    
    const themeGenerator = new HTMLAdventureGenerator();
    themeGenerator[&#39;selectedTheme&#39;] = theme;
    themeGenerator[&#39;outputDir&#39;] = themeDir;
    
    await themeGenerator.generateAdventure();
    return { theme, success: true };
  });

  const results = await Promise.allSettled(themePromises);
  console.log(chalk.green.bold(&#39;üéâ All themes generated successfully!&#39;));
}
</code></pre>
<ul>
<li>Drives the parallel generation of multiple themes, leveraging async mapping.</li>
<li>Simplifies complexity by dividing generation into independent encapsulated processes.</li>
<li>Illustrates operational resilience by ensuring each theme completes or fails independently of others.</li>
</ul>
<hr>
<pre><code class="language-typescript">async startHttpServer(port: number = 8080): Promise&lt;void&gt; {
  const server = http.createServer((req, res) =&gt; {
    let filePath = path.join(this.outputDir, req.url === &#39;/&#39; ? &#39;index.html&#39; : req.url || &#39;&#39;);
    
    fs.readFile(filePath, (err, content) =&gt; {
      if (err) {
        res.writeHead(404);
        res.end(&#39;File not found&#39;);
      } else {
        res.writeHead(200, { &#39;Content-Type&#39;: &#39;text/html&#39; });
        res.end(content, &#39;utf-8&#39;);
      }
    });
  });

  server.listen(port, () =&gt; {
    console.log(chalk.green(`üåê HTTP server started on http://localhost:${port}`));
  });
}
</code></pre>
<ul>
<li>Provides lightweight deployment capabilities by serving the generated HTML content over HTTP.</li>
<li>Demonstrates the importance of portability and accessibility in disseminating results.</li>
<li>Integrates graceful error-handling for unknown paths or server issues.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/generator/src/cli/asset-manager.ts:</span> Knowledge Preservation</h3>
<p>The <code class="inline-code">AssetManager</code> is responsible for managing and copying shared assets. It ensures that all necessary resources are available for multiple themes without redundancy or duplication.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">copyGlobalAssets</code>: Handles shared assets across directories, guaranteeing efficient resource sharing.</li>
<li><code class="inline-code">copyQuestNavigator</code>: Copies navigation assets to ensure users can explore adventures smoothly.</li>
<li><code class="inline-code">copyImages</code>: Copies theme-specific and shared image assets, safeguarding visual consistency across all outputs.</li>
</ul>
<h2>Code</h2>
<h3>packages/generator/src/cli/asset-manager.ts</h3>
<pre><code class="language-typescript">copyGlobalAssets(outputDir: string): void {
  const globalSharedDir = path.join(outputDir, &#39;assets&#39;, &#39;shared&#39;);
  const globalImages = [&#39;github-mark.svg&#39;, &#39;github-mark-white.svg&#39;];

  fs.mkdirSync(globalSharedDir, { recursive: true });

  globalImages.forEach(file =&gt; {
    const sourcePath = path.join(this.sourceDir, &#39;assets&#39;, &#39;shared&#39;, file);
    const targetPath = path.join(globalSharedDir, file);
    fs.copyFileSync(sourcePath, targetPath);
  });
}
</code></pre>
<ul>
<li>Consolidates shared assets into a common directory for efficiency in multi-theme setups.</li>
<li>Encourages streamlined asset reuse, conserving storage and improving maintainability.</li>
<li>Demonstrates careful directory management through recursive creation and fail-safe operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">copyQuestNavigator(outputDir: string): void {
  const templatesDir = path.join(this.sourceDir, &#39;templates&#39;);
  const assetsDir = path.join(this.sourceDir, &#39;assets&#39;);

  const cssSource = path.join(templatesDir, &#39;quest-navigator.css&#39;);
  const jsSource = path.join(templatesDir, &#39;quest-navigator.js&#39;);

  const assetsDirTarget = path.join(outputDir, &#39;assets&#39;);
  fs.mkdirSync(assetsDirTarget, { recursive: true });

  fs.copyFileSync(cssSource, path.join(assetsDirTarget, &#39;quest-navigator.css&#39;));
  fs.copyFileSync(jsSource, path.join(assetsDirTarget, &#39;quest-navigator.js&#39;));
}
</code></pre>
<ul>
<li>Guides the smooth exploration of quest narratives by ensuring navigational resources are present.</li>
<li>Facilitates the user journey through the file structures.</li>
</ul>
<hr>
<pre><code class="language-typescript">copyImages(outputDir: string, isMultiTheme: boolean): void {
  const targetImagesDir = path.join(outputDir, &#39;assets&#39;, &#39;images&#39;);
  fs.mkdirSync(targetImagesDir, { recursive: true });

  const sourceImagesDir = path.join(this.sourceDir, &#39;assets&#39;, &#39;images&#39;);
  const imageFiles = fs.readdirSync(sourceImagesDir);

  imageFiles.forEach(file =&gt; {
    const sourcePath = path.join(sourceImagesDir, file);
    const targetPath = path.join(targetImagesDir, file);
    fs.copyFileSync(sourcePath, targetPath);
  });
}
</code></pre>
<ul>
<li>Transfers visual resources to ensure theme fidelity and consistency across generated output.</li>
<li>Handles both multi- and single-theme setups, highlighting operational flexibility.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Investigate how template caching improves performance in <code class="inline-code">TemplateEngine</code>.</li>
<li>Explore the <code class="inline-code">generateAdventure</code> method for inspiration on modular task orchestration.</li>
<li>Notice the error-handling patterns within file operations for resilient designs.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hail, seeker of wisdom, for thou hast completed the sacred Rite of Themes, etching thy first triumph upon the eternal tablets of destiny‚Äîpress onward, for the cosmos awaits thy mastery! ‚≠ê‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>