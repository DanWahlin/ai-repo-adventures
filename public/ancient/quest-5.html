<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Foundation & Utilities - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Code Pyramid</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Foundation &amp; Utilities</h1>
<hr>
<p>Beneath the pyramid‚Äôs heart, you uncover a chamber of quiet instruments: measuring rods, counting beads, and scrolls of careful notation. Here the expedition‚Äôs foundation is kept true. Config stones whisper of quests and files, and a scribe‚Äôs toolkit compresses sprawling records into concise tablets fit for swift counsel. In this sanctum, you will read the ancient markings that govern what is loaded, which paths are worthy, and how sprawling edicts are rendered into brief inscriptions for your LLM scribe. Master these utilities to steady the entire expedition.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Pathway Cartography: How does <code class="inline-code">extractUniqueFilePaths</code> traverse nested structures and ensure only existing file paths are preserved?</li>
<li>‚ö° Tablet Unsealing: In what sequence do <code class="inline-code">loadAdventureConfig</code> and <code class="inline-code">parseAdventureConfig</code> cooperate to safely read and parse the config without halting the expedition?</li>
<li>üõ°Ô∏è Inscription Minimalism: How does <code class="inline-code">formatAdventureConfigForPrompt</code> reduce noise while preserving essential quest titles, file lists, and function names?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> The bedrock utilities for reading, validating, and distilling the expedition‚Äôs configuration tablet</h3>
<p>This single scroll equips the expedition with a cautious, fault-tolerant ritual for reading the <code class="inline-code">adventure.config.json</code> stone, parsing it into workable clay, extracting valid file paths cited within, and compressing quest outlines for fast LLM guidance. The internal <code class="inline-code">readFileIfExists</code> performs a gentle read, treating missing stones as non-fatal so the expedition continues. The <code class="inline-code">loadAdventureConfig</code> then resolves the correct path to the config stone and delegates to that gentle read. Next, <code class="inline-code">parseAdventureConfig</code> becomes the lone parsing sanctum, returning <code class="inline-code">null</code> on any parsing mishaps to avoid cascading failures. The path extraction rite, <code class="inline-code">extractUniqueFilePaths</code>, explores the entire object graph like a careful surveyor, checking <code class="inline-code">path</code> fields, verifying existence on disk, and accumulating only unique, valid entries. Finally, <code class="inline-code">formatAdventureConfigForPrompt</code> transforms the heavy inscription into light guidance: quest titles, file lists, and function names, nothing more. This approach balances resilience with clarity, ensuring that upper chambers‚Äîgeneration engines and analyzers‚Äîreceive trustworthy, compact guidance. These utilities matter because they form the expedition‚Äôs ground truth: they prevent brittle assumptions, simplify prompts, and maintain a clean separation between raw reading, parsing, extraction, and formatting.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> parses the tablet once and returns <code class="inline-code">null</code> safely on error, centralizing JSON interpretation and preventing brittle duplication across the pyramid‚Äôs chambers.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> conducts a full object-graph traversal, verifies each <code class="inline-code">path</code> against the file system, and returns unique, existing paths to keep the expedition anchored in real artifacts.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> distills quests into minimal outlines‚Äîtitles, files, function names‚Äîpreserving signal while trimming verbose inscriptions for efficient LLM prompting.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Centralizes JSON parsing, making it the single truthful entry for interpreting the config tablet</li>
<li>Uses safe <code class="inline-code">try/catch</code> and returns <code class="inline-code">null</code> on failure, preventing cascade errors in higher layers</li>
<li>Relies on <code class="inline-code">loadAdventureConfig</code> for file access separation, keeping parsing pure</li>
<li>Establishes a contract: callers must handle <code class="inline-code">null</code>, encouraging robust flows</li>
<li>Minimizes side effects, improving testability and making error paths explicit</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Traverses the entire config structure, treating arrays and object values uniformly via a stack</li>
<li>Validates each <code class="inline-code">path</code> by resolving and checking existence to avoid phantom references</li>
<li>Uses a <code class="inline-code">Set</code> to ensure uniqueness, preventing duplicate path entries in the expedition ledger</li>
<li>Keeps traversal iterative (stack) to avoid recursion depth concerns and improve clarity</li>
<li>Decouples from any schema specifics, making it resilient to nested variations</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Produces a concise prompt-ready inscription with predictable headings and lists</li>
<li>Filters to only essential details: quest titles, file paths, and function names for clarity</li>
<li>Handles missing or malformed structures gracefully, returning an empty string on issues</li>
<li>Mirrors the expedition‚Äôs need to reduce noise for LLM guidance and faster iteration</li>
<li>Avoids schema over-assumptions by performing presence checks and array validations</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>If results seem empty, inspect the <code class="inline-code">adventure.config.json</code> tablet and confirm well-formed JSON and a valid <code class="inline-code">adventure.quests</code> array.</li>
<li>Trace failures by checking each stage: <code class="inline-code">loadAdventureConfig</code> read, <code class="inline-code">parseAdventureConfig</code> parse, then the extract or format step.</li>
<li>Before invoking higher chambers, run <code class="inline-code">extractUniqueFilePaths</code> locally to verify that paths referenced by quests actually exist on disk.</li>
</ul>
<hr>
<p>You have mastered all the secrets of the expedition‚Äôs code pyramid! Your adventure is complete.</p>
<p>Hark, seeker of wisdom‚Äîwithin the hallowed halls of learning thou hast completed Quest 5: Foundation &amp; Utilities, laying sacred bedrock beneath thy craft and ascending to 4 of 5 quests (80%) with triumphant vigor, as the temple‚Äôs torches blaze and the scrolls attest thy mastery‚Äîpress on to the final rite, for victory‚Äôs laurel nears!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>