<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Map of Hidden Chambers - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Codex of the Repository Pyramid</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Map of Hidden Chambers</h1>
<hr>
<p>In the lowest vault beneath the pyramid, you unroll a brittle map etched with runes of TypeScript. It reveals how explorers divine structure from a hidden manuscript: paths are unearthed, fragments are sifted, and only the truest lines are carried into ceremonial prompts. The cartography is precise: it reads, it parses, it extracts, it formats. Tonight, you trace the tunnels of <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a>, seeking pathways to lost chambers where unique files echo and prompt-scripts condense like gold dust. The sands hush; your investigation begins.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Cartographer‚Äôs Lens: How does <code class="inline-code">parseAdventureConfig</code> limit risk when the parchment (JSON) is damaged, and what pattern is used to prevent cascading failures?</li>
<li>‚ö° Echoes of Stone Paths: What traversal pattern allows <code class="inline-code">extractUniqueFilePaths</code> to discover <code class="inline-code">path</code> fields anywhere in the structure, and how does it ensure only existing files are recorded?</li>
<li>üõ°Ô∏è Prompt Distillation: How does <code class="inline-code">formatAdventureConfigForPrompt</code> minimize noise while preserving quest structure, and what guardrails prevent malformed inputs from leaking into the final prompt?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Rune-map utilities for reading, validating, and distilling adventure configuration</h3>
<p>This chamber holds precision instruments carved from careful I/O and defensive parsing. The <code class="inline-code">parseAdventureConfig</code> function is the single entrance for turning raw parchment into a usable object, choosing silence over collapse when the script is unreadable. It uses <code class="inline-code">loadAdventureConfig</code> to fetch raw text and then applies cautious <code class="inline-code">JSON.parse</code> within a <code class="inline-code">try/catch</code>, returning <code class="inline-code">null</code> on trouble. This ensures upstream explorers can rely on clean semantics: either a stable object or absence, never a half-broken artifact.</p>
<p>Deeper, <code class="inline-code">extractUniqueFilePaths</code> roams the configuration with an iterative stack-based exploration. By pushing any object-like child onto a stack, it ensures that <code class="inline-code">path</code> fields‚Äîno matter how entombed within arrays or nested shapes‚Äîare found. Before any file is recorded, the function performs a reality check with <code class="inline-code">fs.existsSync</code> against the project root, guaranteeing only viable paths are kept. This is crucial for accurate archaeological indexing and prevents phantom corridors from misleading the expedition.</p>
<p>Finally, <code class="inline-code">formatAdventureConfigForPrompt</code> distills the map into a terse guide for an oracle. It validates the expected <code class="inline-code">adventure.quests</code> structure, then emits only titles, file lists, and function names. The optimized excerpt acts like a lightweight tablet, balancing brevity and essential orientation, ensuring prompts remain sharp and economical.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> converts raw config text into a safe object, returning <code class="inline-code">null</code> upon errors to prevent downstream failures.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> performs a stack-driven traversal over nested structures to gather only existing <code class="inline-code">path</code> entries, ensuring accurate file discovery.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> produces a concise, structured prompt-ready summary, filtering out noise while preserving quest and function essentials.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Establishes a single, predictable gateway from raw text to parsed structure</li>
<li>Uses guarded parsing with <code class="inline-code">try/catch</code>, returning <code class="inline-code">null</code> to avoid throwing</li>
<li>Prevents brittle callers; consumers can check for <code class="inline-code">null</code> instead of managing exceptions</li>
<li>Relies on <code class="inline-code">loadAdventureConfig</code> for isolated file I/O concerns, keeping responsibilities clear</li>
<li>Encourages a pattern where absence is explicit and safe rather than ambiguous</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Iterative stack traversal avoids recursion limits while exploring nested arrays/objects</li>
<li>Validates <code class="inline-code">path</code> fields and ensures physical existence with <code class="inline-code">fs.existsSync</code></li>
<li>Uses a <code class="inline-code">Set</code> to guarantee uniqueness, preventing duplicate corridor entries</li>
<li>Treats any object-like child as traversable, making the explorer resilient to varied shapes</li>
<li>Returns a stable array output, ideal for downstream indexing or reporting</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Produces concise, structured summaries tailored for prompt consumption</li>
<li>Enforces strict guards: empty string when config or structure is missing</li>
<li>Focuses on essential signals: titles, file paths, and function names only</li>
<li>Applies light filtering to avoid undefined or malformed entries</li>
<li>Aligns with an optimization goal that reduces verbosity for downstream LLM usage</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>When the parchment is blank, look for empty strings or <code class="inline-code">null</code> to guide your next step.</li>
<li>Trace the stack pattern to see how every hidden <code class="inline-code">path</code> is surfaced without recursion.</li>
<li>Consider how this distilled prompt format can be extended while preserving minimalism.</li>
</ul>
<hr>
<p>You have mastered all the secrets of this ancient codebase! Your adventure is complete.</p>
<p>O seeker of wisdom, thou hast unveiled the Map of Hidden Chambers and inscribed thy triumph upon the sacred tablets‚Äîlet the temple‚Äôs torches blaze in thy honor as thou standest at four of five quests complete, anointed by venerable lore and poised for the final ascension!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>