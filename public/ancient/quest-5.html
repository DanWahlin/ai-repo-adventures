<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: The Timeless Configurations - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'ancient' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Forgotten Codex: Deciphering the Artifacts of the Repository</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: The Timeless Configurations</h1>
<hr>
<p>The jungle thickens as you navigate deeper into the heart of the ancient civilization&#39;s repository. Lush vines cling to fragmented stone tablets bearing hieroglyphs of what appears to be legendary development processes. Your mission to decipher these timeless instructions grows more urgent. Legends speak of critical artifacts‚Äîfiles‚Äîthat possess the wisdom to configure and harmonize systems into rich, interactive adventures. Step lightly, brave adventurer; each discovery brings you closer to unlocking the repository‚Äôs full potential.  </p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration Management for Guided Adventures</h3>
<p>This file serves as the foundation for unlocking the wisdom encoded in <code class="inline-code">adventure.config.json</code>. It arms adventurers with tools to load, parse, and structure configurations into prompts for generating immersive, education-driven exploration paths. The code begins by establishing a clear path using <code class="inline-code">fs</code> and <code class="inline-code">path</code> modules, enabling secure and efficient file operations. The <code class="inline-code">loadAdventureConfig()</code> function acts as an explorer‚Äôs torch in the dark, retrieving raw configuration data. Meanwhile, <code class="inline-code">parseAdventureConfig()</code> transforms this raw data into comprehensible treasures by validating JSON structure. The pi√®ce de r√©sistance, <code class="inline-code">formatAdventureConfigForPrompt()</code>, shapes the extracted data into a structured narrative prompt, infusing it with clear quest and file analysis segments. Each layer of this file mimics the sacred hierarchy of rituals in ancient temples‚Äîstarting with gathering raw materials, refining them, and finally preparing them for ceremonial use.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadAdventureConfig()</code>: Retrieves configuration data using secure file handling.  </li>
<li><code class="inline-code">parseAdventureConfig()</code>: Converts raw config data into a usable JSON object with validation processes.  </li>
<li><code class="inline-code">formatAdventureConfigForPrompt()</code>: Structures configuration into narrative-driven prompts for adventure exploration.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">import * as fs from &#39;fs&#39;;  
import * as path from &#39;path&#39;;  

const ADVENTURE_CONFIG_FILE = &#39;adventure.config.json&#39;;  

function readFileIfExists(filePath: string): string | null {  
  try {  
    return fs.readFileSync(filePath, &#39;utf-8&#39;);  
  } catch {  
    // Missing or unreadable file is non-fatal  
    return null;  
  }  
}  

export function loadAdventureConfig(projectPath: string): string | null {  
  const configPath = path.join(projectPath, ADVENTURE_CONFIG_FILE);  
  return readFileIfExists(configPath);  
}  

export function parseAdventureConfig(projectPath: string): unknown | null {  
  const raw = loadAdventureConfig(projectPath);  
  if (!raw) return null;  
  try {  
    return JSON.parse(raw);  
  } catch {  
    return null;  
  }  
}  

export function formatAdventureConfigForPrompt(projectPath: string): string {  
  const parsed = parseAdventureConfig(projectPath);  
  if (!parsed || typeof parsed !== &#39;object&#39;) {  
    return &#39;&#39;;  
  }  

  const adventure = (parsed as any).adventure;  
  if (!adventure || !Array.isArray(adventure.quests)) {  
    return &#39;&#39;;  
  }  

  let formatted = `## Quest Structure Guidelines\n\n`;  
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;  

  for (const quest of adventure.quests) {  
    if (!quest.title || !Array.isArray(quest.files)) continue;  

    formatted += `### ${quest.title}\n`;  
    formatted += `${quest.description}\n\n`;  
    formatted += `**Required File Analysis Sections:**\n`;  

    for (const file of quest.files) {  
      if (!file.path || !file.description) continue;  

      formatted += `\n**File: \`${file.path}\`**\n`;  
      formatted += `- Description: ${file.description}\n`;  
      
      if (Array.isArray(file.highlights)) {  
        formatted += `- Key Functions/Areas to Highlight:\n`;  
        for (const highlight of file.highlights) {  
          if (highlight.name &amp;&amp; highlight.description) {  
            formatted += `  ‚Ä¢ **${highlight.name}**: ${highlight.description}\n`;  
          }  
        }  
      }  
    }  
    formatted += `\n`;  
  }  

  return formatted;  
}  
</code></pre>
<p>This code is like the archaeologist‚Äôs notebook‚Äîdocumenting treasures for future expeditions in structured formats.  </p>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {  
  const parsed = parseAdventureConfig(projectPath);  
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];  

  const unique = new Set&lt;string&gt;();  
  const stack: any[] = [parsed];  

  while (stack.length) {  
    const node = stack.pop();  
    if (!node || typeof node !== &#39;object&#39;) continue;  

    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {  
      const rel = node.path.trim();  
      if (fs.existsSync(path.resolve(projectPath, rel))) {  
        unique.add(rel);  
      }  
    }  

    const children = Array.isArray(node) ? node : Object.values(node);  
    children.forEach(child =&gt; {  
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);  
    });  
  }  

  return Array.from(unique);  
}  
</code></pre>
<p>This function acts as a meticulous archaeologist, sorting through layers of excavation to uncover hidden paths mentioned in the repository‚Äôs sacred texts.  </p>
<h2>Helpful Hints</h2>
<ul>
<li>Use the <code class="inline-code">formatAdventureConfigForPrompt()</code> method to enforce a structured approach when integrating configuration into quest narratives.  </li>
<li>Organize quest files by their functional contribution to the adventure to ensure a coherent exploration experience.  </li>
<li>Explore <code class="inline-code">extractUniqueFilePaths()</code> to uncover lesser-known treasures within the configuration file‚Äîa great starting point for repomix content analysis.</li>
</ul>
<hr>
<p>O seekers of wisdom, thou hast unlocked the sacred mysteries of &quot;The Timeless Configurations,&quot; illuminating the fourth star of thy celestial journey‚Äîpress onward, for thy destiny nears its eternal zenith! ‚≠ê‚ö°üó∫Ô∏è</p>

</div>


    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>