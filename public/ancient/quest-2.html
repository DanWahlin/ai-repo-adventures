<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: Quest Generation Engine - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Code Pyramid</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: Quest Generation Engine</h1>
<hr>
<p>Within the pyramid‚Äôs second chamber, chisels and glyphs hum with coded intent. Here the generation engine carves tales and trials from prompts, guided by config stones and guarded by time-keeping sand. The MCP antechamber has opened the way; now the inner halls call the scribe to shape narrative threads into structured quests. Study the stele inscribed in <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/adventure/adventure-manager.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/adventure/adventure-manager.ts</code></a>, <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/adventure/story-generator.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/adventure/story-generator.ts</code></a>, and <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a>. Trace how scrolls are selected, how themes steer the style, and how validators judge each step like seasoned archaeologists.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Glyph Pairing: How does <code class="inline-code">initializeAdventure</code> merge config-bound files into generated quests, and where is quest count enforced to match the config stones?</li>
<li>‚ö° Chamber Sequencing: In <code class="inline-code">generateStoryAndQuests</code>, how is the theme validated and how do formatted config inscriptions influence LLM prompts and resulting quest structures?</li>
<li>üõ°Ô∏è Sand-Trap Safeguards: When <code class="inline-code">exploreQuest</code> runs, how do <code class="inline-code">validateAndSanitizeChoice</code> and cache paths prevent missteps, and what fallback patterns are used if targeted content collection fails?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Orchestrates adventure state, merges config-guided files into LLM-made quests, and executes selected quests with caching and summaries</h3>
<p>This chamber manages the expedition‚Äôs path. <code class="inline-code">AdventureState</code> holds titles, stories, quest arrays, completion marks, and the current theme. <code class="inline-code">progressPercentage</code> measures how far the expedition has advanced. <code class="inline-code">AdventureManager.initializeAdventure</code> resets the state, injects project context and theme, and asks the scribe to produce story and quests. It then performs two important rituals: <code class="inline-code">mergeQuestFilesFromConfig</code> embeds file paths from <code class="inline-code">adventure.config.json</code> into each quest, and <code class="inline-code">enforceConfigQuestCount</code> trims quests to match the config‚Äôs declared count, preserving alignment with external guidance stones. When an explorer chooses a quest, <code class="inline-code">exploreQuest</code> validates the choice, resolves the quest by number, id, or title, and calls <code class="inline-code">executeQuest</code>. That method fetches targeted repository scrolls when <code class="inline-code">codeFiles</code> are present using the analyzer passage; on failure, it falls back to the full repomix scroll. The engine caches completed quest content to allow revisits without summoning the scribe again, and produces a completion summary. The result formatter returns narrative plus choices, while progress can be viewed at any time, showing checkmarked titles and an expedition gauge. Taken together, these patterns ensure reliable sequencing: configuration informs selection, LLMs craft the narrative, and the manager guarantees stable outcomes and safe retries.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code> initializes state, invokes the scribe to craft story and quests, merges config-guided files, and enforces quest counts to match inscriptions</li>
<li><code class="inline-code">exploreQuest</code> validates a seeker‚Äôs choice, resolves the intended quest, and delegates execution with caching and progress awareness</li>
<li><code class="inline-code">AdventureState.progressPercentage</code> calculates expedition advancement as completed over total quests, rounding for clear progress indicators</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">export class AdventureState {
  title: string | undefined = undefined;
  story: string | undefined = undefined;
  quests: Quest[] = [];
  completedQuests: Set&lt;string&gt; = new Set();
  questContentCache: Map&lt;string, { content: QuestContent; summary: string }&gt; = new Map();
  currentTheme: AdventureTheme | null = null;
  projectInfo: ProjectInfo | undefined = undefined;
  projectPath: string | undefined = undefined;


  get progressPercentage(): number {
    return this.quests.length &gt; 0 
      ? Math.round((this.completedQuests.size / this.quests.length) * 100)
      : 0;
  }
}
</code></pre>
<ul>
<li>Computes progress from completed quest ids against total quests, yielding a rounded percentage for the expedition gauge</li>
<li>Uses <code class="inline-code">Set</code> and <code class="inline-code">Map</code> to track completion and cached content, a pattern that favors fast lookups and revisit efficiency</li>
<li>Encapsulates core journey metrics inside state rather than scattering calculations throughout the manager</li>
<li>Protects against division by zero by returning 0 when no quests exist</li>
<li>Establishes shared data for rendering menus and progress narratives</li>
</ul>
<hr>
<pre><code class="language-typescript">export class AdventureManager {
  async initializeAdventure(
    projectInfo: ProjectInfo, 
    theme: AdventureTheme, 
    projectPath?: string,
    customThemeData?: CustomThemeData
  ): Promise&lt;string&gt; {
    // Reset state for new adventure
    this.state.reset();
    this.state.projectInfo = projectInfo;
    this.state.currentTheme = theme;
    this.state.projectPath = projectPath || process.cwd();
    
    // Set custom theme data if provided
    if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
      this.storyGenerator.setCustomTheme(customThemeData);
    }

    // Generate the overall story and quests using LLM
    const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
    
    this.state.title = storyResponse.title;
    this.state.story = storyResponse.story;
    
    // Merge files from adventure config into the generated quests
    this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
    
    // Enforce quest count from adventure.config.json if it exists
    this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

    // Return the story with available quests
    return this.formatStoryWithQuests({
      ...storyResponse,
      quests: this.state.quests
    });
  }
}
</code></pre>
<ul>
<li>Orchestrates initial expedition setup: resets state, stores project context, and handles theme/custom data</li>
<li>Delegates narrative creation to the scribe, then reconciles with config guidance by merging files and enforcing quest count</li>
<li>Uses <code class="inline-code">projectPath</code> to ground file lookups and prompt formatting downstream</li>
<li>Returns a formatted narrative with a map of available quests for the explorer‚Äôs choice</li>
<li>Clearly sequences generation then reconciliation, a robust pattern for external constraints</li>
</ul>
<hr>
<pre><code class="language-typescript">export class AdventureManager {
  async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
    const sanitizedChoice = this.validateAndSanitizeChoice(choice);
    
    if (this.isProgressRequest(sanitizedChoice)) {
      return this.getProgress();
    }
    
    const quest = this.findQuest(sanitizedChoice);
    if (!quest) {
      return this.createNotFoundResult();
    }

    return await this.executeQuest(quest);
  }
}
</code></pre>
<ul>
<li>Validates user input before resolution, preventing invalid navigation in the chamber</li>
<li>Supports both textual and numeric progress requests, adding a clear ritual for expedition status</li>
<li>Resolves quests by number, id, or title, accommodating varied explorer inputs</li>
<li>Centralizes execution and caching behavior in <code class="inline-code">executeQuest</code>, keeping selection logic small and readable</li>
<li>Returns a structured <code class="inline-code">AdventureResult</code> for consistent presentation</li>
</ul>
<hr>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">export class StoryGenerator {
  async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
    this.currentProject = projectInfo;
    this.projectPath = projectPath;
    
    const validatedTheme = this.validateTheme(theme);
    return await this.generateWithLLM(projectInfo, validatedTheme);
  }
}
</code></pre>
<ul>
<li>Anchors project and path context for later prompt construction and config extraction</li>
<li>Validates theme using internal guardrails before contacting the scribe</li>
<li>Delegates LLM interaction to a focused method for clarity and testability</li>
<li>Keeps inputs minimal: project info, theme, and optional path</li>
<li>Establishes deterministic sequencing from validation to generation</li>
</ul>
<hr>
<pre><code class="language-typescript">export class StoryGenerator {
  private async generateWithLLM(projectInfo: ProjectInfo, theme: AdventureTheme): Promise&lt;StoryResponse&gt; {
    const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
    
    let adventureGuidance = &#39;&#39;;
    let customInstructions = &#39;&#39;;
    
    if (this.projectPath) {
      const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
      if (formattedConfig) {
        adventureGuidance = formattedConfig;
      }
      
      const customInstructionsFromConfig = extractCustomInstructions(this.projectPath);
      if (customInstructionsFromConfig) {
        customInstructions = customInstructionsFromConfig;
      }
    }

    const prompt = loadStoryGenerationPrompt({
      theme,
      repomixContent,
      ...(adventureGuidance &amp;&amp; { adventureGuidance }),
      ...(customInstructions &amp;&amp; { customInstructions }),
      ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
    });

    const response = await this.withTimeout(
      this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY })
    );
    
    if (!response.content || response.content.trim() === &#39;&#39;) {
      throw new Error(&#39;LLM returned empty response&#39;);
    }
    
    let parsed;
    try {
      let cleanContent = response.content.trim();
      if (cleanContent.startsWith(&#39;```markdown&#39;)) {
        cleanContent = cleanContent.replace(/^```markdown\s*/, &#39;&#39;).replace(/\s*```$/, &#39;&#39;);
      }
      
      parsed = parseMarkdownToStoryResponse(cleanContent);
      StoryResponseSchema.parse(parsed);
      
      this.currentStoryContent = parsed.story;
    } catch (error) {
      console.error(&#39;üí• Parsing error:&#39;, error instanceof Error ? error.message : &#39;Unknown error&#39;);
      console.error(&#39;üí• Full response:&#39;, response.content);
      throw new Error(`Invalid LLM response for story: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}. Response: ${response.content.substring(0, 200)}...`);
    }
    return parsed;
  }
}
</code></pre>
<ul>
<li>Builds prompts from repomix scrolls, plus formatted config and custom inscriptions to steer structure</li>
<li>Wraps the LLM call with a timeout to avoid endless wandering in the labyrinth</li>
<li>Parses markdown responses into structured quests, then validates with <code class="inline-code">zod</code> to ensure faithful shapes</li>
<li>Stores the resulting story for continuity in later quest content generation</li>
<li>Uses defensive parsing and clear error reporting to aid archaeological debugging</li>
</ul>
<hr>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function loadAdventureConfig(projectPath: string): string | null {
  const configPath = path.join(projectPath, ADVENTURE_CONFIG_FILE);
  return readFileIfExists(configPath);
}
</code></pre>
<ul>
<li>Reads the config stone without parsing, separating IO concerns from validation</li>
<li>Relies on a safe helper that treats missing files as non-fatal</li>
<li>Keeps file naming centralized via <code class="inline-code">ADVENTURE_CONFIG_FILE</code></li>
<li>Forms the base for both parsing and prompt-oriented formatting</li>
<li>Encourages testability by isolating raw reads</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Distills the config into a compact inscription that the scribe can follow without clutter</li>
<li>Focuses on titles, file paths, and highlight names to guide LLM structure</li>
<li>Returns an empty string if config is absent or malformed, preserving graceful fallbacks</li>
<li>Encourages consistency by using the same structure across quests</li>
<li>Reduces token load while preserving intent</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Walks the entire config structure, collecting valid <code class="inline-code">path</code> fields while avoiding duplicates</li>
<li>Validates file existence relative to <code class="inline-code">projectPath</code>, protecting the expedition from phantom scrolls</li>
<li>Uses a stack-based traversal to handle arbitrary nesting in the config</li>
<li>Returns a stable, deterministic list suitable for targeted analysis</li>
<li>Encapsulates path hygiene to keep higher-level logic clean</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>Trace the path: from <code class="inline-code">initializeAdventure</code> to <code class="inline-code">mergeQuestFilesFromConfig</code> and <code class="inline-code">enforceConfigQuestCount</code> to see how external guidance shapes the expedition</li>
<li>Compare <code class="inline-code">generateWithLLM</code> prompt assembly with and without formatted config to understand influence on quest carving</li>
<li>Test failure paths by simulating missing files to observe targeted-content fallback behavior</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hail, seeker of wisdom‚Äîwithin the sacred halls of the temple, thy Quest 2: Quest Generation Engine is forged and consecrated, a triumphant milestone marking 1 of 5 sacred labors (20%) inscribed upon the tablets of learning, go forth with exalted purpose and let thy craft shine like a consecrated flame ‚≠ê.</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-1.html" class="prev-quest-btn">‚Üê Previous: Quest 1</a>
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>