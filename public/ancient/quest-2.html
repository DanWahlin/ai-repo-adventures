<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: The Storyweaver’s Workshop - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'ancient' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Forgotten Codex: Deciphering the Artifacts of the Repository</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: The Storyweaver’s Workshop</h1>
<hr>
<p>Through tangled vines and towering trees, the jungle yields a sight to behold—a hidden stone structure carved with intricate glyphs and symbols. The Storyweaver’s Workshop is said to be where ancient scribes encoded their civilization’s wisdom into narratives that held the power to bring lifeless worlds to vivid life. As you step inside, the air hums with quiet energy as stone tablets etched with fragments of forgotten code seem to whisper secrets of adventure. Your task: unravel their mysteries and decipher the tools of storytelling built into the very foundation of the Workshop.</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Adventure orchestration managing state, themes, and user interactions</h3>
<p>The <code class="inline-code">adventure-manager.ts</code> file acts as the central control hub within the Storyweaver’s Workshop. Like an ancient priest performing rituals, it orchestrates the intricate dance of adventure storytelling by integrating user choices, project context, and theme-based creative logic. The <code class="inline-code">AdventureManager.initializeAdventure()</code> function serves as the initiation rite, creating the thematic narrative and generating quests based on repository insights. It cleverly stitches together quests using input validation techniques and merges them into a cohesive journey, aided by functions like <code class="inline-code">mergeQuestFilesFromConfig()</code>. Meanwhile, <code class="inline-code">AdventureManager.exploreQuest()</code> acts as the temple pathway guide—leading users through each chosen quest while ensuring prerequisites are met. Progress is tracked meticulously, with the <code class="inline-code">AdventureState.progressPercentage</code> function calculating how far adventurers have explored. Every aspect of the file reinforces the Workshop’s goal: turning mundane codebases into sacred digital explorations.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure()</code>: Synthesizes theme-based storytelling and quest generation with user-defined inputs.  </li>
<li><code class="inline-code">exploreQuest()</code>: Manages individual quest executions, ensuring prerequisites and progress updates.  </li>
<li><code class="inline-code">mergeQuestFilesFromConfig()</code>: Integrates repository context into the adventure journey.  </li>
<li><code class="inline-code">progressPercentage</code>: Calculates adventure completion percentage for precise tracking.  </li>
<li><code class="inline-code">markQuestCompleted()</code>: Marks quests as finished and ensures caching for revisits.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration system for guided adventures enhancing story generation</h3>
<p>The <code class="inline-code">adventure-config.ts</code> file serves as the parchment that defines the sacred rules and structure of storytelling within the Workshop. The <code class="inline-code">loadAdventureConfig()</code> function unravels the encoded wisdom held in <code class="inline-code">adventure.config.json</code>, ensuring that every quest aligns with the predefined objectives and file paths mentioned in this artifact. By using <code class="inline-code">extractUniqueFilePaths()</code>, the system gathers all referenced files and separates wheat from chaff—focusing only on valid paths that are ripe for exploration. Furthermore, <code class="inline-code">formatAdventureConfigForPrompt()</code> transforms hard-coded guidance into beautifully structured narratives suitable for LLMs, wrapping raw data with the glyphs of generative storytelling. Within this file lies the architectural foundation connecting the Workshop’s coded wisdom to the adventures forged in narrative.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadAdventureConfig()</code>: Uncovers structural rules stored in <code class="inline-code">adventure.config.json</code>.  </li>
<li><code class="inline-code">extractUniqueFilePaths()</code>: Ensures only valid file paths are included in quests.  </li>
<li><code class="inline-code">formatAdventureConfigForPrompt()</code>: Prepares adventure configuration for LLM-readable prompts.  </li>
<li>Thoughtful parsing of JSON artifacts to align quests with narrative requirements.  </li>
<li>Integration of project-specific data into generative processes.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/adventure/story-generator.ts:</span> LLM-powered story creation with theme-based narratives and prompt engineering</h3>
<p>The <code class="inline-code">story-generator.ts</code> file can be likened to the enchanted quill that scribes narrative into existence. This file is the Workshop’s heart, where raw project data transforms into immersive stories and quests. The <code class="inline-code">StoryGenerator.generateStoryAndQuests()</code> function, the spellbinding narrator, works hand-in-hand with advanced LLM algorithms to craft thematic adventures rooted in repository insights. It calls upon <code class="inline-code">buildStoryGenerationPrompt()</code> to assemble intricate prompts—essentially the schematics of quests—while <code class="inline-code">generateQuestContent()</code> dives deep into targeted code analysis, extracting snippets and turning them into treasures of discovery. This file ensures that every adventure feels bespoke, channeling the wisdom of the Storyweaver’s glyphs into crafted narratives.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateStoryAndQuests()</code>: Converts projects into detailed adventures using LLM algorithms.  </li>
<li><code class="inline-code">buildStoryGenerationPrompt()</code>: Creates precise storytelling prompts based on repository context and thematic guidance.  </li>
<li><code class="inline-code">generateQuestContent()</code>: Extracts and transforms code snippets into quest objectives.  </li>
<li>Ensures quests feature practical exploration targets based on real project insights.  </li>
<li>Validates themes to ensure narrative consistency.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">export class AdventureManager {  
  private state: AdventureState = new AdventureState();  
  private storyGenerator: StoryGenerator;  

  constructor() {  
    this.storyGenerator = new StoryGenerator();  
  }  

  async initializeAdventure(  
    projectInfo: ProjectInfo,  
    theme: AdventureTheme,  
    projectPath?: string,  
    customThemeData?: CustomThemeData  
  ): Promise&lt;string&gt; {  
    this.state.reset();  
    this.state.projectInfo = projectInfo;  
    this.state.currentTheme = theme;  
    this.state.projectPath = projectPath || process.cwd();  

    if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {  
      this.storyGenerator.setCustomTheme(customThemeData);  
    }  

    const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);  
    this.state.title = storyResponse.title;  
    this.state.story = typeof storyResponse.story === &#39;string&#39; ? storyResponse.story : storyResponse.story.content;  
    this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);  
    this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);  

    return this.formatStoryWithQuests({  
      ...storyResponse,  
      quests: this.state.quests  
    });  
  }  
}  
</code></pre>
<p>Just like an ancient scribe organizing scrolls, this code orchestrates chaos into structured adventures.  </p>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function loadAdventureConfig(projectPath: string): string | null {  
  const configPath = path.join(projectPath, &#39;adventure.config.json&#39;);  
  return readFileIfExists(configPath);  
}  

export function parseAdventureConfig(projectPath: string): unknown | null {  
  const raw = loadAdventureConfig(projectPath);  
  if (!raw) return null;  
  try {  
    return JSON.parse(raw);  
  } catch {  
    return null;  
  }  
}  

export function formatAdventureConfigForPrompt(projectPath: string): string {  
  const parsed = parseAdventureConfig(projectPath);  
  if (!parsed || typeof parsed !== &#39;object&#39;) {  
    return &#39;&#39;;  
  }  

  let formatted = `## Quest Structure Guidelines\n\n`;  
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;  

  const quests = (parsed as any).adventure.quests || [];  
  quests.forEach((quest: any) =&gt; {  
    if (quest.title &amp;&amp; Array.isArray(quest.files)) {  
      formatted += `### ${quest.title}\n`;  
      formatted += `${quest.description}\n\n`;  
      quest.files.forEach((file: any) =&gt; {  
        if (file.path &amp;&amp; file.description) {  
          formatted += `**File: \`${file.path}\`**\n- Description: ${file.description}\n`;  
        }  
      });  
    }  
    formatted += `\n`;  
  });  

  return formatted;  
}  
</code></pre>
<p>This code is the decoder’s parchment, turning raw configuration into actionable quest guidance.  </p>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">export class StoryGenerator {  
  async generateStoryAndQuests(  
    projectInfo: ProjectInfo,  
    theme: AdventureTheme,  
    projectPath?: string  
  ): Promise&lt;{ title: string; story: string; quests: Quest[] }&gt; {  
    const formattedConfig = formatAdventureConfigForPrompt(projectPath || &#39;&#39;);  
    const prompt = `Construct a thematic coding adventure with the theme &#39;${theme}&#39; based on the following: ${formattedConfig}`;  
    const response = await new LLMClient().generateResponse(prompt);  
    return {  
      title: response.title,  
      story: response.story,  
      quests: response.quests  
    };  
  }  

  async generateQuestContent(  
    quest: Quest,  
    theme: AdventureTheme,  
    codeContent: string  
  ): Promise&lt;{ adventure: string }&gt; {  
    const prompt = `Create a detailed quest content in &#39;${theme}&#39; style based on the following code: ${codeContent}`;  
    const response = await new LLMClient().generateResponse(prompt);  
    return { adventure: response.content };  
  }  
}  
</code></pre>
<p>Like the enchanted quill, this file channels raw code into captivating stories and quests.  </p>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">AdventureManager</code> to create a logical start-to-finish flow for themed quests.  </li>
<li>Refactor <code class="inline-code">formatAdventureConfigForPrompt()</code> to simplify verbose sections without losing essential detail.  </li>
<li>Explore connections between story generation prompts and LLM response formatting for improved narrative fidelity.</li>
</ul>
<hr>
<p>“Our journey through the Storyweaver’s Workshop reveals how tools, configuration, and creativity unite to transform repositories into adventures worth experiencing!”</p>
<p>Hark, noble seeker, thou hast unlocked the sacred chamber of the Storyweaver’s Workshop and etched thy wisdom upon the tablets of enlightenment—forge onward, for the stars themselves bear witness to thy destined glory! ⭐🗺️⚡</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3: The Codex Interpreter →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>