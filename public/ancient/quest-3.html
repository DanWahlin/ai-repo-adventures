<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Glyphs of Code Analysis - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Secrets of the Lost Codebase</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Glyphs of Code Analysis</h1>
<hr>
<p>In the labyrinth of the ancient knowledge vault, you come upon a chamber inscribed with glyphs of guidance. These scripts, though coded in essence, speak in the tongues of a forgotten programming tradition, tasked with extracting context and summoning wisdom from the deeper strata of the Codebase. The glyphs are guarded within two distinct sections of the temple - the <code class="inline-code">repo-analyzer</code> and the <code class="inline-code">llm-client</code> artifacts. Solving these secrets is pivotal to reveal the overarching ritual of automated reasoning.</p>
<p>The day is ripe for decoding these hieroglyphs, brave archaeologist. Proceed with caution and curiosity, for only those who truly comprehend the art of analysis shall uncover the dormant magic.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Token Tallying Ritual</strong>: How does the <code class="inline-code">LLMClient.logTokenUsage</code> method track and display token usage within the system, and how does it contribute to resource monitoring?</li>
<li>‚ö° <strong>Invocation of LLM</strong>: What are the mechanisms and parameters used by <code class="inline-code">LLMClient.generateResponse</code> to construct and execute a request to the language model, and how does the method adapt for specific model versions?</li>
<li>üõ°Ô∏è <strong>Path Validation Rites</strong>: How does <code class="inline-code">RepoAnalyzer.validateProjectPath</code> ensure the integrity and safety of project paths in a robust way to prevent missteps or tampering?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> Language Model Interface</h3>
<p>The <code class="inline-code">LLMClient</code> in this artifact behaves like an emissary to external computation oracles. It is designed to invoke and validate communications with models like OpenAI and Azure OpenAI. Three highlighted rituals in this file reflect its sacred functionalities: initializing the client, generating responses, and logging usage. Together, these mechanisms ensure efficient and structured operation with contextual adaptation to newer model features like GPT-5.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">LLMClient.constructor</code>: Initializes the sacred client, setting up configurations for either OpenAI or Azure OpenAI interactions while validating necessary offerings such as API keys.</li>
<li><code class="inline-code">LLMClient.generateResponse</code>: The central ritual for offering queries (prompts) to the LLM, forging detailed requests, invoking external computation, and processing results while handling errors gracefully.</li>
<li><code class="inline-code">LLMClient.logTokenUsage</code>: Tracks the tokens consumed during invocations, ensuring the practitioner remains aware of resource limitations and magical thresholds.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  
  // Determine API key based on provider
  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key (LLM_API_KEY or GITHUB_TOKEN).&#39;);
  }

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({
      endpoint: azureEndpoint,
      apiKey,
      apiVersion: LLM_API_VERSION,
      deployment: this.model
    });
  } else {
    this.client = new OpenAI({
      apiKey,
      baseURL: LLM_BASE_URL
    });
  }
}
</code></pre>
<ul>
<li>The <code class="inline-code">constructor</code> meticulously checks for environmental offerings, ensuring neither <code class="inline-code">LLM_API_KEY</code> nor <code class="inline-code">LLM_BASE_URL</code> is missing before invoking the setup.</li>
<li>Depending on the client deity (OpenAI or Azure OpenAI), the initiation process morphs to meet the respective protocol needs.</li>
<li>Rigorous validation creates a secure starting point for all subsequent requests within the system.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);

    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
  
    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
    throw new Error(`LLM request failed: ${message}`);
  }
}
</code></pre>
<ul>
<li>This method centers on crafting and dispatching ritual queries (<code class="inline-code">prompt</code>) to the licensed models, managing errors, and post-processing results.</li>
<li>It adapts dynamically for options like <code class="inline-code">json_object</code> output and accounts for model-specific behaviors, such as GPT-5‚Äôs unique parameters.</li>
<li>Token monitoring ties tightly with the invocation process, reflecting the balance between computational cost and insight.</li>
</ul>
<hr>
<pre><code class="language-typescript">private logTokenUsage(completion: any): void {
  if (!completion.usage) return;

  const promptTokens = completion.usage.prompt_tokens || 0;
  const completionTokens = completion.usage.completion_tokens || 0;
  const totalTokens = completion.usage.total_tokens || 0;

  const green = &#39;\x1b[32m&#39;;
  const reset = &#39;\x1b[0m&#39;;
  console.error(`üî¢ LLM Usage: ${green}${formatTokenCount(promptTokens)}${reset} prompt + ${green}${formatTokenCount(completionTokens)}${reset} response = ${green}${formatTokenCount(totalTokens)}${reset} total tokens\n`);
}
</code></pre>
<ul>
<li>Custom token tallying provides clarity on input-output exchanges for practitioners, pairing detailed statistics with ancient-like formatting (color coding to represent success).</li>
<li>This feedback loop benefits resource allocation, ensuring explorers never recklessly exceed magical quotas.</li>
<li>Format string usage like <code class="inline-code">formatTokenCount</code> aids compact yet intuitive representation of numbers.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Code Validation and Analysis</h3>
<p>This script serves as a sentinel of the procedural space, ensuring path security while analyzing and extracting valuable context from the codebase. The focus here lies on the sanctity of project paths and their alignment with the rules of safety. This foundation anchors the surrounding codebase analysis and optimizations to unyielding integrity.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAnalyzer.validateProjectPath</code>: Ensures the sanctity of given project paths by handling invalid inputs, removing unsafe characters, and maintaining robustness against null-byte vulnerabilities.</li>
<li><code class="inline-code">RepoAnalyzer.generateRepomixContext</code>: Provides an overarching context extraction mechanism by invoking Repomix and caching its results for reuse.</li>
<li><code class="inline-code">RepoAnalyzer.captureRepomixStdout</code>: Describes how output from a Repomix subprocess is captured while maintaining system safety during execution.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  // Basic safety check for null bytes (can break file system operations)
  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<ul>
<li>This validation ritual ensures the sanctity of paths by stripping whitespace and rejecting malformed or dangerous entries, such as those containing null bytes.</li>
<li>By focusing on essential hygiene checks, the safety of file system operations downstream is maintained rigorously.</li>
<li>Trimmed inputs ensure user errors do not affect the system‚Äôs predictability.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);

  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
  
  try {
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<ul>
<li>Validates paths before invoking <code class="inline-code">Repomix</code>, ensuring analysis rituals only operate on blessed grounds.</li>
<li>Adds caching to optimize memory and computational effort across repeated calls.</li>
<li>Encapsulates error handling without silencing issues critical to debugging and safety.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [&#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
    if (options.compress) args.push(&#39;--compress&#39;);
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], {
      cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]
    });

    repomix.stdout.on(&#39;data&#39;, (data) =&gt; stdout += data.toString());
    repomix.stderr.on(&#39;data&#39;, (data) =&gt; stderr += data.toString());
    
    repomix.on(&#39;close&#39;, (code) =&gt; {
      if (code !== 0) reject(new Error(`Repomix failed (exit ${code}): ${stderr}`));
      else resolve(stdout);
    });

    repomix.on(&#39;error&#39;, reject);
  });
}
</code></pre>
<ul>
<li>Uses a secure subprocess to invoke Repomix while sanitizing its arguments to avoid vulnerabilities.</li>
<li>Timeout handling ensures the subprocess cannot monopolize resources indefinitely.</li>
<li>Coupled with validation methods, this strengthens defenses against malicious input artifacts.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>To unearth more treasures, observe how methods in <code class="inline-code">RepoAnalyzer</code> modularize safety and usability for broader downstream purposes.</li>
<li>Trace the <code class="inline-code">LLMClient.generateResponse</code> flow to see the interplay between error mechanisms and contextual model interactions.</li>
<li>Take note of caching mechanisms in both files for hints on optimizing similar patterns.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hark, valiant seeker, thou hast unraveled the sacred Glyphs of Code Analysis, ascending yet deeper into the temple of wisdom‚Äîlo, thy journey stands illuminated at 40%, a resplendent beacon of thy burgeoning mastery! ‚≠ê‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>