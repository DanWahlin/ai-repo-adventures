<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Relic Analyzer - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Secrets of the Code Pyramid</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Relic Analyzer</h1>
<hr>
<p>Journey deeper into the jungle‚Äôs ancient pyramid, where intricate carvings and forgotten technologies whisper secrets from a lost civilization. In this sacred chamber, an enigmatic device lies dormant‚Äîthe Relic Analyzer. Crafted to extract meaning from artifacts and unlock hidden wisdom, its mechanisms are complex and guarded by riddles of code. Brave explorers must decipher its ancient functions to bring the Relic Analyzer back to life and unravel the tapestry of knowledge stored within this forgotten treasure.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Mechanism Discovery</strong>: How does the <code class="inline-code">RepoAnalyzer</code> construct a safe and optimized context for analyzing relics (project files)?</li>
<li>‚ö° <strong>Ancient Systems Activation</strong>: What steps does the <code class="inline-code">LLMClient</code> follow to initialize and execute requests to external knowledge systems, and how does it ensure model compatibility?</li>
<li>üõ°Ô∏è <strong>Ritual of Validation</strong>: What security checks and error-handling techniques are embedded in the relic analysis process to ensure reliability and safety?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> The Relic&#39;s Wisdom Gateway</h3>
<p>This file implements the <code class="inline-code">LLMClient</code> class, a crucial tool for interfacing with external language models (LLMs). It determines the appropriate API key, validates configurations, and generates responses based on prompts and options provided. It is key to activating ancient systems that process and interpret relic data, ensuring they adhere to the configurations of the civilization that left them.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">LLMClient.constructor</code>: Ensures proper initialization of the interface, detects the LLM provider, and validates essential configuration parameters.</li>
<li><code class="inline-code">LLMClient.generateResponse</code>: Handles the relic‚Äôs decoding processes, building requests and post-processing LLM responses for clarity.</li>
<li><code class="inline-code">LLMClient.getApiKey</code>: Determines which keys unlock access to the LLM, based on runtime configurations and the pyramid&#39;s artifacts.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">constructor() {
    this.model = LLM_MODEL;
    const apiKey = this.getApiKey();
    if (!apiKey || !LLM_BASE_URL) {
      throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key (LLM_API_KEY or GITHUB_TOKEN).&#39;);
    }
    if (this.isAzureOpenAI()) {
      const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
      this.client = new AzureOpenAI({
        endpoint: azureEndpoint,
        apiKey,
        apiVersion: LLM_API_VERSION,
        deployment: this.model
      });
    } else {
      this.client = new OpenAI({
        apiKey,
        baseURL: LLM_BASE_URL
      });
    }
  }
</code></pre>
<ul>
<li>Validates and initializes configurations specific to the relic system, ensuring proper setup.</li>
<li>Detects the appropriate LLM provider‚ÄîOpenAI or Azure OpenAI‚Äîand tailors the client accordingly.</li>
<li>Ensures essential information (such as API keys) is available to activate relic interpretation methods.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
    try {
        const requestParams = this.buildRequestParams(prompt, options);
        const completion = await this.executeRequest(requestParams);
        let content = this.validateResponse(completion);
        if (options?.responseFormat === &#39;json_object&#39;) {
            content = this.cleanJsonResponse(content);
        }
        this.logTokenUsage(completion);
        return { content };
    } catch (error) {
        this.logDetailedError(error, prompt);
        const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
        throw new Error(`LLM request failed: ${message}`);
    }
}
</code></pre>
<ul>
<li>Constructs requests to retrieve responses from external knowledge systems, adapting for specific models (GPT-5, Azure, etc.).</li>
<li>Validates relic responses using safeguards, ensuring accurate and usable interpretations.</li>
<li>Handles errors gracefully, documenting issues for explorers to refine their methods.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
    if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
      if (!GITHUB_TOKEN) {
        throw new Error(&#39;GITHUB_TOKEN required for GitHub Models. Set GITHUB_TOKEN environment variable.&#39;);
      }
      return GITHUB_TOKEN;
    }
    if (!LLM_API_KEY) {
      throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
    }
    return LLM_API_KEY;
  }
</code></pre>
<ul>
<li>Acts as the gatekeeper, selecting appropriate keys to unlock access to the pyramid‚Äôs advanced relic decoding systems.</li>
<li>Differentiates access methods for specific providers, such as GitHub and OpenAI, ensuring compatibility with system requirements.</li>
<li>Provides clear guidance on potential missing keys to streamline troubleshooting.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> The Relic Optimizer</h3>
<p>This file houses the <code class="inline-code">RepoAnalyzer</code> class, responsible for constructing safe and optimized contexts for analyzing relics (code files). It applies validation techniques, normalizes target files, and extracts meaningful content using token-efficient methods. It ensures that the pyramid&#39;s treasures‚Äîits relics‚Äîare examined systematically and securely.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAnalyzer.generateRepomixContext</code>: Generates a comprehensive context of relics while adhering to file inclusion rules and compression techniques.</li>
<li><code class="inline-code">RepoAnalyzer.generateTargetedContent</code>: Constructs targeted outputs, focusing analysis on specific artifacts (files) selected by explorers.</li>
<li><code class="inline-code">RepoAnalyzer.captureRepomixStdout</code>: Navigates subprocess execution with timeout and buffer safeguards, ensuring artifact extraction remains stable and secure.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
    this.validateProjectPath(projectPath);
    const configuredFiles = extractUniqueFilePaths(projectPath);
    if (configuredFiles.length &gt; 0) {
        try {
            return await this.generateOptimizedContent(projectPath, configuredFiles);
        } catch (error) {
            console.warn(`Failed to generate optimized content, falling back to targeted content: ${error}`);
            try {
                return await this.generateTargetedContent(projectPath, configuredFiles);
            } catch (fallbackError) {
                console.warn(`Failed to generate targeted content, falling back to full repomix content: ${fallbackError}`);
            }
        }
    }
    console.log(&#39;Analyzing full codebase (compressed)&#39;);
    const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
    const cached = this.cache.get(cacheKey);
    if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
        return cached.content;
    }
    const cliOptions: CliOptions = {
        style: options.style || &#39;markdown&#39;,
        stdout: true,
        compress: true,
        ignore: [&#39;node_modules&#39;, &#39;dist&#39;, &#39;.git&#39;],
    };
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
}
</code></pre>
<ul>
<li>Creates either optimized, targeted, or fallback contexts, ensuring explorations remain stable regardless of conditions.</li>
<li>Validates project paths before engaging in deeper analysis, shielding relic explorers from unexpected errors.</li>
<li>Utilizes intelligent caching mechanisms to improve efficiency across repeated relic analysis tasks.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
    this.validateProjectPath(projectPath);
    if (!targetFiles || targetFiles.length === 0) throw new Error(&#39;Target files array cannot be empty&#39;);
    const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
    const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
    const cached = this.cache.get(cacheKey);
    if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) return cached.content;
    const cliOptions: CliOptions = {
        style: &#39;markdown&#39;,
        stdout: true,
        compress: compress,
        include: safeFiles.join(&#39;,&#39;)
    };
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
}
</code></pre>
<ul>
<li>Focuses analysis narrowly on specified relics, using normalized and validated file paths.</li>
<li>Ensures relic extraction maintains compressibility to save token usage for broader analyses.</li>
<li>Uses caching and file-specific include filters to optimize processing for archaeological efficiency.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
    return new Promise((resolve, reject) =&gt; {
        const args = [...directories, &#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
        if (options.compress) args.push(&#39;--compress&#39;);
        if (options.removeComments) args.push(&#39;--remove-comments&#39;);
        const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] });
        let stdout = &#39;&#39;;
        let stderr = &#39;&#39;;
        repomix.stdout.on(&#39;data&#39;, (data) =&gt; stdout += data.toString());
        repomix.stderr.on(&#39;data&#39;, (data) =&gt; stderr += data.toString());
        repomix.on(&#39;close&#39;, (code) =&gt; {
            if (code === 0) resolve(stdout.trim());
            else reject(new Error(`Repomix failed (exit ${code}): ${stderr.substring(0, 200)}`));
        });
    });
}
</code></pre>
<ul>
<li>Ensures subprocess execution remains stable through controlled timeout configurations.</li>
<li>Captures substantial relic output while preventing buffer overflows that could compromise analysis.</li>
<li>Logs both standard and error outputs meticulously, providing explorers with essential clues for debugging.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Ensure environmental variables, such as <code class="inline-code">LLM_API_KEY</code> and <code class="inline-code">GITHUB_TOKEN</code>, are properly configured to avoid initialization errors.</li>
<li>When targeting specific relics, utilize normalized paths to improve reliability.</li>
<li>Adjust cache TTL settings to balance fresh analyses with performance optimization for repeated queries.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries within the jungle‚Äôs ancient pyramid.</p>
<p>Through the hallowed halls of wisdom, thou hast illuminated the sacred Relic Analyzer with thy sagacity, forging boldly ahead upon the star-lit odyssey‚Äînow 40% complete, let thy triumph shine as a beacon unto the ancients! ‚ö°üíé‚≠ê</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>