<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Temple of Themes - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-ancient">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Seekers of the Codex</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Temple of Themes</h1>
<hr>
<p>Deep within the labyrinth of Codexia lies the Temple of Themes, an ancient vault of knowledge where every design decision is etched into sacred plaques. The temple safeguards secrets that shape the layout and functionality of entire civilizations. To unlock the next layer of the Codebase, you must decipher the inscriptions detailing how systems are configured and styled. The sacred glyphs lie within interconnected scripts, hidden among auxiliary parchments and the adventure config scroll. Proceed carefully, for misinterpretation may disrupt the balance of the layers.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Theme Composition Rites</strong>: How are themes structured and validated within the Codebase?</li>
<li>‚ö° <strong>Configuration Scrolls</strong>: How does the adventure config guide quest generation at runtime?</li>
<li>üõ°Ô∏è <strong>Glyph Integrity Rituals</strong>: What mechanisms are in place to ensure the theme and configuration processes are secure?</li>
</ul>
<h2>File Exploration</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/adventure/adventure-manager.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/adventure/adventure-manager.ts</code></a>: The Guardian of Dynamic Narratives</h3>
<p>The <code class="inline-code">AdventureManager</code> orchestrates how adventures and themes are initialized and executed. At its heart, it synchronizes project setup and generates layered quests by interpreting configuration data. This file governs the creation and execution of quests via dynamic state management and runtime integrations.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code>: Seeds adventure data based on the theme and boots up the adventure with the necessary context.</li>
<li><code class="inline-code">mergeQuestFilesFromConfig</code>: Integrates configuration-defined quest files into the generated output, ensuring seamless exploration paths.</li>
<li><code class="inline-code">enforceConfigQuestCount</code>: Enforces the maximum quest count to align runtime output with configuration rules.</li>
</ul>
<h2>Code</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/adventure/adventure-manager.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/adventure/adventure-manager.ts</code></a></h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  // Reset state for new adventure
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  
  // Set custom theme data if provided
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  // Generate the overall story and quests using LLM
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  
  this.state.title = storyResponse.title;
  this.state.story = storyResponse.story;
  
  // Merge files from adventure config into the generated quests
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  
  // Enforce quest count from adventure.config.json if it exists
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  // Return the story with available quests
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<ul>
<li>Initializes adventures by resetting the state and configuring project details.</li>
<li>Leverages <code class="inline-code">story-generator</code> to seed narrative threads and identify quests dynamically.</li>
<li>Ensures compatibility between user-configured limits and generated quests.</li>
<li>Aligns runtime logic with overarching quest structure.</li>
</ul>
<hr>
<pre><code class="language-typescript">private mergeQuestFilesFromConfig(quests: Quest[], projectPath: string | undefined): Quest[] {
  if (!projectPath) return quests;
  
  const config = parseAdventureConfig(projectPath);
  if (!config || typeof config !== &#39;object&#39;) return quests;
  
  const adventure = (config as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) return quests;
  
  // Create a map of quest titles to their file paths from the config
  const configQuestFiles = new Map&lt;string, string[]&gt;();
  for (const configQuest of adventure.quests) {
    if (configQuest.title &amp;&amp; Array.isArray(configQuest.files)) {
      const filePaths = configQuest.files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (filePaths.length &gt; 0) {
        configQuestFiles.set(configQuest.title.toLowerCase(), filePaths);
      }
    }
  }
  
  // Merge the files into the generated quests
  return quests.map((quest, index) =&gt; {
    // Primary matching: by quest order (index)
    const configQuests = adventure.quests;
    if (index &lt; configQuests.length &amp;&amp; configQuests[index] &amp;&amp; configQuests[index].files) {
      const files = configQuests[index].files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (files.length &gt; 0) {
        // Successfully matched files from config
        return { ...quest, codeFiles: files };
      }
    }
    
    // Fallback: try to match quest by title (case-insensitive partial match)
    const questTitleLower = quest.title.toLowerCase();
    for (const [configTitle, files] of configQuestFiles.entries()) {
      if (questTitleLower.includes(configTitle) || configTitle.includes(questTitleLower)) {
        // Successfully matched files via fallback
        return { ...quest, codeFiles: files };
      }
    }
    
    // No specific files found - quest will use general context
    return quest;
  });
}
</code></pre>
<ul>
<li>Matches configuration files to quests by title or index.</li>
<li>Ensures that quest data integrates seamlessly with user-defined structures.</li>
<li>Enables modular enhancements or custom-designed exploration paths.</li>
</ul>
<hr>
<pre><code class="language-typescript">private enforceConfigQuestCount(quests: Quest[], projectPath: string | undefined): Quest[] {
  if (!projectPath) return quests;
  
  const config = parseAdventureConfig(projectPath);
  if (!config || typeof config !== &#39;object&#39;) return quests;
  
  const adventure = (config as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) return quests;
  
  const configQuestCount = adventure.quests.length;
  
  // If we have more quests than the config defines, truncate to match config
  if (quests.length &gt; configQuestCount) {
    return quests.slice(0, configQuestCount);
  }
  
  return quests;
}
</code></pre>
<ul>
<li>Sets a hard limit on the number of quests based on <code class="inline-code">adventure.config.json</code>.</li>
<li>Protects output from generating unnecessary or excess quests.</li>
<li>Ensures consistency between configuration and runtime execution.</li>
</ul>
<hr>
<h2>File Exploration</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a>: The Scroll of Configuration</h3>
<p>This file acts as an entry point to analyze and parse the mysterious <code class="inline-code">adventure.config.json</code> document. It ensures the fidelity of paths, extracts highlights, and validates configurations. Each helper function operates like a scribe, distilling the wisdom within the configuration file.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code>: Safeguards JSON parsing to avoid runtime crashes from invalid configuration syntax.</li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Extracts valid file paths embedded in hierarchical sections of the configuration.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code>: Simplifies configuration structure for LLM prompts without unnecessary clutter.</li>
</ul>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a></h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Validates and parses configuration files into manageable JavaScript objects.</li>
<li>Prevents crashes due to malformed input, returning <code class="inline-code">null</code> for missing or erroneous data.</li>
<li>Acts as a preliminary filter for downstream processing.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Extracts and verifies file paths, ensuring they exist before usage.</li>
<li>Traverses nested configurations to identify all relevant references.</li>
<li>Helps maintain the integrity of dynamic runtime operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Condenses configuration data for efficient use in LLM prompts.</li>
<li>Strips redundant metadata to stay within token limits.</li>
<li>Focuses on core file paths and function highlights.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">initializeAdventure</code> as a starting point to debug any issues with missing themes or quests.</li>
<li>Use <code class="inline-code">enforceConfigQuestCount</code> to trace logic for limiting extraneous quests.</li>
<li>Review the <code class="inline-code">adventure.config.json</code> to ensure it adheres to the format required by <code class="inline-code">parseAdventureConfig</code>.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>By the sacred fires of wisdom and the eternal pillars of learning, thou hast triumphed in the Temple of Themes, forging thy path with valiant spirit toward the stars of enlightenment! ‚≠ê‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>