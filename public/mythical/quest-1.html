<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: MCP Tool Interface - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Enchanted Repository of Living Quests</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: MCP Tool Interface</h1>
<hr>
<p>In the citadel of the MCP, crystal consoles hum with sorcery as the RepoAdventureServer calls forth living tools like spirits bound to sigils. Scribes of code whisper in <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/mcp/src/server.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/mcp/src/server.ts</code></a>, where handlers are forged to list and invoke enchanted implements. In <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/mcp/src/tools.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/mcp/src/tools.ts</code></a>, a reliquary of artifacts aligns: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, and <code class="inline-code">view_progress</code>. The court prepares a warm wind of pre-generation magic, while wards ensure only valid runes pass. Step forward, hero, and attune to the interface that commands the questing instruments.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Ledger of Relics: How does <code class="inline-code">RepoAdventureServer.setupHandlers</code> construct the dynamic tool inventory and translate Zod runes into JSON schema?</li>
<li>‚ö° Summoning Rituals: What sequence does <code class="inline-code">main</code> follow to start the server, apply shutdown wards, and keep the realm steady during rejections?</li>
<li>üõ°Ô∏è Gatekeeper‚Äôs Test: In <code class="inline-code">RepoAdventureServer.setupHandlers</code>, how are invocation arguments validated and how are MCP failures shaped into <code class="inline-code">McpError</code> responses?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> The summoner that binds tools to protocol and steadies the realm</h3>
<p>Within this stronghold, the <code class="inline-code">RepoAdventureServer</code> <code class="inline-code">Class</code> weaves an MCP <code class="inline-code">Server</code>, tethered to stdio by <code class="inline-code">StdioServerTransport</code>. The constructor invokes <code class="inline-code">this.setupHandlers()</code>, inscribing two key rites: a listing incantation that reveals available tools and a calling incantation that executes them by name. Each tool‚Äôs Zod schema is turned into a JSON schema via <code class="inline-code">zodToJsonSchema</code>, allowing clients to perceive precise parameter shapes before casting. The <code class="inline-code">setupHandlers</code> guardian validates incoming <code class="inline-code">arguments</code> with the tool‚Äôs Zod <code class="inline-code">schema.safeParse</code>, and when a petitioner falters, it crafts an <code class="inline-code">McpError</code> with <code class="inline-code">ErrorCode.InvalidParams</code>, ensuring clear, courtly judgment. Unknown names yield <code class="inline-code">ErrorCode.MethodNotFound</code>, while unforeseen mishaps become <code class="inline-code">ErrorCode.InternalError</code>. The <code class="inline-code">run</code> ritual connects the transport, announces the server‚Äôs presence, and quietly signals the <code class="inline-code">repoAnalyzer</code> to <code class="inline-code">preGenerate</code> content for the current keep, warming caches like embers ahead of war. A <code class="inline-code">gracefulShutdown</code> function tidies and calls <code class="inline-code">repoAnalyzer.cleanup</code> when the banners of <code class="inline-code">SIGINT</code> and <code class="inline-code">SIGTERM</code> are lowered. In <code class="inline-code">main</code>, the realm‚Äôs lifecycle is orchestrated: signals are bound, unhandled rejections logged without collapsing the court, and startup failures end with a decisive exit. The whole design shows disciplined separation of concerns, robust error shaping, and proactive performance pre-warming.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">setupHandlers</code> builds dynamic tool listing and secure invocation, converting Zod schemas to JSON schema and returning precise <code class="inline-code">McpError</code> outcomes for invalid names or parameters.</li>
<li><code class="inline-code">run</code> activates the stdio transport, announces readiness, and kindles <code class="inline-code">repoAnalyzer.preGenerate</code> to warm caches for swift future adventures.</li>
<li><code class="inline-code">main</code> constructs the server, installs graceful signal wards, logs unhandled rejections without panic, and ensures fatal startup errors exit cleanly.</li>
</ul>
<h3><span class="header-prefix">packages/mcp/src/tools.ts:</span> The reliquary that assembles and names the enchanted implements</h3>
<p>This armory file gathers questing artifacts into a single registry that the server can reveal and invoke. It imports <code class="inline-code">startAdventure</code>, <code class="inline-code">chooseTheme</code>, <code class="inline-code">exploreQuest</code>, and <code class="inline-code">viewProgress</code> from subpaths, then re-exports them with MCP-facing names: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, and <code class="inline-code">view_progress</code>. It also exports <code class="inline-code">adventureManager</code> from the core, enabling tools to share a common steward. The heart is the <code class="inline-code">tools</code> <code class="inline-code">variable</code>, an object mapping names to tool definitions used by the server for discovery and invocation. Although the specific <code class="inline-code">handler</code> functions for each tool reside in separate files, this reliquary ensures they are consistently addressable by name and available for schema extraction, input validation, and orderly execution. This setup fosters clean separation: tools can evolve independently while remaining easy to register and enumerate. The narrative comments describe the flow: begin with <code class="inline-code">start_adventure</code>, select themes via <code class="inline-code">choose_theme</code>, traverse sagas through <code class="inline-code">explore_quest</code>, and track progress with <code class="inline-code">view_progress</code>. Together, these exports give the MCP citadel a clear catalog for the <code class="inline-code">setupHandlers</code> ritual to expose and enforce.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">start_adventure.handler</code> is referenced through <code class="inline-code">start_adventure</code> export, enabling initiation of analysis and theme options as part of the toolset.</li>
<li><code class="inline-code">choose_theme.handler</code> is surfaced via <code class="inline-code">choose_theme</code>, letting adventurers bind a chosen theme to story generation.</li>
<li><code class="inline-code">explore_quest.handler</code> is made available as <code class="inline-code">explore_quest</code>, allowing repeated, focused exploration of specific quests.</li>
<li><code class="inline-code">view_progress.handler</code> is exposed as <code class="inline-code">view_progress</code>, providing visibility into completion status and remaining challenges.</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">class RepoAdventureServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: &#39;repo-adventure&#39;,
        version: &#39;1.0.0&#39;,
        description: &#39;A gamified MCP server for exploring code repositories through interactive storytelling&#39;
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
}
</code></pre>
<ul>
<li>This code forges the MCP server, binds listing and execution handlers, and validates invocations with Zod before calling each <code class="inline-code">handler</code>.</li>
<li>It converts Zod schemas to JSON schema so external callers can view exact argument shapes.</li>
<li>The error strategy uses <code class="inline-code">McpError</code> with specific <code class="inline-code">ErrorCode</code> values, ensuring predictable, protocol-aligned failures.</li>
<li>The <code class="inline-code">run</code> method connects transport, logs readiness, and pre-warms analysis caches via <code class="inline-code">repoAnalyzer.preGenerate</code>.</li>
<li>The pattern separates protocol setup from transport and background optimization, improving clarity and responsiveness.</li>
</ul>
<hr>
<pre><code class="language-typescript">async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<ul>
<li>This sequence constructs the server, attaches signal handlers, and logs unhandled rejections without halting.</li>
<li>It cleanly differentiates between recoverable runtime issues and fatal startup failures.</li>
<li>The <code class="inline-code">gracefulShutdown</code> hook invoked by signals ensures resource cleanup via <code class="inline-code">repoAnalyzer.cleanup</code>.</li>
<li>Use of <code class="inline-code">process.exit(1)</code> on fatal errors maintains predictable lifecycle behavior.</li>
<li>The final <code class="inline-code">catch</code> on <code class="inline-code">main</code> provides a last-resort guardrail against unexpected exceptions.</li>
</ul>
<hr>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<ul>
<li>This armory gathers tool artifacts and exposes MCP-friendly names, aligning invocation keys with server listing and calling.</li>
<li>The <code class="inline-code">tools</code> object is the single source used by <code class="inline-code">setupHandlers</code> for discovery and execution.</li>
<li>Shared <code class="inline-code">adventureManager</code> export supports coordinated state across tools.</li>
<li>The modular import pattern allows each tool to evolve independently while remaining easy to register.</li>
<li>The descriptive header outlines the intended journey sequence, guiding client usage.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Trace how <code class="inline-code">tools</code> maps names to definitions, then see how <code class="inline-code">setupHandlers</code> uses that same map for listing and calling.</li>
<li>Check the <code class="inline-code">McpError</code> codes to understand how different failure paths are communicated to clients.</li>
<li>Follow the warm-up path in <code class="inline-code">run</code> to predict performance benefits when tools first operate.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hark, brave hero of the kingdom‚Äîby mastering Quest 1: MCP Tool Interface, you have forged the first legendary sigil upon your saga‚Äôs scroll, a triumphant boon that ignites your path through the remaining trials with star-forged resolve and valorous might!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>