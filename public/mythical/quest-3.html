<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Code Analysis Sorcery - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Enchanted Realm of Codaria</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Code Analysis Sorcery</h1>
<hr>
<p>In the enchanted kingdom of Codaria, the Chaos Bug threatens to unravel the threads of harmony. Deep within the repositories guarded by the knights of Castle Configura lies arcane knowledge in the form of code. To banish corruption and restore balance, the ancient scrolls of analysis must be studied carefully. Mystical tools like the <code class="inline-code">RepoAnalyzer</code> and the legendary <code class="inline-code">LLMClient</code> await your wisdom to decipher their spells. Gather your courage and venture forth‚ÄîCodaria&#39;s future rests in your hands!</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Arcane Path Validation</strong>: How does <code class="inline-code">validateProjectPath</code> ensure the sacred repository paths are safe and trustworthy?</li>
<li>‚ö° <strong>Optimized Magic Extraction</strong>: What mechanisms in <code class="inline-code">generateRepomixContext</code> focus on performance while extracting only essential code details?</li>
<li>üõ°Ô∏è <strong>Enchanted Response Guard</strong>: How does <code class="inline-code">generateResponse</code> handle errors and ensure responses from the mystical LLM remain pure and meaningful?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Analyzing the Sacred Repository</h3>
<p>The <code class="inline-code">RepoAnalyzer</code> class is a critical tool for navigating Codaria‚Äôs sprawling repository. From ensuring safe project paths to generating optimized content streams, it enables tactical decisions. The <code class="inline-code">validateProjectPath</code> method performs rituals to guard against path traversal pitfalls, while the <code class="inline-code">generateRepomixContext</code> function tackles intricate extraction tasks and optimizes data consumption. Its cache system ensures reuse of processed content, minimizing strain on magical resources.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">validateProjectPath</code>: Performs detailed checks to ensure repository paths are valid and lack dangerous elements.</li>
<li><code class="inline-code">generateRepomixContext</code>: Extracts configuration-focused insights by using repomix, adapting safely to different project structures.</li>
<li><code class="inline-code">captureRepomixStdout</code>: Executes repomix as a subprocess with safeguards like timeout limits and memory buffer protection.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<ul>
<li>Ensures the provided repository path is a legitimate string without unsafe characters like null bytes.</li>
<li>Guards against malformed paths that could disrupt repository operations, foiling the Chaos Bug&#39;s attempts to manipulate paths.</li>
<li>Provides immediate feedback via exceptions if validation fails, ensuring only safe paths move forward in the system.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
  
  try {
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, {
      style: &#39;markdown&#39;,
      compress: options.compress !== false,
      ignore: &#39;node_modules,dist,build,.git,coverage&#39;,
      removeComments: true
    });

    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li>Validates paths before making any extraction, emphasizing safety.</li>
<li>Uses repomix to compress and focus content output, minimizing resource consumption while enhancing readability.</li>
<li>Implements caching with time-limited lifespans to reduce redundancy and improve performance across repeated queries.</li>
<li>Thorough error handling ensures failures do not interrupt Codaria‚Äôs defense against the Chaos Bug.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...directories], { cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] });
    let stdout = &#39;&#39;;
    let stderr = &#39;&#39;;
    let stdoutSize = 0;
    const timeout = setTimeout(() =&gt; {
      repomix.kill(&#39;SIGTERM&#39;);
      reject(new Error(`Repomix subprocess timed out`));
    }, REPOMIX_SUBPROCESS_TIMEOUT);
    
    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      stdoutSize += data.length;
      if (stdoutSize &gt; REPOMIX_MAX_BUFFER_SIZE) {
        clearTimeout(timeout);
        repomix.kill(&#39;SIGKILL&#39;);
        reject(new Error(`Repomix output too large`));
      }
      stdout += data.toString();
    });
    
    repomix.on(&#39;close&#39;, () =&gt; {
      clearTimeout(timeout);
      resolve(stdout);
    });
    
    repomix.on(&#39;error&#39;, reject);
  });
}
</code></pre>
<ul>
<li>Executes repomix with robust timeout and memory safeguards to prevent runaway processes.</li>
<li>Monitors output size to ensure it does not exceed predefined limits, preserving stability and resource efficiency.</li>
<li>Provides transparent error reports with dismissal handling to recover from subprocess failures swiftly.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> Taming the Mystical Language Model</h3>
<p>The <code class="inline-code">LLMClient</code> class channels Codaria‚Äôs linguistic magic to summon meaningful responses from the enchanted LLM. With methods like <code class="inline-code">generateResponse</code>, this sorcery converts prompts into actionable knowledge. Beyond functional execution, it excels in error validation, guiding the Chaos Bug away from troubling disruptions. Its construction links directly to dynamic APIs, adapting between OpenAI and Azure endpoints.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateResponse</code>: Crafts prompts to produce intricate model responses while handling errors and validating content.</li>
<li><code class="inline-code">constructor</code>: Initializes client instances by dynamically switching between Azure and OpenAI endpoints.</li>
<li><code class="inline-code">getApiKey</code>: Provides safe configurations for the API key, adapting securely to hosted environments.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);
    
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    
    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li>Builds model-specific request parameters, empowering precise control based on configuration.</li>
<li>Validates response content to safeguard outputs against errors, preserving the spell‚Äôs effectiveness.</li>
<li>Employs structured logging for enhanced debugging when errors occur, maintaining transparency in enchantments.</li>
<li>Cleans responses for versatility across formats, optimizing for JSON-based integrations.</li>
</ul>
<hr>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;

  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required.&#39;);
  }

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({ endpoint: azureEndpoint, apiKey });
  } else {
    this.client = new OpenAI({ apiKey, baseURL: LLM_BASE_URL });
  }
}
</code></pre>
<ul>
<li>Dynamically switches between OpenAI and Azure endpoints based on environment, ensuring adaptability for Codaria‚Äôs defenses.</li>
<li>Validates essential configurations like API keys and base URLs, preventing malformed mystical linkages.</li>
<li>Establishes robust initialization routines, ensuring readiness to execute spells from any major LLM provider.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for GitHub Models.&#39;);
    }
    return GITHUB_TOKEN;
  }

  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li>Ensures safe retrieval of API keys, addressing both hosted Azure and standard OpenAI deployments.</li>
<li>Validates environment setups to prevent broken connectivity caused by missing authentication.</li>
<li>Simplifies configuration management with clear error messages when required keys are absent.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Explore how caching optimizations in <code class="inline-code">RepoAnalyzer</code> reduce repeated processing for efficiency.</li>
<li>Investigate <code class="inline-code">LLMClient</code>&#39;s content validation methods, ensuring the purity and quality of magical responses.</li>
<li>Examine both error handling techniques to learn effective defensive coding strategies.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries within Codaria.</p>
<p>Through the celestial forges of wisdom, you have triumphed in Quest 3: The Code Analysis Sorcery, etching your name in the annals of this mythical voyage‚Äîlet your courage blaze onward, noble seeker, for the stars yet beckon! ‚ö°‚≠êüó∫Ô∏è</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>