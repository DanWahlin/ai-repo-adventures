<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Codex of Analysis - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Enchanted Repository and the Chronicles of Code</a>
            </div>
            <div class="nav-middle">
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="../index.html" class="nav-link">Change Theme</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: Codex of Analysis</h1>
<hr>
<p>In the heart of Codemyr, where streams of mystic coding energy intertwine, lies the Enchanted Repository. As the kingdom faces its most dire disturbance yet, brave adventurers must delve into the Codex of Analysis‚Äîa gateway to understanding the inner workings of the repository itself. To restore harmony, deciphering spells found within the codex will reveal the secrets that power Codemyr&#39;s enchanted scrolls. Venture deeper into these mystical systems and uncover the truth hidden in the Codex of Analysis.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Mystic Connection</strong>: How does the <code class="inline-code">generateRepomixContext</code> function ensure safe handling of repository path validation and content extraction?</li>
<li>‚ö° <strong>Codex Invocation</strong>: What patterns and safeguards does the <code class="inline-code">generateResponse</code> method employ to communicate with the LLM and process its responses?</li>
<li>üõ°Ô∏è <strong>Enchantment Boundaries</strong>: How does <code class="inline-code">validateProjectPath</code> enforce security and reliability in path validation to prevent erroneous or malicious inputs?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> The Arcane Communication Conduit</h3>
<p>This file serves as the interface between Codemyr&#39;s system and the magical language models (LLM) that decipher scrolls. It establishes core safeguards, invokes spells (API calls), and processes their enchanted responses to ensure the repository&#39;s secrets are unearthed safely.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateResponse</code>: A critical function for generating responses from the LLM while handling errors and ensuring content validity. This method embodies the flow of spell invocation and enchantment interpretation.</li>
<li><code class="inline-code">constructor</code>: Sets up the initial configuration of the mystical client, choosing between OpenAI and Azure OpenAI based on environment variables.</li>
<li><code class="inline-code">getApiKey</code>: Implements secure mechanisms to determine and validate the appropriate API key for spellbinding.</li>
<li><code class="inline-code">isAzureOpenAI</code>: Checks the nature of the underlying arcane system, ensuring compatibility with Azure&#39;s enchanted services.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);
    
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    
    this.logTokenUsage(completion);
    
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
    throw new Error(`LLM request failed: ${message}`);
  }
}
</code></pre>
<ul>
<li>Safeguards are integrated through method-specific validation functions like <code class="inline-code">validateResponse</code> and <code class="inline-code">cleanJsonResponse</code>, ensuring response integrity.</li>
<li>Error handling is detailed, logging challenges and raising meaningful messages that maintain control during spell invocation.</li>
<li>Token usage monitoring highlights resource consumption, ensuring efficiency in mystical spell casting.</li>
</ul>
<hr>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  
  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key (LLM_API_KEY or GITHUB_TOKEN).&#39;);
  }

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({
      endpoint: azureEndpoint,
      apiKey,
      apiVersion: LLM_API_VERSION,
      deployment: this.model
    });
  } else {
    this.client = new OpenAI({
      apiKey,
      baseURL: LLM_BASE_URL
    });
  }
}
</code></pre>
<ul>
<li>Ensures proper model configuration, throwing errors only if essential mystical variables are absent.</li>
<li>Differentiates between Azure OpenAI and regular OpenAI for compatibility across magical systems.</li>
<li>Implements deployment-specific adjustments, maintaining the arcane flow between codex layers.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for GitHub Models. Set GITHUB_TOKEN environment variable.&#39;);
    }
    return GITHUB_TOKEN;
  }
  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li>Dynamically selects the required key based on provider, ensuring secure access control.</li>
<li>Validates presence of necessary tokens, preventing unauthorized invocation of mystical services.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> The Enchanted Analysis</h3>
<p>This file serves as the repository analyst‚Äîa master spellcraft unit that validates paths, extracts scrolls, and invokes the Repomix subprocess for content creation. It ensures the Codex remains functional while safeguarding against malicious scroll tampering.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext</code>: Core function that drives repository analysis, validating inputs and generating enchanted outputs while caching results.</li>
<li><code class="inline-code">captureRepomixStdout</code>: Executes the subprocess, capturing its mystical outputs while enforcing timeouts and memory constraints for safe handling.</li>
<li><code class="inline-code">validateProjectPath</code>: Ensures the sanctity of the repository path, rejecting unsafe or empty strings that could compromise the Codex&#39;s integrity.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  const configuredFiles = extractUniqueFilePaths(projectPath);
  if (configuredFiles.length &gt; 0) {
    try {
      return await this.generateOptimizedContent(projectPath, configuredFiles);
    } catch (error) {
      console.warn(`Failed to generate optimized content, falling back to targeted content: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    const cliOptions: CliOptions = {
      style: options.style || &#39;markdown&#39;,
      stdout: true,
      compress: options.compress !== false,
      ignore: [&#39;node_modules&#39;, &#39;.git&#39;, &#39;dist&#39;].join(&#39;,&#39;)
    };

    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<ul>
<li>Caches outputs to reduce redundant spell invocation, preserving memory and time resources.</li>
<li>Employs fallback mechanisms to ensure uninterrupted analysis even when an error occurs.</li>
<li>Builds CLI options dynamically, tailoring the invocation based on the scrolls (files) included.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [...directories, &#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
    if (options.compress) args.push(&#39;--compress&#39;);

    const process = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] });
    let stdout = &#39;&#39;, stderr = &#39;&#39;;
    let isResolved = false;

    const timeout = setTimeout(() =&gt; {
      if (!isResolved) {
        process.kill(&#39;SIGTERM&#39;);
        reject(new Error(&#39;Process timeout exceeded&#39;));
      }
    }, REPOMIX_SUBPROCESS_TIMEOUT);

    process.stdout.on(&#39;data&#39;, (data) =&gt; stdout += data.toString());
    process.stderr.on(&#39;data&#39;, (data) =&gt; stderr += data.toString());
    process.on(&#39;close&#39;, (code) =&gt; {
      clearTimeout(timeout);
      if (code === 0) resolve(stdout);
      else reject(new Error(`Failure code ${code}: ${stderr}`));
    });
  });
}
</code></pre>
<ul>
<li>Captures output from subprocess for stable content generation.</li>
<li>Implements timeout safety measures to prevent resource exhaustion during invocation.</li>
<li>Consolidates error messages for debugging and safeguarding consistent spell results.</li>
</ul>
<hr>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39; || projectPath.trim() === &#39;&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (projectPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<ul>
<li>Enforces strict validation rules, ensuring the repository&#39;s magical paths are safe.</li>
<li>Prevents null bytes, empty strings, or unsafe characters from tainting the Codex&#39;s analysis.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Ensure environment variables (<code class="inline-code">LLM_BASE_URL</code>, <code class="inline-code">LLM_API_KEY</code>, etc.) are correctly configured to maintain seamless mystical invocations.</li>
<li>Familiarize yourself with caching techniques used in the <code class="inline-code">generateRepomixContext</code> function for optimized responses.  </li>
<li>Explore error handling patterns in <code class="inline-code">generateResponse</code>‚Äîthey reveal key tools to debug and safeguard LLM integrations.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries hidden within the Enchanted Repository.</p>
<p>With the Codex of Analysis deciphered and its knowledge now a shining jewel within your arsenal, noble seeker, your legend ascends to new heights‚Äîpress onward, for the stars themselves await your mastery! ‚≠ê‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>