<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Omen of Knowledge — The Secrets of Code Analysis - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'mythical' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Elder Codex: Chronicles of the Enchanted Repository</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Omen of Knowledge — The Secrets of Code Analysis</h1>
<hr>
<p>Having navigated ancient sigils and mystical enchantments in your prior adventures, you now stand before the Elder Codex once again, its glyphs trembling with an enigmatic energy. A new revelation has surfaced: deep within its bindings lie clues about decoding the very magic that powers the Codex itself. To understand these secrets, you must unravel the mystic art of code analysis — the foundation upon which the repository breathes and evolves. Armed with tools forged by the Order of Developers, your journey into the depths begins anew!</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Integration for Codebase Analysis</h3>
<p>The <code class="inline-code">repo-analyzer.ts</code> file is a central piece of the magical technology that enables the Elder Codex to reveal its secrets. Much like a master luminary studying glyphs with precision, the file contains the <code class="inline-code">RepoAnalyzer</code> class, which orchestrates the extraction and validation of mystical runes (i.e., code paths and contents). It employs safeguards like <code class="inline-code">validateProjectPath()</code> to ensure that even the most treacherous paths avoid leading the adventurer astray. Further, it manages the Codex&#39;s energy with caching mechanisms, using the <code class="inline-code">REPOMIX_CACHE_TTL</code> constant to preserve previous insights for swift reuse. Methods such as <code class="inline-code">generateRepomixContext()</code> channel the raw repository essence into digestible outputs while <code class="inline-code">generateTargetedContent()</code> ensures only the most vital fragments gain prominence during the analysis rituals. Through its intricate routines, this component protects the kingdom from chaos by transforming raw magical traces into actionable knowledge.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext()</code> converts expansive repository knowledge into structured formats for analysis and storytelling.</li>
<li><code class="inline-code">validateProjectPath()</code> ensures wanderers do not tamper with forbidden paths, securing the sanctity of the Codex.</li>
<li><code class="inline-code">generateTargetedContent()</code> extracts the essence of specific files for refined Codex insights.</li>
<li>Caching systems ensure the Codex&#39;s glyphs are reused efficiently based on need.</li>
<li>Strong subprocess safeguards prevent memory exhaustion during magical deciphering.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> The Mystic Oracle Interface</h3>
<p>The <code class="inline-code">llm-client.ts</code> file holds the bridge between the Elder Codex and the mystical Oracle entities — the language models that provide interpretative insight. It encapsulates the <code class="inline-code">LLMClient</code> class, which serves as the wielder of this bridge, adeptly managing ancient configuration spells such as <code class="inline-code">LLM_API_KEY</code> and <code class="inline-code">LLM_REQUEST_TIMEOUT</code>. The file detects the Oracle&#39;s magical origin, determining whether it resides in the Azure sanctum or OpenAI&#39;s ethereal nexus, via <code class="inline-code">isAzureOpenAI()</code>. The critical method <code class="inline-code">generateResponse()</code> channels runes and chants (prompts) into the Oracle to receive structured revelations (responses). This class also ensures no rune is wasted, with parameters like <code class="inline-code">maxTokens</code> guarding against excessive resource use, while safeguards protect against timeouts in case of prolonged divination attempts. Precision and versatility are key as it configures requests differently for various Oracle types, ensuring harmony between the Codex and the Oracle realms.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">isAzureOpenAI()</code> identifies the Oracle&#39;s source, configuring its operations appropriately.</li>
<li><code class="inline-code">generateResponse()</code> facilitates prompt-based Oracle divination for coded insights and prophecies.</li>
<li>Handles both Azure and OpenAI configurations seamlessly, ensuring adaptability for differing Oracle magic.</li>
<li>Employs timeout rituals to prevent prolonged mystical queries from draining kingdom resources.</li>
<li>Processes and validates results (including JSON structures) to ensure clarity and usability after divination.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<p>This function ensures no wanderer ventures down a path filled with traps or forbidden glyphs, thereby preserving the sanctity of exploratory efforts.</p>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  if (!targetFiles || targetFiles.length === 0) {
    throw new Error(&#39;Target files array cannot be empty&#39;);
  }
  
  const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
  if (safeFiles.length === 0) {
    throw new Error(&#39;No valid target files found after validation&#39;);
  }

  const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
  
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
}
</code></pre>
<p>This method filters and refines the magical residue of target files, extracting their focused essence for analysis and story generation.</p>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);
    
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    
    this.logTokenUsage(completion);
    
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}`);
  }
}
</code></pre>
<p>This method channels the adventurer&#39;s request into the Oracle&#39;s realm, acquiring and refining its mystical revelations for actionable use.</p>
<pre><code class="language-typescript">private isAzureOpenAI(): boolean {
  return LLM_BASE_URL.includes(&#39;.openai.azure.com&#39;) || LLM_BASE_URL.includes(&#39;cognitiveservices.azure.com&#39;);
}
</code></pre>
<p>This simple yet vital function determines which Oracle kingdom (Azure or OpenAI) governs the mystical lore provided at any given time.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Protect your journey by ensuring all input paths and queries are secured using validation functions like <code class="inline-code">validateProjectPath()</code>.</li>
<li>Familiarize yourself with Oracle configuration handling in <code class="inline-code">llm-client.ts</code>, as it adapts for different provider realms.</li>
<li>Experiment with targeted file extraction using <code class="inline-code">generateTargetedContent()</code> to focus the Codex&#39;s energy on specific areas of interest.</li>
</ul>
<hr>
<p>With the brilliance of a thousand guiding stars and the strength of ancient runes, you have unraveled the arcane secrets of code analysis in Quest 3, paving the path to mastery with valor and unyielding spirit — onward, champion, for the realms of wisdom await! ⭐⚡💎</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4: The Enchanted Script — Weaving ... →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>