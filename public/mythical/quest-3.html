<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Oracle of Mirrors - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Enchanted Repository</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Oracle of Mirrors</h1>
<hr>
<p>In the glasswork hall of the coded kingdom, you approach the Oracle of Mirrors, where reflections reveal the workings behind enchanted whispers. Here, servers gossip with wizards and analyzers scribe what the repositories truly say. The oracle bids you study the twin mirrors: <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a> and <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a>. Through these panes you shall witness spells of gathering lore and summoning counsel. Heed the runes <code class="inline-code">llm-client.ts</code> and <code class="inline-code">input-validator.ts</code> hinted earlier in your journey, for their echoes shape the visions you now behold. Seek patterns, trace flows, and learn the limits of magic.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Mirror Alignment: How does <code class="inline-code">generateTargetedContent</code> constrain and normalize file paths before invoking <code class="inline-code">repomix</code>, and what patterns ensure safe inclusion?</li>
<li>‚ö° Summoner‚Äôs Binding: In <code class="inline-code">LLMClient.constructor</code>, how does provider detection influence client setup, and when does the path split logic for Azure endpoints take effect?</li>
<li>üõ°Ô∏è Ward of Time: Where do <code class="inline-code">LLM_REQUEST_TIMEOUT</code> and timeout guards surface in <code class="inline-code">LLMClient</code> and <code class="inline-code">RepoAnalyzer</code>, and how do they enforce graceful failure when calls exceed limits?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> The Scribe‚Äôs Lens over the Repository</h3>
<p>This scroll crafts controlled visions of your project using Repomix. The <code class="inline-code">RepoAnalyzer</code> maintains a cache of conjured contexts, validates paths, and summons repomix as a subprocess. Begin with <code class="inline-code">validateProjectPath</code>, a simple but crucial ward that rejects empty strings and null bytes, ensuring the scribe never reads from cursed paths. Next, <code class="inline-code">generateTargetedContent</code> is the careful ritual that filters and normalizes a set of target files. It uses an inner talisman <code class="inline-code">validateAndNormalizeTargetFiles</code> to deduplicate, reject traversal hints like <code class="inline-code">..</code>, enforce project-root containment, verify existence, and produce stable cache keys. With this purified list, it constructs strict CLI options, captures stdout through <code class="inline-code">captureRepomixStdout</code>, and caches results. The capture spell sets memory and time wards using <code class="inline-code">REPOMIX_MAX_BUFFER_SIZE</code>, <code class="inline-code">REPOMIX_SUBPROCESS_TIMEOUT</code>, and <code class="inline-code">REPOMIX_GRACEFUL_TIMEOUT</code>. Errors are wrapped with clear causes. Finally, <code class="inline-code">generateRepomixContext</code> provides an adaptive path: if <code class="inline-code">adventure.config.json</code> yields configured files, it favors optimized or targeted routes, else falls back to a compressed full sweep. Together, these functions illustrate a thoughtful balance of safety, performance, and deterministic outputs, so the oracle‚Äôs mirror reflects only what is intended, within limits that protect the kingdom‚Äôs resources.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext</code> orchestrates adaptive analysis, preferring configured and optimized views while enforcing caching and ignores to protect resources.</li>
<li><code class="inline-code">generateTargetedContent</code> validates and limits the scope of files, builds precise <code class="inline-code">repomix</code> options, and caches the targeted result for repeated visions.</li>
<li><code class="inline-code">captureRepomixStdout</code> summons <code class="inline-code">repomix</code> with subprocess guards, applying timeout, graceful kill, and buffer limits to keep the spell safe.</li>
<li><code class="inline-code">validateProjectPath</code> is a minimal but essential path ward preventing null-byte and empty path misuse.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  // Check if adventure.config.json has specific files to include
  const configuredFiles = extractUniqueFilePaths(projectPath);
  
  if (configuredFiles.length &gt; 0) {
    // Use configured files with optimized content generation
    console.log(`Using adventure.config.json: analyzing ${configuredFiles.length} configured files with optimization`);
    try {
      return await this.generateOptimizedContent(projectPath, configuredFiles);
    } catch (error) {
      console.warn(`Failed to generate optimized content, falling back to targeted content: ${error instanceof Error ? error.message : String(error)}`);
      try {
        return await this.generateTargetedContent(projectPath, configuredFiles);
      } catch (fallbackError) {
        console.warn(`Failed to generate targeted content, falling back to full repomix content: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`);
        // Fall through to full content generation
      }
    }
  }
  
  // Fallback: use existing behavior with all files (compressed)
  console.log(&#39;No adventure.config.json found: analyzing full codebase (compressed)&#39;);
  
  // Create cache key from path and options
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  
  // Check cache first
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
  
  
  try {
    // Build ignore patterns
    const ignorePatterns = [
      &#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;, &#39;coverage&#39;, &#39;.nyc_output&#39;
    ];
    
    if (!options.includeTests) {
      ignorePatterns.push(&#39;**/*.test.ts&#39;, &#39;**/*.spec.ts&#39;, &#39;**/tests/**&#39;, &#39;**/test/**&#39;);
    }

    // Configure repomix options
    const cliOptions: CliOptions = {
      style: options.style || &#39;markdown&#39;,
      stdout: true,
      compress: options.compress !== false, // Default to true unless explicitly disabled
      ignore: ignorePatterns.join(&#39;,&#39;),
      removeComments: true,
      removeEmptyLines: true,
      noDirectoryStructure: true
    };

    // Capture stdout during repomix execution
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    
    // Cache the result
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<ul>
<li>Orchestrates the end-to-end flow for context generation with graceful fallbacks.</li>
<li>Uses <code class="inline-code">extractUniqueFilePaths</code> to honor configured focus, promoting deterministic output.</li>
<li>Applies caching via <code class="inline-code">REPOMIX_CACHE_TTL</code> to reduce redundant invocations.</li>
<li>Sets ignore patterns to exclude bulky or noisy domains for efficiency.</li>
<li>Delegates actual execution to <code class="inline-code">captureRepomixStdout</code>, cleanly separating concerns.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  if (!targetFiles || targetFiles.length === 0) {
    throw new Error(&#39;Target files array cannot be empty&#39;);
  }
  
  // Harden and validate target files
  const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
  if (safeFiles.length === 0) {
    throw new Error(&#39;No valid target files found after validation&#39;);
  }
  
  // Create stable cache key from normalized files
  const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
  
  // Check cache first
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
  
  
  try {
    // Configure repomix options for targeted extraction
    const cliOptions: CliOptions = {
      style: &#39;markdown&#39;,
      stdout: true,
      compress: compress, // Configurable compression
      include: safeFiles.join(&#39;,&#39;), // Only include validated files
      removeComments: compress, // Remove comments if compressing
      removeEmptyLines: compress, // Remove empty lines if compressing
      noDirectoryStructure: true
    };

    // Capture stdout during repomix execution
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    
    // Cache the result
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    
    return context;
  } catch (error) {
    throw new Error(`Targeted repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<ul>
<li>Validates project and files up front to avoid unsafe inclusion and traversal.</li>
<li>Normalizes and deduplicates filenames, ensuring stable caching keys and reliable runs.</li>
<li>Encodes scope via <code class="inline-code">include</code> rather than broad scans, conserving tokens and time.</li>
<li>Parameterizes compression to control verbosity of the captured content.</li>
<li>Centralizes execution through <code class="inline-code">captureRepomixStdout</code>, retaining consistent error handling.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    // Build repomix CLI arguments
    const args = [
      ...directories,
      &#39;--stdout&#39;,
      &#39;--style&#39;, options.style || &#39;markdown&#39;
    ];
    
    if (options.compress) args.push(&#39;--compress&#39;);
    if (options.removeComments) args.push(&#39;--remove-comments&#39;);
    if (options.removeEmptyLines) args.push(&#39;--remove-empty-lines&#39;);
    if (options.noDirectoryStructure) args.push(&#39;--no-directory-structure&#39;);
    if (options.ignore) args.push(&#39;--ignore&#39;, options.ignore);
    if (options.include) args.push(&#39;--include&#39;, options.include);
    
    // Spawn repomix as subprocess
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], {
      cwd,
      stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]
    });
    
    let stdout = &#39;&#39;;
    let stderr = &#39;&#39;;
    let stdoutSize = 0;
    let isResolved = false;
    
    // Set up timeout with graceful then force kill
    const timeout = setTimeout(() =&gt; {
      if (!isResolved) {
        console.warn(`Repomix subprocess timeout (${REPOMIX_SUBPROCESS_TIMEOUT}ms), killing process...`);
        repomix.kill(&#39;SIGTERM&#39;);
        setTimeout(() =&gt; repomix.kill(&#39;SIGKILL&#39;), REPOMIX_GRACEFUL_TIMEOUT);
        isResolved = true;
        reject(new Error(`Repomix subprocess timed out after ${REPOMIX_SUBPROCESS_TIMEOUT}ms (${cwd})`));
      }
    }, REPOMIX_SUBPROCESS_TIMEOUT);
    
    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      const chunk = data.toString();
      stdoutSize += chunk.length;
      
      // Memory protection
      if (stdoutSize &gt; REPOMIX_MAX_BUFFER_SIZE) {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeout);
          repomix.kill(&#39;SIGKILL&#39;);
          reject(new Error(`Repomix output too large (${stdoutSize} bytes) for ${cwd}`));
        }
        return;
      }
      
      stdout += chunk;
    });
    
    repomix.stderr.on(&#39;data&#39;, (data) =&gt; {
      stderr += data.toString();
    });
    
    repomix.on(&#39;close&#39;, (code) =&gt; {
      if (!isResolved) {
        isResolved = true;
        clearTimeout(timeout);
        
        if (code === 0 &amp;&amp; stdout.trim().length &gt; 0) {
          resolve(stdout);
        } else {
          reject(new Error(`Repomix failed (exit ${code}): ${stderr.substring(0, 200)}`));
        }
      }
    });
    
    repomix.on(&#39;error&#39;, (error) =&gt; {
      if (!isResolved) {
        isResolved = true;
        clearTimeout(timeout);
        reject(new Error(`Repomix spawn failed: ${error.message}`));
      }
    });
  });
}
</code></pre>
<ul>
<li>Enforces strict time and memory wards to prevent runaway processes.</li>
<li>Applies a graceful shutdown before escalation, protecting system stability.</li>
<li>Truncates error surfaces for clarity while preserving root cause.</li>
<li>Supports flexible CLI argument composition driven by caller options.</li>
<li>Returns only when output is valid and non-empty, preventing silent failures.</li>
</ul>
<hr>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  
  // Determine API key based on provider
  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key (LLM_API_KEY or GITHUB_TOKEN).&#39;);
  }

  if (this.isAzureOpenAI()) {
    // Azure OpenAI requires endpoint without the path
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({
      endpoint: azureEndpoint,
      apiKey,
      apiVersion: LLM_API_VERSION,
      deployment: this.model
    });
  } else {
    this.client = new OpenAI({
      apiKey,
      baseURL: LLM_BASE_URL
    });
  }
}
</code></pre>
<ul>
<li>Selects provider instance based on endpoint inspection, splitting Azure endpoints to required base form.</li>
<li>Validates presence of both base URL and key, failing early with a clear message.</li>
<li>Uses <code class="inline-code">LLM_MODEL</code> consistently as deployment for Azure, aligning with service expectations.</li>
<li>Centralizes client construction, keeping downstream calls provider-agnostic.</li>
<li>Encourages deterministic configuration via environment-driven constants.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  // GitHub Models (hosted on Azure) uses GITHUB_TOKEN
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for GitHub Models. Set GITHUB_TOKEN environment variable.&#39;);
    }
    return GITHUB_TOKEN;
  }
  // All other providers (OpenAI, Azure OpenAI, Ollama, etc.) use LLM_API_KEY
  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li>Differentiates API credential selection based on host pattern, avoiding misconfiguration.</li>
<li>Provides targeted error messages to guide correct environment setup.</li>
<li>Supports both GitHub-hosted Azure models and other providers with a single method.</li>
<li>Keeps provider branching lightweight and readable.</li>
<li>Ensures that downstream construction always receives a valid key.</li>
</ul>
<hr>
<pre><code class="language-typescript">private isAzureOpenAI(): boolean {
  return LLM_BASE_URL.includes(&#39;.openai.azure.com&#39;) || LLM_BASE_URL.includes(&#39;cognitiveservices.azure.com&#39;);
}
</code></pre>
<ul>
<li>Implements a concise detection charm based on domain fragments.</li>
<li>Shields the constructor from repeated string checks.</li>
<li>Aligns with Azure endpoint conventions without complex parsing.</li>
<li>Facilitates clear control flow between Azure and non-Azure paths.</li>
<li>Simple, fast, and sufficient for environment-driven routing.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);
    
    // Post-process JSON responses that might be wrapped in markdown
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    
    this.logTokenUsage(completion);
    
    return { content };
  } catch (error) {
    // Enhanced error logging for debugging
    this.logDetailedError(error, prompt);
    
    const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
    throw new Error(`LLM request failed: ${message}`);
  }
}
</code></pre>
<ul>
<li>Encapsulates the full summon cycle: build, execute with timeout, validate, post-process, and log usage.</li>
<li>Handles JSON formatting quirks by stripping code fences for clean parsing.</li>
<li>Uses comprehensive logging on failure to aid diagnosis without leaking control flow.</li>
<li>Wraps error messaging to present a single, clear exception surface.</li>
<li>Ties into <code class="inline-code">executeRequest</code> where <code class="inline-code">LLM_REQUEST_TIMEOUT</code> governs latency boundaries.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Trace how cache keys are composed to predict when results will be reused.</li>
<li>Compare targeted vs. full analysis flows to see how scope and ignores alter performance.</li>
<li>Review timeout constants to tune reliability when mirrors grow large or the summoner lingers.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hail, valiant hero‚Äîby deciphering the Oracle of Mirrors you have wrested truth from the veils of fate, claiming Quest 3 and shining like a star-forged champion at 2 of 4 quests (50%) complete, your legend ascending with thunderous valor toward the next triumph! ‚≠ê‚ö°üöÄ</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>