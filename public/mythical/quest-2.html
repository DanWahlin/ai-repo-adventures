<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: The Forge of Living Tales - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Enchanted Repository</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: The Forge of Living Tales</h1>
<hr>
<p>From the bustling square of parsing scribes, you stride into the Forge of Living Tales, where molten logic glows beneath anvils of patterns. Smith-wizards temper scrolls into quests while bellows of <code class="inline-code">LLMClient</code> feed mystic flame. Here, <code class="inline-code">AdventureManager</code> binds choices to fate, and <code class="inline-code">adventure-config.ts</code> inscribes runes that guide hammer and spark. With each validated step, your coder-knight discipline shapes story-steel. Listen for the ring of functions, for in these strikes the saga is forged, and the kingdom‚Äôs legend takes form in executable verse.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Rune Alignment: How does <code class="inline-code">AdventureManager.initializeAdventure</code> weave theme, project context, and config guidance to shape the final quest list shown to travelers?</li>
<li>‚ö° Ember Flow: When a seeker chooses a path, how does <code class="inline-code">AdventureManager.exploreQuest</code> route intention through validation, lookup, and content generation, including caching on revisits?</li>
<li>üõ°Ô∏è Tempered Safety: In <code class="inline-code">parseAdventureConfig</code>, what safeguards ensure malformed scrolls do not shatter the forge, and how do <code class="inline-code">extractUniqueFilePaths</code> and <code class="inline-code">formatAdventureConfigForPrompt</code> prevent unsafe or noisy fuel from entering the fire?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> The master smith coordinating story steel and quest ingots</h3>
<p>Within this hall, <code class="inline-code">AdventureManager</code> conducts the ritual: it resets the anvil via <code class="inline-code">AdventureState</code>, sets theme alloy, and invites <code class="inline-code">StoryGenerator</code> to pour initial narrative ore. The function <code class="inline-code">initializeAdventure</code> primes the forge with <code class="inline-code">projectInfo</code>, theme, and optionally custom alloys, then tempers the LLM-crafted quests with local runes using <code class="inline-code">mergeQuestFilesFromConfig</code> and <code class="inline-code">enforceConfigQuestCount</code>. This ensures the final ingots match the blacksmith‚Äôs ledger in <code class="inline-code">adventure.config.json</code>. When a traveler declares a choice, <code class="inline-code">exploreQuest</code> first runs <code class="inline-code">validateAdventureChoice</code> as gate wards, then distinguishes progress invocations from real expeditions. It locates the requested quest by number or cleansed title, and passes it into the crucible <code class="inline-code">executeQuest</code>, which uses <code class="inline-code">repoAnalyzer.generateTargetedContent</code> when paths are specified, falling back to full repomix ore if necessary. The smith caches finished ingots so revisits return polished artifacts instantly, and records completion to update journey progress. Throughout, the forge respects theme metal, project path, and contextual constraints so that every strike lands true and consistent. Notice how completion summaries, quest choices, and progress parchment are all shaped by state, ensuring the tale and its steel remain synchronized across the saga.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code> orchestrates theme and project context, generates quests, merges config file paths, enforces quest counts, and formats the story listing for seekers.</li>
<li><code class="inline-code">exploreQuest</code> validates traveler intent, detects progress views, resolves a quest by number or title, and invokes execution with caching and summaries.</li>
<li><code class="inline-code">mergeQuestFilesFromConfig</code> binds config-defined file lists to generated quests using index-first matching and a fallback title-match to ensure targeted content.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  // Reset state for new adventure
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  
  // Set custom theme data if provided
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  // Generate the overall story and quests using LLM
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  
  this.state.title = storyResponse.title;
  this.state.story = storyResponse.story;
  
  // Merge files from adventure config into the generated quests
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  
  // Enforce quest count from adventure.config.json if it exists
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  // Return the story with available quests
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<ul>
<li>Establishes the forge: resets state, sets theme and project path, and optionally infuses custom alloy via <code class="inline-code">setCustomTheme</code>.</li>
<li>Invokes <code class="inline-code">StoryGenerator.generateStoryAndQuests</code> to pour the initial narrative ingots.</li>
<li>Tempering step: integrates quest file targets from <code class="inline-code">adventure.config.json</code> and trims quest count to match config.</li>
<li>Returns a polished story scroll created by <code class="inline-code">formatStoryWithQuests</code>, ensuring seekers see the canonical quest slate.</li>
<li>Key pattern: staged orchestration followed by config-informed reconciliation.</li>
</ul>
<hr>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);
  
  // Check if this is a progress request
  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }
  
  // Find the quest based on the choice
  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }

  // Execute the quest
  return await this.executeQuest(quest);
}
</code></pre>
<ul>
<li>Guards the gate with <code class="inline-code">validateAdventureChoice</code>, then divines whether the seeker requests progress or a real expedition.</li>
<li>Resolves quests through number, id, or cleansed-title matching before proceeding.</li>
<li>Delegates to <code class="inline-code">executeQuest</code>, where content generation, caching, and summaries occur.</li>
<li>Design decision: centralized routing keeps selection logic clear and safe.</li>
<li>Connects to <code class="inline-code">getAvailableQuestChoices</code> and state tracking for coherent user flow.</li>
</ul>
<hr>
<pre><code class="language-typescript">private mergeQuestFilesFromConfig(quests: Quest[], projectPath: string | undefined): Quest[] {
  if (!projectPath) return quests;
  
  const config = parseAdventureConfig(projectPath);
  if (!config || typeof config !== &#39;object&#39;) return quests;
  
  const adventure = (config as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) return quests;
  
  // Create a map of quest titles to their file paths from the config
  const configQuestFiles = new Map&lt;string, string[]&gt;();
  for (const configQuest of adventure.quests) {
    if (configQuest.title &amp;&amp; Array.isArray(configQuest.files)) {
      const filePaths = configQuest.files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (filePaths.length &gt; 0) {
        configQuestFiles.set(configQuest.title.toLowerCase(), filePaths);
      }
    }
  }
  
  // Merge the files into the generated quests
  return quests.map((quest, index) =&gt; {
    // Primary matching: by quest order (index)
    const configQuests = adventure.quests;
    if (index &lt; configQuests.length &amp;&amp; configQuests[index] &amp;&amp; configQuests[index].files) {
      const files = configQuests[index].files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (files.length &gt; 0) {
        // Successfully matched files from config
        return { ...quest, codeFiles: files };
      }
    }
    
    // Fallback: try to match quest by title (case-insensitive partial match)
    const questTitleLower = quest.title.toLowerCase();
    for (const [configTitle, files] of configQuestFiles.entries()) {
      if (questTitleLower.includes(configTitle) || configTitle.includes(questTitleLower)) {
        // Successfully matched files via fallback
        return { ...quest, codeFiles: files };
      }
    }
    
    // No specific files found - quest will use general context
    return quest;
  });
}
</code></pre>
<ul>
<li>Reads config via <code class="inline-code">parseAdventureConfig</code> and prepares a title-to-files ledger.</li>
<li>Primary binding by index ensures deterministic matching when lineups are aligned.</li>
<li>Fallback binding by partial, case-insensitive title prevents drift from breaking targeting.</li>
<li>Outcome: each quest carries <code class="inline-code">codeFiles</code> to enable focused <code class="inline-code">repoAnalyzer.generateTargetedContent</code>.</li>
<li>Important detail: gracefully returns original quests when config is absent or malformed.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> The codex of forging runes that guide targeted strikes</h3>
<p>This codex governs how the forge interprets local scrolls. <code class="inline-code">parseAdventureConfig</code> performs cautious parsing: it reads raw text with <code class="inline-code">loadAdventureConfig</code>, attempts <code class="inline-code">JSON.parse</code>, and returns null on failure so the anvil never cracks under bad ink. <code class="inline-code">extractUniqueFilePaths</code> is a careful miner, walking the entire structure to gather <code class="inline-code">path</code> fields into a deduplicated set, verifying file existence with <code class="inline-code">fs.existsSync</code> against <code class="inline-code">projectPath</code>. This prevents the bellows from pulling phantom ash into the fire. Finally, <code class="inline-code">formatAdventureConfigForPrompt</code> crafts a lean incantation for the LLM: it prints quest headings, the file list, and function names only, omitting verbose tales since the molten core is the code itself. These functions together ensure the smith‚Äôs instructions are legible, safe, and minimal, allowing the <code class="inline-code">StoryGenerator</code> and <code class="inline-code">AdventureManager</code> to work with precise, trustworthy inputs. Observe how each step de-risks IO and parsing, and how formatting focuses the model on relevant structure without noisy adornments.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> safely parses the quest codex, returning null on errors to keep the forge resilient.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> traverses the codex, collects valid <code class="inline-code">path</code> entries, and confirms their existence to avoid illusory files.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> emits a concise, signal-rich outline of quests, files, and functions to guide LLM-smithing.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Centralizes JSON parsing and shields the system from malformed parchment by returning null.</li>
<li>Ensures downstream consumers like <code class="inline-code">AdventureManager</code> use defensive checks (<code class="inline-code">!config || typeof config !== &#39;object&#39;</code>).</li>
<li>Avoids throwing in IO-heavy paths to keep the forge‚Äôs workflow smooth.</li>
<li>Pattern: tolerant parsing with null signaling rather than exceptions.</li>
<li>Connects directly to higher-level merging and formatting logic.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Depth-first traversal gathers all <code class="inline-code">path</code> runes across nested structures.</li>
<li>Validates existence using <code class="inline-code">fs.existsSync</code> to prevent broken targeting in quest content generation.</li>
<li>Uses a <code class="inline-code">Set</code> to remove duplicates, ensuring a clean bellows input.</li>
<li>Robust to non-object nodes via defensive guards.</li>
<li>Supports targeted analysis paths used by <code class="inline-code">AdventureManager</code>.</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Produces a minimal, high-signal outline for prompts to the LLM-smith.</li>
<li>Intentionally omits verbose descriptions to reduce token ash and keep heat on structure.</li>
<li>Aligns with <code class="inline-code">StoryGenerator</code> usage that pulls this outline as guidance during quest content forging.</li>
<li>Benefits: reduced token cost, clearer intent, better controllability of outputs.</li>
<li>Readers should note its tight coupling with <code class="inline-code">StoryGenerator</code> prompt construction.</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>When matching config files to quests, study the index-first approach before the title fallback to predict which files bind where.</li>
<li>Trace a single quest from <code class="inline-code">initializeAdventure</code> through <code class="inline-code">mergeQuestFilesFromConfig</code> into <code class="inline-code">executeQuest</code> to see how targeted content generation is enabled.</li>
<li>If your codex is missing or malformed, ensure your flows gracefully continue using general context rather than halting the forge.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Hail, valiant hero‚Äîby conquering Quest 2: The Forge of Living Tales, you have tempered your craft in dragonfire and etched your name in the kingdom‚Äôs codex, advancing a quarter of the grand saga (25%) toward legend‚Äîpress on with courage, for brighter stars await your banner! ‚≠ê‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-1.html" class="prev-quest-btn">‚Üê Previous: Quest 1</a>
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>