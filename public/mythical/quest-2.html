<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: Quest Generation Engine - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Enchanted Repository</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: Quest Generation Engine</h1>
<hr>
<p>In the citadel of scripts, you stride as a quest-smith, binding runes to repositories with the quills <code class="inline-code">StoryGenerator</code> and <code class="inline-code">AdventureManager</code>. Enchanted parchments whisper of <code class="inline-code">adventure-config.json</code>, and the <code class="inline-code">repoAnalyzer</code> calls from cavernous archives. Under the watch of time sigils, the <code class="inline-code">LLMClient</code> invokes oracles to shape sagas that suit the mystic theme scrolls. Through this chapter, decode how tales are forged: how quests are summoned, merged with scroll guidance, and returned to heroes as shining paths. Ready your mind, knight of code, and read the spells themselves.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Mystic Mapping: How does <code class="inline-code">AdventureManager.initializeAdventure</code> weave together LLM-spun quests with <code class="inline-code">adventure.config.json</code> files, and in what order are merges and truncations performed?</li>
<li>‚ö° Oracle Channeling: In <code class="inline-code">StoryGenerator.generateStoryAndQuests</code>, how are prompts assembled and validated, and where is the final story content stored for reuse during quest generation?</li>
<li>üõ°Ô∏è Ward of Guidance: How does <code class="inline-code">formatAdventureConfigForPrompt</code> reduce config verbosity, and how does <code class="inline-code">StoryGenerator</code> incorporate this trimmed guidance into LLM prompts?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Quest orchestration and merging with guidance</h3>
<p>Within this hall, <code class="inline-code">AdventureManager</code> governs the journey from initialization to exploration. The ritual begins in <code class="inline-code">initializeAdventure</code>, where the <code class="inline-code">AdventureState</code> is reset and the <code class="inline-code">StoryGenerator</code> is invoked to craft a narrative and quests. Once the oracles respond, the manager merges scroll-specified files into quests via <code class="inline-code">mergeQuestFilesFromConfig</code>, then enforces count alignment with <code class="inline-code">enforceConfigQuestCount</code>. This ordering means config-guided files are attached first, and only afterward are excess quests trimmed to match the scroll‚Äôs decree. When a hero selects a path, <code class="inline-code">exploreQuest</code> sanitizes the choice using <code class="inline-code">validateAdventureChoice</code>, resolves the intended quest by number, id, or title, and handles special ‚Äúprogress‚Äù invocations through <code class="inline-code">isProgressRequest</code>. Upon execution, <code class="inline-code">executeQuest</code> either retrieves cached quest content or conjures fresh content using <code class="inline-code">repoAnalyzer.generateTargetedContent</code> when specific files are set, falling back to full <code class="inline-code">repomixContent</code> if needed. Summaries are then forged by <code class="inline-code">StoryGenerator.generateCompletionSummary</code>, and progress blooms through <code class="inline-code">progressPercentage</code>. Note the careful prerequisite wards in <code class="inline-code">validateQuestPrerequisites</code> that ensure a theme and project context exist before any deep magic is attempted. Finally, formatted outputs are returned using <code class="inline-code">formatStoryWithQuests</code> and <code class="inline-code">formatQuestResult</code>, while <code class="inline-code">getAvailableQuestChoices</code> signs each completed quest with a checkmark for noble clarity.</p>
<h4>Highlights</h4>
<ul>
<li>Initialization pipeline: reset state, LLM generation, config merge, quest count enforcement</li>
<li>Exploration flow: choice validation, progress checks, quest lookup by number/id/title</li>
<li>Execution path: cache reuse vs targeted repo analysis, summary generation, progress updates</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  // Reset state for new adventure
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  
  // Set custom theme data if provided
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }

  // Generate the overall story and quests using LLM
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  
  this.state.title = storyResponse.title;
  this.state.story = typeof storyResponse.story === &#39;string&#39; ? storyResponse.story : storyResponse.story.content;
  
  // Merge files from adventure config into the generated quests
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  
  // Enforce quest count from adventure.config.json if it exists
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);

  // Return the story with available quests
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<p>Like a royal herald assembling banners, it first gathers all quests, adorns them with config-bound files, then trims to match the scroll‚Äôs final decree.</p>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);
  
  // Check if this is a progress request
  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }
  
  // Find the quest based on the choice
  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }

  // Execute the quest
  return await this.executeQuest(quest);
}
</code></pre>
<p>As a gatewarden, it cleans the traveler‚Äôs request, reveals progress on command, or guides them to the right chamber of challenges.</p>
<pre><code class="language-typescript">get progressPercentage(): number {
  return this.quests.length &gt; 0 
    ? Math.round((this.completedQuests.size / this.quests.length) * 100)
    : 0;
}
</code></pre>
<p>A simple abacus of triumphs, tallying completed banners against all quests to show the realm‚Äôs advance.</p>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
  this.currentProject = projectInfo;
  this.projectPath = projectPath;
  
  const validatedTheme = this.validateTheme(theme);
  return await this.generateWithLLM(projectInfo, validatedTheme);
}
</code></pre>
<p>Like a court mage, it records the realm and path, blesses the theme, and invokes the grand summoning.</p>
<pre><code class="language-typescript">private async generateWithLLM(projectInfo: ProjectInfo, theme: AdventureTheme): Promise&lt;StoryResponse&gt; {
  const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
  
  // Use formatted adventure config instead of raw JSON
  let adventureGuidance = &#39;&#39;;
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
  }

  const prompt = loadStoryGenerationPrompt({
    theme,
    repomixContent,
    ...(adventureGuidance &amp;&amp; { adventureGuidance }),
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  });

  const response = await this.withTimeout(
    this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY })
  );
  
  if (!response.content || response.content.trim() === &#39;&#39;) {
    throw new Error(&#39;LLM returned empty response&#39;);
  }
  
  let parsed;
  try {
    // Preprocess response to remove markdown code block wrapper if present
    let cleanContent = response.content.trim();
    if (cleanContent.startsWith(&#39;```markdown&#39;)) {
      cleanContent = cleanContent.replace(/^```markdown\s*/, &#39;&#39;).replace(/\s*```$/, &#39;&#39;);
    }
    
    parsed = parseMarkdownToStoryResponse(cleanContent);
    // Validate with Zod schema for safety
    StoryResponseSchema.parse(parsed);
    
    // Store the story content for consistency in quest generation
    this.currentStoryContent = typeof parsed.story === &#39;string&#39; ? parsed.story : parsed.story.content;
  } catch (error) {
    console.error(&#39;üí• Parsing error:&#39;, error instanceof Error ? error.message : &#39;Unknown error&#39;);
    console.error(&#39;üí• Full response:&#39;, response.content);
    throw new Error(`Invalid LLM response for story: ${error instanceof Error ? error.message : &#39;Unknown error&#39;}. Response: ${response.content.substring(0, 200)}...`);
  }
  return parsed;
}
</code></pre>
<p>The mage composes a prompt, consults the oracle, cleans the prophecy, validates its structure, and preserves the tale for later rites.</p>
<pre><code class="language-typescript">async generateQuestContent(
  quest: Quest,
  theme: AdventureTheme,
  codeContent: string
): Promise&lt;QuestContent&gt; {
  // Include formatted adventure config as context if available
  let adventureGuidance = &#39;&#39;;
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
  }

  const prompt = loadQuestContentPrompt({
    theme,
    adventureTitle: quest.title,
    codeContent,
    storyContent: this.currentStoryContent || &#39;No story context available.&#39;,
    adventureGuidance: adventureGuidance || &#39;&#39;,
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  }) + &#39;\n\nIMPORTANT: Respond with ONLY markdown content between explicit delimiters.\n\nFormat your response EXACTLY like this:\n\n---BEGIN MARKDOWN---\n[Your markdown content here starting with the quest title]\n

By the decree of the ancient runes, your valiant completion of Quest 2: Quest Generation Engine forges a gleaming milestone upon the royal codex‚Äî1 of 5 quests conquered (20% complete)‚Äîa triumph worthy of heroes, with the forge-fires of mastery blazing brighter as you march onward under guiding stars ‚≠ê toward the next legendary chapter!
</code></pre>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-1.html" class="prev-quest-btn">‚Üê Previous: Quest 1</a>
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>