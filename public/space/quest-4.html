<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 4: Code Analysis & Content Pipeline - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-space">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">Galactic Code Chronicles: Missions Beyond the Repository</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 4: Code Analysis &amp; Content Pipeline</h1>
<hr>
<p>Aboard the <em>Celestial Refactor</em>, your mission intensifies as your crew dives into the enigmatic structure of the ship&#39;s content generation core. The luminous nebula of the interstellar codebase hums with cryptic algorithms, and it&#39;s up to you to decipher the way these systems analyze galactic data and transform it into navigational insights. The <em>Repo Analyzer</em> and <em>LLM Client</em> form the heart of this pipeline, synthesizing vast cosmic knowledge to guide your automated explorers. Will you unlock their secrets and enhance their interstellar reach?</p>
<p><strong>Adventure Awaits ‚Äì Operational success hinges on unlocking these mysteries!</strong></p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Decoder&#39;s Insight</strong>: How does the <code class="inline-code">RepoAnalyzer.generateRepomixContext</code> ensure safe and optimized content extraction from the galactic file system?</li>
<li>‚ö° <strong>Signal Relay Mechanics</strong>: What logic powers the <code class="inline-code">LLMClient.generateResponse</code>, and how does it adapt to different AI models and parameters?</li>
<li>üõ°Ô∏è <strong>Safety Nets in the Void</strong>: How does error handling in both <code class="inline-code">RepoAnalyzer</code> and <code class="inline-code">LLMClient</code> prevent system breakdowns and ensure adaptive recovery?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Orchestrating Galactic Data Streams</h3>
<p>The <code class="inline-code">RepoAnalyzer</code> file governs the extraction and optimization of repository contents. It ensures that data from the starship‚Äôs galactic archives is validated, secured, and compressed for efficient use. Key methods cover path validation, cache management, and targeted content generation, ensuring that only relevant files are utilized while respecting memory constraints.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext</code>: Coordinates analysis of the codebase using configurable options, applying cache systems and fallback mechanisms for adaptability.</li>
<li><code class="inline-code">generateTargetedContent</code>: Extracts specific files based on input criteria, enforcing secure file handling to mitigate cosmic anomalies (e.g., unsafe paths).</li>
<li><code class="inline-code">captureRepomixStdout</code>: Launches and monitors a subprocess to capture the output of the repomix tool while managing resource constraints.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
    
  // Check if adventure.config.json has specific files to include
  const configuredFiles = extractUniqueFilePaths(projectPath);
    
  if (configuredFiles.length &gt; 0) {
    console.log(`Using adventure.config.json: analyzing ${configuredFiles.length} configured files with optimization`);
    try {
      return await this.generateOptimizedContent(projectPath, configuredFiles);
    } catch (error) {
      console.warn(`Failed to generate optimized content, falling back to targeted content`);
      try {
        return await this.generateTargetedContent(projectPath, configuredFiles);
      } catch (fallbackError) {
        console.warn(`Failed to generate targeted content, falling back to full repomix content`);
      }
    }
  }
    
  console.log(&#39;No adventure.config.json found: analyzing full codebase (compressed)&#39;);
    
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    const cliOptions = {
      style: options.style || &#39;markdown&#39;,
      stdout: true,
      compress: options.compress !== false,
      ignore: [&#39;node_modules&#39;, &#39;dist&#39;]
    };

    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Decipher galactic repository configurations to determine optimal extraction paths.</li>
<li><strong>Patterns</strong>: Caching ensures repeated queries don‚Äôt strain system resources.</li>
<li><strong>Fallbacks</strong>: Tries multiple content-generation strategies in case of errors.</li>
<li><strong>Validation</strong>: Prevents misuse of paths and ensures only relevant files are processed.</li>
</ul>
<hr>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
    
  const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
  if (safeFiles.length === 0) {
    throw new Error(&#39;No valid target files found after validation&#39;);
  }
    
  const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
  const cached = this.cache.get(cacheKey);
  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    const cliOptions = {
      style: &#39;markdown&#39;,
      stdout: true,
      compress,
      include: safeFiles.join(&#39;,&#39;)
    };

    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Targeted repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Harnesses targeted precision to analyze only pre-specified files.</li>
<li><strong>Techniques</strong>: Normalization and deduplication of paths ensure input security.</li>
<li><strong>Error Handling</strong>: Catches subprocess failures to maintain system integrity.</li>
<li><strong>Caching</strong>: Avoids redundant subprocess calls by storing results.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [&#39;--stdout&#39;, &#39;--style&#39;, options.style];
    if (options.compress) args.push(&#39;--compress&#39;);
    const repomix = spawn(&#39;npx&#39;, [...args], { cwd });

    let stdout = &#39;&#39;;
    let stdoutSize = 0;
    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      const chunk = data.toString();
      stdoutSize += chunk.length;
      if (stdoutSize &gt; REPOMIX_MAX_BUFFER_SIZE) {
        repomix.kill(&#39;SIGKILL&#39;);
        return reject(new Error(&#39;Repomix output too large&#39;));
      }
      stdout += chunk;
    });

    repomix.stderr.on(&#39;data&#39;, (data) =&gt; reject(data));
    repomix.on(&#39;close&#39;, (code) =&gt; resolve(stdout.trim()));
  });
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Executes the <code class="inline-code">repomix</code> tool, ensuring resource allocation is capped.</li>
<li><strong>Safety</strong>: Monitors subprocess to avoid unbounded memory usage.</li>
<li><strong>Flexibility</strong>: Configurable arguments adapt to various styles and scopes.</li>
<li><strong>Handling</strong>: Graceful fallbacks ensure subprocess resilience.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> Navigating the AI Constellations</h3>
<p>The <code class="inline-code">LLMClient</code> file guides communication with large language models, adapting requests based on the selected generative engine. It translates high-level input into actionable prompts while performing robust error management and token usage analytics.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateResponse</code>: Centralizes the logic for converting prompts into LLM completions while handling retries, timeouts, and response validation.</li>
<li><code class="inline-code">constructor</code>: Initializes the LLM client by determining configuration for API keys, deployment types, and models.</li>
<li><code class="inline-code">getApiKey</code>: Selects the authentication method based on the backend provider.</li>
</ul>
<hr>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);

    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }

    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    const message = error.message;
    throw new Error(`LLM request failed: ${message}`);
  }
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Converts prompts into refined LLM responses using structured requests.</li>
<li><strong>Adaptation</strong>: Dynamically configures parameters based on model type and options.</li>
<li><strong>Safety</strong>: Logs errors and token usage metrics, fostering transparency.</li>
</ul>
<hr>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required.&#39;);
  }

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({ endpoint: azureEndpoint, apiKey });
  } else {
    this.client = new OpenAI({ apiKey, baseURL: LLM_BASE_URL });
  }
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Sets up the LLM client with appropriate authentication and endpoints.</li>
<li><strong>Model-Specific Configurations</strong>: Tailors initialization for Azure vs. OpenAI setups.</li>
<li><strong>Errors</strong>: Verifies prerequisites, stopping execution for incomplete setups.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) throw new Error(&#39;GITHUB_TOKEN required.&#39;);
    return GITHUB_TOKEN;
  }

  if (!LLM_API_KEY) throw new Error(&#39;LLM_API_KEY required.&#39;);
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li><strong>Purpose</strong>: Centralizes logic for selecting API keys based on the backend type.</li>
<li><strong>Validation</strong>: Ensures key presence to prevent misconfigurations.</li>
<li><strong>Adaptability</strong>: Differentiates between GitHub-hosted and standard providers.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li><strong>Tip</strong>: Observe how <code class="inline-code">generateResponse</code> dynamically tailors LLM queries to explore adaptive system strategies.</li>
<li><strong>Recommendation</strong>: Compare <code class="inline-code">RepoAnalyzer</code> and <code class="inline-code">LLMClient</code> error-handling methodologies for insights on robust design.</li>
<li><strong>Next Step</strong>: Prepare for the final frontier‚Äîexploring configuration-based dynamic themes!</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Mission Control reports a stellar success as Quest 4: Code Analysis &amp; Content Pipeline powers your starship to 60% completion‚Äîkeep igniting those intellectual thrusters, Commander! ‚≠êüöÄüíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-3.html" class="prev-quest-btn">‚Üê Previous: Quest 3</a>
        <a href="quest-5.html" class="next-quest-btn">Next: Quest 5 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>