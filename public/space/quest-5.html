<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Utility Systems in the Starship Foundation - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Horizons: Adventures in Galactic Code</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Utility Systems in the Starship Foundation</h1>
<hr>
<p>Aboard the <em>Horizons</em>, the success of your mission depends not only on decoding the Code Nebula&#39;s cryptic transmissions but also on the reliability of the starship&#39;s foundational systems. In this final chapter, you turn your attention to the ship&#39;s core utilities‚Äîensuring your journey has an unshakable foundation. The <em>Horizons</em>&#39; utility framework facilitates the parsing of cosmic data, validates input from diverse operational modules, and maintains seamless cooperation between its subsystems. Your crew must ensure this subsystem is robust, optimized, and ready to face the unpredictable nature of intergalactic exploration. Every line of its code could mean the difference between discovery and disaster.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Signal Path Mapping</strong>: How does the system locate and validate file paths referenced in the adventure configuration?</li>
<li>‚ö° <strong>Config Parsing Flow</strong>: What mechanisms are in place to parse and transform configuration data into actionable insights for the adventure system?</li>
<li>üõ°Ô∏è <strong>Error Containment Protocols</strong>: What approach is used to safeguard against errors when configuration or file paths are not accessible or valid?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Core adventure configuration utilities</h3>
<p>This file encapsulates key utility functions for managing and operating on the adventure configuration file. It ensures the adventure system has access to structured, validated data and that references to file paths are accurate. Among its many noteworthy functions, it includes logic for parsing JSON configurations, traversing nested objects to extract file paths, and generating concise summaries for LLM prompts. These utilities form the backbone of the <em>Horizons</em>&#39; ability to load and operate adventures accurately.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadAdventureConfig</code> retrieves the raw configuration file as plain text. This function is critical for reading the foundational configuration required to initialize adventures.</li>
<li><code class="inline-code">parseAdventureConfig</code> parses the raw configuration into a validated JSON object. It centralizes parsing logic into a single function to reduce redundancy and potential inconsistencies.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> traverses the parsed configuration object to extract validated file paths. This ensures operations dependent on these files are stable and error-free.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> formats the adventure configuration into a condensed format suitable for LLM input. This reduces unnecessary verbosity while retaining critical contextual information.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">/**
 * Loads the raw adventure config text if present.
 * Pure file read - no parsing here.
 */
export function loadAdventureConfig(projectPath: string): string | null {
  const configPath = path.join(projectPath, ADVENTURE_CONFIG_FILE);
  return readFileIfExists(configPath);
}
</code></pre>
<ul>
<li>This function leverages <code class="inline-code">readFileIfExists</code> to handle missing or inaccessible files gracefully.</li>
<li>By isolating file reading logic from parsing, it increases modularity and reusability.</li>
<li>The function uses the <code class="inline-code">path</code> module to construct file paths dynamically based on the project directory.</li>
<li>Its output (raw text or <code class="inline-code">null</code>) simplifies downstream handling of absent files.</li>
<li>Notice the fallback behavior‚Äîfailure to read the file does not crash the system, ensuring reliability.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Parses the adventure config into an object (or null on error/missing).
 * Single point of JSON parsing and validation.
 */
export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>This function builds upon <code class="inline-code">loadAdventureConfig</code>, tightly integrating file loading and parsing steps.</li>
<li>Centralized parsing reduces duplication and improves maintainability across the codebase.</li>
<li>By wrapping <code class="inline-code">JSON.parse</code> in a <code class="inline-code">try-catch</code>, it avoids unhandled errors that might crash the system under malformed input.</li>
<li>Returning <code class="inline-code">null</code> for failures allows consumers of this function to handle configuration parsing in a predictable manner.</li>
<li>Its simplicity adheres to the single-responsibility principle, focusing purely on JSON conversion and validation.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Extracts all unique, existing file paths referenced by &quot;path&quot; fields anywhere in the config.
 */
export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>This sophisticated function traverses nested configuration objects to locate all file paths specified by <code class="inline-code">path</code> properties.</li>
<li>Using a <code class="inline-code">Set</code> guarantees that only unique paths are returned, eliminating duplicates for streamlined processing.</li>
<li>Stack-based traversal ensures the function works regardless of configuration depth, supporting complex nested structures.</li>
<li>It validates the existence of referenced files with <code class="inline-code">fs.existsSync</code>, filtering out broken references.</li>
<li>The combination of traversal, validation, and deduplication enhances robustness and utility.</li>
</ul>
<hr>
<pre><code class="language-typescript">/**
 * Formats adventure config into a minimal format for LLM prompts
 * OPTIMIZED: Reduced from 7,279 to ~2,000 characters (72% reduction)
 */
export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>This function transforms verbose configuration files into concise summaries optimized for LLM interaction.</li>
<li>It uses nested object traversal to extract meaningful details like file paths and function names.</li>
<li>By filtering out empty fields, it ensures the final output is clean and focused.</li>
<li>The reduction in verbosity minimizes token usage, a strategic improvement for LLM efficiency.</li>
<li>Its output provides a perfect balance of brevity and clarity, useful for automated processing systems.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">extractUniqueFilePaths</code> to audit and clean up misplaced or unused configuration files.</li>
<li>To debug LLM output issues, ensure <code class="inline-code">formatAdventureConfigForPrompt</code> is integrated correctly with its consumers.</li>
<li>For improved file path validation, consider adding asynchronous support to <code class="inline-code">extractUniqueFilePaths</code>.</li>
</ul>
<hr>
<p>You have mastered all the secrets of the <em>Horizons</em>&#39; foundational systems! Your adventure is complete.</p>
<p>Mission accomplished, Star Voyager! üöÄ You&#39;ve powered up the utility systems of the starship foundation, igniting a stellar path through the cosmos‚Äîjust one quest away from galactic mastery! ‚≠ê‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>