<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: Cartography Annex - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship RepoVenture: Charting the Code Galaxy</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: Cartography Annex</h1>
<hr>
<p>The command bridge hums as your research starship enters the Cartography Annex, where raw config signals are refined into star maps for the LLM core. Reactors funnel context while analyzers slice nebulae of JSON, and your onboard AI compiles a minimal chart for transmission. This chapter completes the stellar atlas: extracting viable file waypoints, validating signal integrity, and compressing guidance into mission-ready prompts. Study the Annex‚Äôs core routines to calibrate scanners and finalize navigation beacons for a fully mapped galaxy of your project.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">parseAdventureConfig</code> centralize JSON decoding and error tolerance to keep the pipeline resilient against malformed inputs?</li>
<li>‚ö° Waypoint Mapping: What traversal pattern does <code class="inline-code">extractUniqueFilePaths</code> use to discover <code class="inline-code">path</code> fields across arbitrarily nested structures, and how does it validate existence?</li>
<li>üõ°Ô∏è Signal Compression: In <code class="inline-code">formatAdventureConfigForPrompt</code>, how are quest titles, file paths, and function names reduced to a compact structure while avoiding null or invalid entries?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Annex utilities for loading, parsing, extracting, and formatting adventure configuration</h3>
<p>This Annex module supplies four mission-critical routines that power your starship‚Äôs cartography workflow. First, <code class="inline-code">loadAdventureConfig</code> performs a pure file read of <code class="inline-code">adventure.config.json</code> under a given project path, delegating I/O to a guarded <code class="inline-code">readFileIfExists</code> that treats missing files as non-fatal. Next, <code class="inline-code">parseAdventureConfig</code> becomes the single decoding station: it calls <code class="inline-code">loadAdventureConfig</code>, attempts <code class="inline-code">JSON.parse</code>, and returns <code class="inline-code">null</code> on any parse error to prevent exception leaks into higher layers. With decoded data in hand, <code class="inline-code">extractUniqueFilePaths</code> navigates the entire object graph using an explicit stack, locating any <code class="inline-code">path</code> fields at any depth. It validates each candidate using <code class="inline-code">fs.existsSync(path.resolve(projectPath, rel))</code>, collecting only real, unique waypoints. Finally, <code class="inline-code">formatAdventureConfigForPrompt</code> condenses the data into a minimal, LLM-friendly signal: listing quest titles, file paths, and highlight function names while filtering empty structures. Together, these functions transform raw repository signals into navigable charts: robust reads, tolerant parsing, exhaustive traversal, and deliberate compression. This pattern ensures downstream story generators and analyzers receive clean, consistent inputs, enabling stable mission execution and predictable content assembly across the galaxy of your project.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig</code> centralizes JSON parsing and shields upstream systems by returning <code class="inline-code">null</code> on unreadable or malformed configs, ensuring fault isolation.</li>
<li><code class="inline-code">extractUniqueFilePaths</code> performs a stack-based graph traversal to find <code class="inline-code">path</code> fields anywhere, validating existence and de-duplicating results for precise waypoints.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt</code> compresses the adventure structure into a succinct prompt: quest titles, file paths, and function names only, minimizing token load.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Serves as the single point of JSON decoding, simplifying error handling across the system</li>
<li>Uses a guard on missing raw content and a <code class="inline-code">try/catch</code> around <code class="inline-code">JSON.parse</code> for safety</li>
<li>Returns <code class="inline-code">null</code> instead of throwing, keeping the pipeline resilient and predictable</li>
<li>Decouples parsing from I/O by delegating read logic to <code class="inline-code">loadAdventureConfig</code></li>
<li>Encourages upstream callers to handle <code class="inline-code">null</code> as a non-fatal absence of configuration</li>
</ul>
<hr>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Executes an explicit stack-based traversal over arbitrary nested objects and arrays</li>
<li>Detects <code class="inline-code">path</code> fields anywhere in the structure and trims/validates candidates</li>
<li>Uses <code class="inline-code">fs.existsSync</code> with <code class="inline-code">path.resolve</code> to ensure only real files become waypoints</li>
<li>Employs a <code class="inline-code">Set</code> to de-duplicate paths, preventing redundant navigation targets</li>
<li>Returns a stable array of unique, existing file paths for downstream analyzers</li>
</ul>
<hr>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    
    // Just file paths, no verbose descriptions
    const filePaths = quest.files.map((f: any) =&gt; f.path).filter(Boolean);
    formatted += `Files: ${filePaths.join(&#39;, &#39;)}\n`;
    
    // Just function names, no descriptions
    const functions = quest.files
      .flatMap((f: any) =&gt; f.highlights || [])
      .map((h: any) =&gt; h.name)
      .filter(Boolean);
    formatted += `Functions: ${functions.join(&#39;, &#39;)}\n\n`;
  }

  return formatted;
}
</code></pre>
<ul>
<li>Produces a compact prompt representation to reduce token usage for the LLM core</li>
<li>Filters invalid quests and missing arrays to maintain well-formed output</li>
<li>Extracts only file paths and function names, stripping verbose descriptions</li>
<li>Iterates deterministically over quests and their files/highlights to build structure</li>
<li>Returns an empty string when configuration is missing or malformed, preserving stability</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>Start with <code class="inline-code">parseAdventureConfig</code> to confirm whether your config is readable before exploring traversal or formatting.</li>
<li>Compare the output of <code class="inline-code">extractUniqueFilePaths</code> to your repository layout to spot missing or misconfigured waypoints.</li>
<li>Use <code class="inline-code">formatAdventureConfigForPrompt</code> output to sanity-check what the LLM core will actually ingest.</li>
</ul>
<hr>
<p>You have mastered all the secrets of your project context! Your adventure is complete.</p>
<p>Mission log update: You‚Äôve charted the Cartography Annex like a star navigator and pushed your starship to 80% completion‚ÄîQuest 5 secured with stellar precision, trajectory locked for the final frontier, full thrusters ahead! üöÄ‚≠êüì°üó∫Ô∏è</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="prev-quest-btn">‚Üê Previous: Quest 4</a>
        <a href="index.html" class="next-quest-btn complete-btn">Complete Adventure ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>