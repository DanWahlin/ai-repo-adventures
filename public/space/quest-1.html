<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: MCP Relay Beacon Activation - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Repo Odyssey</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: MCP Relay Beacon Activation</h1>
<hr>
<p>Your starship glides along the rim of a code galaxy as the MCP relay flickers to life. The AdventureManager and StoryGenerator chart routes across repositories while the RepoAnalyzer compresses stellar data into tight-band signals. You, navigator, must activate the relay beacon that links ground crews to command consoles. Calibrate the handlers, verify tool manifests, and ensure safe orbit insertion for every request traversing the relay. With the LLMClient translating cosmic noise, your mission is to unify scanning, storytelling, and tool execution into a seamless voyage across the code cosmos.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">RepoAdventureServer.setupHandlers</code> transform Zod schemas into JSON Schemas and bundle them in <code class="inline-code">ListToolsRequestSchema</code> responses?</li>
<li>‚ö° Relay Signal Flow: In <code class="inline-code">main</code> and <code class="inline-code">RepoAdventureServer.run</code>, how is the stdio transport initialized, the server connected, and the pre-generation warm-up triggered without blocking startup?</li>
<li>üõ°Ô∏è Fault Containment Shield: When <code class="inline-code">CallToolRequestSchema</code> executes a tool, how are invalid parameters distinguished from unknown tools, and how are unexpected errors wrapped and surfaced?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> MCP server bootstrap and handler orchestration</h3>
<p>This file constructs the <code class="inline-code">RepoAdventureServer</code> bridge that exposes tools through MCP and ensures reliable signal handling. The <code class="inline-code">constructor</code> seeds a <code class="inline-code">Server</code> instance with service metadata and <code class="inline-code">capabilities.tools</code> to advertise tool readiness. Within <code class="inline-code">setupHandlers</code>, the relay lists tools dynamically by reflecting over the exported <code class="inline-code">tools</code> registry and converting each tool‚Äôs Zod <code class="inline-code">schema</code> into a JSON Schema via <code class="inline-code">zodToJsonSchema</code>. This ensures MCP clients receive machine-parseable <code class="inline-code">inputSchema</code> for validation on the client side. The same method also defines the call path for executing tools: it validates arguments using <code class="inline-code">tool.schema.safeParse</code>, returns parsed data to <code class="inline-code">tool.handler</code> only on success, and applies precise error mapping. Unknown tools emit <code class="inline-code">ErrorCode.MethodNotFound</code>, while invalid parameters yield <code class="inline-code">ErrorCode.InvalidParams</code> with aggregated, path-specific messages. Any other failure is encapsulated as <code class="inline-code">ErrorCode.InternalError</code>, preserving operational clarity.</p>
<p>In <code class="inline-code">run</code>, the server connects over <code class="inline-code">StdioServerTransport</code>, logging status, then pre-warms repository context with <code class="inline-code">repoAnalyzer.preGenerate(process.cwd())</code>. This approach improves first-interaction latency without blocking the server loop. The <code class="inline-code">main</code> routine anchors lifecycle control: it installs <code class="inline-code">SIGINT</code>/<code class="inline-code">SIGTERM</code> traps for graceful cleanup via <code class="inline-code">repoAnalyzer.cleanup</code>, logs unhandled rejections without crashing, and guards startup with a fatal error path. The orchestration balances responsiveness, safety, and observability across the relay mission.</p>
<h4>Highlights</h4>
<ul>
<li>Dynamic capability publication via <code class="inline-code">ListToolsRequestSchema</code> with Zod-to-JSON Schema translation</li>
<li>Robust tool invocation pipeline with schema validation and granular <code class="inline-code">McpError</code> mapping</li>
<li>Non-blocking startup and caching warm-up using <code class="inline-code">repoAnalyzer.preGenerate</code></li>
<li>Graceful shutdown signals and unhandled rejection handling for operational resilience</li>
</ul>
<h3><span class="header-prefix">packages/mcp/src/tools.ts:</span> Tool registry and MCP naming convention</h3>
<p>This file acts as the manifest for the exploration instruments mounted on the relay. It imports the <code class="inline-code">adventureManager</code> for shared state and orchestrates four mission-critical tools: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, and <code class="inline-code">view_progress</code>. Each tool is sourced from its dedicated module and re-exported with snake_case identifiers that align with client-side MCP expectations. The <code class="inline-code">tools</code> object aggregates these entries for discovery by the server. This registry becomes the single source of truth the server reflects upon when listing tools and executing them. While the individual handlers reside in their own files, this registry defines how they are surfaced to the MCP universe and ensures a consistent interface. The structure enables modular maintenance: tools evolve independently while the registry maintains stable MCP-facing names and descriptions. Clients receive coherent capabilities, and server introspection remains clean and deterministic.</p>
<h4>Highlights</h4>
<ul>
<li>Centralized export of <code class="inline-code">adventureManager</code> for cross-tool coordination</li>
<li>Canonical MCP tool naming via <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, <code class="inline-code">view_progress</code></li>
<li>Aggregated <code class="inline-code">tools</code> registry consumed by the server for dynamic listing and dispatch</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
</code></pre>
<p>Like a docking controller, it publishes a manifest of tools and validates cargo before allowing any operation to proceed.</p>
<pre><code class="language-typescript">  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
</code></pre>
<p>Like initiating a radio uplink, it connects on stdio and spins up background telemetry caching for faster responses.</p>
<pre><code class="language-typescript">async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<p>Like a bridge officer‚Äôs protocol, it watches ship signals, logs anomalies, and keeps the mission alive unless failure is fatal.</p>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<p>Like a ship‚Äôs armory manifest, it catalogs instruments and presents them under standardized call signs for mission control.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Trace error paths: follow <code class="inline-code">McpError</code> codes to see how clients will interpret failures during tool calls.</li>
<li>Compare schemas: observe how Zod schemas become JSON Schema via <code class="inline-code">zodToJsonSchema</code> for client-side validation.</li>
<li>Watch lifecycle hooks: signals and unhandled rejection paths reveal operational guarantees during long missions.</li>
</ul>
<hr>
<p>Relay beacon aligned and transmitting. Your crew can now receive quests across the code cosmos. Proceed to calibrate additional instruments in the next sector.</p>
<p>Mission control confirms a triumphant ignition as you successfully activate Quest 1: MCP Relay Beacon, locking in a stellar milestone on your cosmic learning trajectory‚Äîengines hot, üì° aligned, and course set for the next frontier! üöÄ‚≠ê‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>