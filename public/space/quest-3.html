<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Cosmic Signal Processing Array - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Repo Odyssey</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: Cosmic Signal Processing Array</h1>
<hr>
<p>Your console flickers as the MCP relay stabilizes. The AdventureManager charts vectors, the StoryGenerator whispers coordinates, and the RepoAnalyzer compresses an entire nebula of code into a navigable band. The LLMClient interprets static into speech. Your mission: assemble a Cosmic Signal Processing Array that harmonizes these instruments so future crews can tune the code galaxy with precision. Navigate timeouts, cache eddies, and provider routes. Calibrate validators and accelerate data through subprocess conduits. Synchronize these signals, navigator, and broadcast a clear route across the stars.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">RepoAnalyzer.validateProjectPath</code> guard against hazardous path inputs, and what minimal assumptions does it enforce?</li>
<li>‚ö° Subprocess Orbit: In <code class="inline-code">RepoAnalyzer.captureRepomixStdout</code>, how do timeout, buffer limits, and exit codes interplay to ensure stable signal capture from <code class="inline-code">repomix</code>?</li>
<li>üõ°Ô∏è Relay Hardening: In <code class="inline-code">LLMClient.constructor</code> and <code class="inline-code">LLMClient.getApiKey</code>, how does provider detection alter initialization, and what errors protect configuration integrity?</li>
<li>üîç Packet Shaping: How does <code class="inline-code">RepoAnalyzer.generateTargetedContent</code> transform target files into safe, cacheable requests, and where does normalization occur?</li>
<li>‚ö° Model Router Trajectory: How do <code class="inline-code">LLMClient.isAzureOpenAI</code> and the request execution flow influence endpoints and model parameters during response generation?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Signal compression and subprocess capture for repository context</h3>
<p>This module operates like a compression dish pointed at a code galaxy. <code class="inline-code">RepoAnalyzer.validateProjectPath</code> performs early hull checks on <code class="inline-code">projectPath</code>, preventing null bytes and empty vectors that could breach the cargo bay. The core uplink <code class="inline-code">captureRepomixStdout</code> spawns <code class="inline-code">repomix</code> as a subprocess, buffering emissions with strict <code class="inline-code">REPOMIX_MAX_BUFFER_SIZE</code> and enforcing orbital windows via <code class="inline-code">REPOMIX_SUBPROCESS_TIMEOUT</code> and <code class="inline-code">REPOMIX_GRACEFUL_TIMEOUT</code>. It races against time, issuing <code class="inline-code">SIGTERM</code> then <code class="inline-code">SIGKILL</code> if the process refuses to dock, while truncating stderr in failure telemetry. <code class="inline-code">generateTargetedContent</code> runs a targeted sweep: it validates and normalizes file paths, constrains scope through <code class="inline-code">include</code>, toggles compression, and caches results keyed by normalized paths and flags. This targeted pass supports the broader <code class="inline-code">generateRepomixContext</code>, which falls back intelligently through optimized, targeted, then full sweeps based on <code class="inline-code">adventure.config.json</code> signals. Together, these functions transform raw repository radiation into structured, bounded transmissions that downstream instruments can parse without overload. The caching map keeps results warm between jumps, and the optimizer prunes nonessential noise into a navigable format for on-ship analysis.</p>
<h4>Highlights</h4>
<ul>
<li>Validates project path inputs to prevent unsafe operations and malformed trajectories</li>
<li>Spawns <code class="inline-code">repomix</code> with strict timeout and memory envelopes, handling graceful and forced termination</li>
<li>Uses normalized, validated include lists and stable cache keys for repeatable extractions</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">  private validateProjectPath(projectPath: string): void {
    if (!projectPath || typeof projectPath !== &#39;string&#39;) {
      throw new Error(&#39;Project path must be a non-empty string&#39;);
    }

    const trimmedPath = projectPath.trim();
    if (!trimmedPath) {
      throw new Error(&#39;Project path must be a non-empty string&#39;);
    }

    // Basic safety check for null bytes (can break file system operations)
    if (trimmedPath.includes(&#39;\0&#39;)) {
      throw new Error(&#39;Project path contains invalid null bytes&#39;);
    }
  }
</code></pre>
<p>Like checking a docking corridor for air leaks before opening the hatch.</p>
<pre><code class="language-typescript">  async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
    this.validateProjectPath(projectPath);
    
    if (!targetFiles || targetFiles.length === 0) {
      throw new Error(&#39;Target files array cannot be empty&#39;);
    }
    
    // Harden and validate target files
    const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
    if (safeFiles.length === 0) {
      throw new Error(&#39;No valid target files found after validation&#39;);
    }
    
    // Create stable cache key from normalized files
    const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
      return cached.content;
    }
    
    
    try {
      // Configure repomix options for targeted extraction
      const cliOptions: CliOptions = {
        style: &#39;markdown&#39;,
        stdout: true,
        compress: compress, // Configurable compression
        include: safeFiles.join(&#39;,&#39;), // Only include validated files
        removeComments: compress, // Remove comments if compressing
        removeEmptyLines: compress, // Remove empty lines if compressing
        noDirectoryStructure: true
      };

      // Capture stdout during repomix execution
      const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
      
      // Cache the result
      this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
      
      return context;
    } catch (error) {
      throw new Error(`Targeted repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
</code></pre>
<p>Like plotting a narrow-band scan of specific sectors and storing the results in the ship‚Äôs buffer for quick recall.</p>
<pre><code class="language-typescript">  private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
    return new Promise((resolve, reject) =&gt; {
      // Build repomix CLI arguments
      const args = [
        ...directories,
        &#39;--stdout&#39;,
        &#39;--style&#39;, options.style || &#39;markdown&#39;
      ];
      
      if (options.compress) args.push(&#39;--compress&#39;);
      if (options.removeComments) args.push(&#39;--remove-comments&#39;);
      if (options.removeEmptyLines) args.push(&#39;--remove-empty-lines&#39;);
      if (options.noDirectoryStructure) args.push(&#39;--no-directory-structure&#39;);
      if (options.ignore) args.push(&#39;--ignore&#39;, options.ignore);
      if (options.include) args.push(&#39;--include&#39;, options.include);
      
      // Spawn repomix as subprocess
      const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], {
        cwd,
        stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]
      });
      
      let stdout = &#39;&#39;;
      let stderr = &#39;&#39;;
      let stdoutSize = 0;
      let isResolved = false;
      
      // Set up timeout with graceful then force kill
      const timeout = setTimeout(() =&gt; {
        if (!isResolved) {
          console.warn(`Repomix subprocess timeout (${REPOMIX_SUBPROCESS_TIMEOUT}ms), killing process...`);
          repomix.kill(&#39;SIGTERM&#39;);
          setTimeout(() =&gt; repomix.kill(&#39;SIGKILL&#39;), REPOMIX_GRACEFUL_TIMEOUT);
          isResolved = true;
          reject(new Error(`Repomix subprocess timed out after ${REPOMIX_SUBPROCESS_TIMEOUT}ms (${cwd})`));
        }
      }, REPOMIX_SUBPROCESS_TIMEOUT);
      
      repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
        const chunk = data.toString();
        stdoutSize += chunk.length;
        
        // Memory protection
        if (stdoutSize &gt; REPOMIX_MAX_BUFFER_SIZE) {
          if (!isResolved) {
            isResolved = true;
            clearTimeout(timeout);
            repomix.kill(&#39;SIGKILL&#39;);
            reject(new Error(`Repomix output too large (${stdoutSize} bytes) for ${cwd}`));
          }
          return;
        }
        
        stdout += chunk;
      });
      
      repomix.stderr.on(&#39;data&#39;, (data) =&gt; {
        stderr += data.toString();
      });
      
      repomix.on(&#39;close&#39;, (code) =&gt; {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeout);
          
          if (code === 0 &amp;&amp; stdout.trim().length &gt; 0) {
            resolve(stdout);
          } else {
            reject(new Error(`Repomix failed (exit ${code}): ${stderr.substring(0, 200)}`));
          }
        }
      });
      
      repomix.on(&#39;error&#39;, (error) =&gt; {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeout);
          reject(new Error(`Repomix spawn failed: ${error.message}`));
        }
      });
    });
  }
</code></pre>
<p>Like opening a comms channel with strict bandwidth caps and an auto-abort if the station stops responding.</p>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">  constructor() {
    this.model = LLM_MODEL;
    
    // Determine API key based on provider
    const apiKey = this.getApiKey();
    if (!apiKey || !LLM_BASE_URL) {
      throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and appropriate API key (LLM_API_KEY or GITHUB_TOKEN).&#39;);
    }

    if (this.isAzureOpenAI()) {
      // Azure OpenAI requires endpoint without the path
      const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
      this.client = new AzureOpenAI({
        endpoint: azureEndpoint,
        apiKey,
        apiVersion: LLM_API_VERSION,
        deployment: this.model
      });
    } else {
      this.client = new OpenAI({
        apiKey,
        baseURL: LLM_BASE_URL
      });
    }
  }
</code></pre>
<p>Like selecting the correct transceiver array and calibrating its endpoint before transmitting.</p>
<pre><code class="language-typescript">  private getApiKey(): string {
    // GitHub Models (hosted on Azure) uses GITHUB_TOKEN
    if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
      if (!GITHUB_TOKEN) {
        throw new Error(&#39;GITHUB_TOKEN required for GitHub Models. Set GITHUB_TOKEN environment variable.&#39;);
      }
      return GITHUB_TOKEN;
    }
    // All other providers (OpenAI, Azure OpenAI, Ollama, etc.) use LLM_API_KEY
    if (!LLM_API_KEY) {
      throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
    }
    return LLM_API_KEY;
  }
</code></pre>
<p>Like choosing the right clearance codes depending on which relay station you approach.</p>
<pre><code class="language-typescript">  private isAzureOpenAI(): boolean {
    return LLM_BASE_URL.includes(&#39;.openai.azure.com&#39;) || LLM_BASE_URL.includes(&#39;cognitiveservices.azure.com&#39;);
  }
</code></pre>
<p>Like checking star charts to see if you are entering Azure-controlled space lanes.</p>
<pre><code class="language-typescript">  async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
    try {
      const requestParams = this.buildRequestParams(prompt, options);
      const completion = await this.executeRequest(requestParams);
      let content = this.validateResponse(completion);
      
      // Post-process JSON responses that might be wrapped in markdown
      if (options?.responseFormat === &#39;json_object&#39;) {
        content = this.cleanJsonResponse(content);
      }
      
      this.logTokenUsage(completion);
      
      return { content };
    } catch (error) {
      // Enhanced error logging for debugging
      this.logDetailedError(error, prompt);
      
      const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
      throw new Error(`LLM request failed: ${message}`);
    }
  }
</code></pre>
<p>Like packaging a message, routing it through the relay, verifying a response packet, and logging bandwidth usage before handing it to the bridge.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">generateTargetedContent</code> when you need a focused scan to conserve tokens and accelerate response times.</li>
<li>Watch <code class="inline-code">captureRepomixStdout</code> for operational envelopes: timeouts and buffer limits are your guardrails in turbulent subprocess space.</li>
<li>For remote model routes, confirm <code class="inline-code">LLM_BASE_URL</code> and tokens align with <code class="inline-code">getApiKey</code> expectations before engaging the thrusters.</li>
</ul>
<hr>
<p>Signal array aligned. Your transmissions now traverse the code cosmos with clarity. Proceed to the next star chart when ready.</p>
<p>Mission triumph achieved: you‚Äôve calibrated the Cosmic Signal Processing Array and boosted your starship‚Äôs comms to light-speed clarity, pushing your campaign to 40% completion‚Äîkeep charting the nebulae, Commander, your trajectory is locked for glory! üöÄ‚≠êüì°‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>