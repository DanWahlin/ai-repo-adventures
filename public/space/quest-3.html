<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Code Analysis & Content Pipeline - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Galactic Repository Adventures</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: Code Analysis &amp; Content Pipeline</h1>
<hr>
<p>In the uncharted boundaries of Codex Prime, the <em>CodeSeeker</em> starship approaches a dense repository storm. This stellar pocket contains a trove of alien frameworks that challenge the sharpest technical minds. Your mission, as part of the Code Analysis &amp; Content Pipeline taskforce, is to penetrate two critical modules: an enigmatic repository analyzer and an advanced LLM client interface. Success will demand not only understanding their operational designs but also mapping their intricate interactions across the code pipeline. Do you have what it takes to decode these mysteries?</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Analyzer Calibration</strong>: How does <code class="inline-code">RepoAnalyzer</code> ensure safety and efficiency when processing repository content?</li>
<li>‚ö° <strong>Response Dynamics</strong>: How does <code class="inline-code">LLMClient</code> handle large-scale requests and differentiate configurations for the API backend?</li>
<li>üõ°Ô∏è <strong>Pipeline Defense Protocols</strong>: What mechanisms are in place for error prevention and recovery in both classes?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> Repository Analyzer Module</h3>
<p>The <code class="inline-code">RepoAnalyzer</code> class serves as the bridge between raw repository data and optimized output. Designed for high performance, it includes caching mechanisms, file validation routines, and functions to distill content into LLM-digestible streams. This sturdy module ensures that even the vastest repositories are analyzed securely and efficiently.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext</code>: Orchestrates the repository analysis, processes entire or partial content, and uses caching for optimization.</li>
<li><code class="inline-code">generateTargetedContent</code>: Extracts content for specific files with configurable compression and tailored CLI parameters.</li>
<li><code class="inline-code">captureRepomixStdout</code>: Interfaces with the <code class="inline-code">repomix</code> CLI tool as a subprocess, applying resource and timeout safeguards.</li>
<li><code class="inline-code">validateProjectPath</code>: Validates a project‚Äôs path to ensure it is free of unsafe or malformed inputs.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);

  const configuredFiles = extractUniqueFilePaths(projectPath);

  if (configuredFiles.length &gt; 0) {
    console.log(`Using adventure.config.json: analyzing ${configuredFiles.length} configured files with optimization`);
    try {
      return await this.generateOptimizedContent(projectPath, configuredFiles);
    } catch (error) {
      console.warn(`Failed to generate optimized content, falling back to targeted content: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  console.log(&#39;No adventure.config.json found: analyzing full codebase (compressed)&#39;);
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);

  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }

  try {
    const cliOptions: CliOptions = {
      style: options.style || &#39;markdown&#39;,
      stdout: true,
      compress: options.compress !== false,
      ignore: [&#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;].join(&#39;,&#39;),
      removeComments: true,
      removeEmptyLines: true,
      noDirectoryStructure: true
    };

    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);

    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });

    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<ul>
<li>Dynamically handles different types of repository configurations with fallback sequences.</li>
<li>Cache usage ensures repeated calls do not waste system resources during redundant analysis.</li>
<li>Implements defensive coding to manage errors when no configurations are available.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [...directories, &#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
    if (options.compress) args.push(&#39;--compress&#39;);
    if (options.removeComments) args.push(&#39;--remove-comments&#39;);

    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd, stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;] });
    let stdout = &#39;&#39;;
    let isResolved = false;

    const timeout = setTimeout(() =&gt; {
      if (!isResolved) {
        console.warn(`Repomix subprocess timeout (${REPOMIX_SUBPROCESS_TIMEOUT}ms), killing process...`);
        repomix.kill(&#39;SIGTERM&#39;);
        reject(new Error(`Timeout after ${REPOMIX_SUBPROCESS_TIMEOUT}ms`));
        isResolved = true;
      }
    }, REPOMIX_SUBPROCESS_TIMEOUT);

    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      stdout += data.toString();
    });

    repomix.on(&#39;close&#39;, (code) =&gt; {
      clearTimeout(timeout);
      if (!isResolved &amp;&amp; code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(&#39;Repomix execution failed&#39;));
      }
    });
  });
}
</code></pre>
<ul>
<li>Spawns a subprocess to safely interact with Repomix without blocking the main execution.</li>
<li>Guardrails like timeouts and memory checks shield against runaway subprocess behavior.</li>
<li>Demonstrates precise CLI wrapping for external tool interoperability.</li>
</ul>
<hr>
<pre><code class="language-typescript">private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<ul>
<li>Ensures that malformed paths, null bytes, or empty strings cannot compromise the system.</li>
<li>A lightweight validation method focused on input hygiene.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> Large Language Model Interface</h3>
<p>The <code class="inline-code">LLMClient</code> class connects to either OpenAI or Azure-hosted APIs to process natural language prompts. It takes into account API-specific differences, applies extensive error logging, and optimizes requests for large-scale tasks.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateResponse</code>: Issues a prompt to the backend and processes the LLM&#39;s response.</li>
<li><code class="inline-code">constructor</code>: Initializes the LLM backend, choosing between OpenAI or Azure configurations.</li>
<li><code class="inline-code">getApiKey</code>: Extracts the correct API key based on selected models or endpoints.</li>
<li><code class="inline-code">isAzureOpenAI</code>: Determines whether the backend is an Azure-hosted OpenAI instance.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);

    let content = this.validateResponse(completion);

    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }

    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error.message || &#39;Unknown error&#39;}`);
  }
}
</code></pre>
<ul>
<li>Encapsulates the full prompt lifecycle from parameter construction to response validation.</li>
<li>Focuses on error resilience with detailed error reporting.</li>
<li>Post-processes content to conform to structured formats like JSON when necessary.</li>
</ul>
<hr>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;

  const apiKey = this.getApiKey();
  if (!apiKey || !LLM_BASE_URL) {
    throw new Error(&#39;LLM configuration required. Please set LLM_BASE_URL and the appropriate API key.&#39;);
  }

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({ endpoint: azureEndpoint, apiKey });
  } else {
    this.client = new OpenAI({ apiKey, baseURL: LLM_BASE_URL });
  }
}
</code></pre>
<ul>
<li>Dynamically builds the appropriate client configuration.</li>
<li>Exhibits modular design by abstracting API-dependent parameters.</li>
</ul>
<hr>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for GitHub Models. Set GITHUB_TOKEN environment variable.&#39;);
    }
    return GITHUB_TOKEN;
  }

  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<ul>
<li>Differentiates between OpenAI and GitHub-hosted backend models when selecting API credentials.</li>
<li>Avoids failures by catching missing or invalid keys early.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>‚öôÔ∏è Use <code class="inline-code">generateRepomixContext</code> to explore full repository snapshots.</li>
<li>üì° <code class="inline-code">generateResponse</code> handles prompt-specific tasks for adaptive AI workloads.</li>
<li>üõ† Combine insights from both classes to understand pipeline optimizations.</li>
</ul>
<hr>
<p>Your crew awaits your next move, adventurer. Chart your course carefully and bring clarity to the cosmos!</p>
<p>Mission Control reports a stellar success on Quest 3: Code Analysis &amp; Content Pipeline‚Äîyour cosmic expertise is fueling this starship to 40% completion, onward to the stars! üöÄ‚≠ê‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>