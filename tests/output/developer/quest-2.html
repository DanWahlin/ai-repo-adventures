<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 2: The Architect’s Tome in the Chamber of Adventures - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'developer' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Codex of Repomix: Chronicles of the Advent</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 2: The Architect’s Tome in the Chamber of Adventures</h1>
<hr>
<p>In this chapter, you delve into the thrilling Chamber of Adventures, uncovering the ancient Architect&#39;s Tome. The tome radiates a profound coding energy, promising the secrets to orchestrating harmonious states within chaotic codebases. As you venture further, you will harness the powers of the Adventure Manager and Story Generator, two pivotal tools that dictate the flow of quests and construct thematic stories for explorers. Prepare for an intellectual expedition into the intricate bindings of software engineering.</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Adventure orchestration management</h3>
<p>The <code class="inline-code">adventure-manager.ts</code> file is the nerve center of the adventure system, dynamically managing state, quests, progress, and user interactions. It encapsulates the core logic for initializing adventures, executing quests, and determining progress percentages. Leveraging <code class="inline-code">AdventureState</code>, it maintains meticulous tracking of completed quests and caches content to optimize user experience. The file also implements methods to generate stories and quests via LLMs, integrating rich narratives while validating user inputs seamlessly. Key functions like <code class="inline-code">initializeAdventure()</code> set the foundation for theme-based storytelling, linking project context and configuration files to guide the adventure. Meanwhile, <code class="inline-code">exploreQuest()</code> facilitates quest execution based on user choices, employing validation routines and leveraging cached progress.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure()</code>: Combines project context, theming, and quest generation into a cohesive experience.</li>
<li><code class="inline-code">exploreQuest()</code>: Executes individual quests, caching results for efficiency and validating inputs to ensure fluid navigation.</li>
<li><code class="inline-code">progressPercentage</code>: Calculates adventure completion progress for optimal tracking and feedback to users.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/adventure/story-generator.ts:</span> The story creation engine</h3>
<p>The <code class="inline-code">story-generator.ts</code> file is the core powerhouse behind the thematic narratives and quest definitions. It interfaces with the LLM client to generate themed stories, thoughtful quests, and detailed adventure content. The function <code class="inline-code">generateStoryAndQuests()</code> spearheads the initialization, dynamically crafting storylines and quests based on project context and user-selected themes. The file also includes <code class="inline-code">generateQuestContent()</code>, which extracts focused repomix content and seamlessly integrates narrative context into a cohesive tale. A robust validation system ensures responses from the LLM align with expected schema structures. This module enables developers to traverse their codebases like adventurers exploring mythical realms.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateStoryAndQuests()</code>: Produces thematic stories and quests using contextualized LLM responses.</li>
<li><code class="inline-code">generateQuestContent()</code>: Constructs adventure tasks by blending quest-specific file analysis data with broader repomix content.</li>
<li><code class="inline-code">removeLLMMetaCommentary()</code>: Cleans out unwanted meta-responses from LLM content, ensuring high-quality narrative outputs.</li>
</ul>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Configuration for guided adventures</h3>
<p>The <code class="inline-code">adventure-config.ts</code> file centralizes all logic related to reading, formatting, and validating adventure configuration files. By parsing the <code class="inline-code">adventure.config.json</code>, it extracts contextual guidelines for quests, file analysis, and configuration-driven exploration paths. The <code class="inline-code">formatAdventureConfigForPrompt()</code> method creates well-structured prompts ready for use by LLMs during quest generation. Notably, this file plays a critical role in integrating file-specific highlights into adventures, bridging technical exploration with narrative storytelling. By ensuring clear and organized guidance is presented to the user, the file aids in constructing quests that align with intended project goals.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">parseAdventureConfig()</code>: Validates and extracts structured data from <code class="inline-code">adventure.config.json</code>.</li>
<li><code class="inline-code">formatAdventureConfigForPrompt()</code>: Crafts structured prompts for LLMs, emphasizing file-specific highlights.</li>
<li><code class="inline-code">extractUniqueFilePaths()</code>: Identifies all referenced paths within the configuration file to guide exploration.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">export class AdventureManager {
  async initializeAdventure(
    projectInfo: ProjectInfo, 
    theme: AdventureTheme, 
    projectPath?: string,
    customThemeData?: CustomThemeData
  ): Promise&lt;string&gt; {
    this.state.reset();
    this.state.projectInfo = projectInfo;
    this.state.currentTheme = theme;
    this.state.projectPath = projectPath || process.cwd();
    if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
      this.storyGenerator.setCustomTheme(customThemeData);
    }
    const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
    this.state.title = storyResponse.title;
    this.state.story = typeof storyResponse.story === &#39;string&#39;
      ? storyResponse.story
      : storyResponse.story.content;
    this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
    this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);
    return this.formatStoryWithQuests({
      ...storyResponse,
      quests: this.state.quests
    });
  }
}
</code></pre>
<p>This method is like a project manager meticulously setting up the pieces for a big software release with precision and care.</p>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string
): Promise&lt;StoryResponse&gt; {
  const validatedTheme = this.validateTheme(theme);
  const repomixContent = projectInfo.repomixContent || &#39;No repomix content available&#39;;
  let adventureGuidance = &#39;&#39;;
  if (projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
  }
  const prompt = loadStoryGenerationPrompt({
    theme,
    repomixContent,
    ...(adventureGuidance &amp;&amp; { adventureGuidance }),
  });
  const response = await this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_STORY });
  return parseMarkdownToStoryResponse(response.content.trim());
}
</code></pre>
<p>This process mirrors assembling a puzzle, carefully merging project details and guidelines to complete a thematic picture.</p>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  let formatted = `## Quest Structure Guidelines\n\n`;
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;
  
  for (const quest of adventure.quests) {
    formatted += `### ${quest.title}\n${quest.description}\n\n**Required File Analysis Sections:**\n`;
    for (const file of quest.files) {
      formatted += `\n**File: \`${file.path}\`**\n- Description: ${file.description}\n`;
      if (Array.isArray(file.highlights)) {
        formatted += `- Key Functions/Areas to Highlight:\n`;
        for (const highlight of file.highlights) {
          formatted += `  • **${highlight.name}**: ${highlight.description}\n`;
        }
      }
    }
  }
  return formatted;
}
</code></pre>
<p>This method functions like a translator, seamlessly converting JSON configuration into adventure-ready guidelines for global exploration.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Dive deeper into file-specific highlights during quest creation to enhance user engagement.</li>
<li>Customize the LLM response format further for clearer debugging during narrative generation.</li>
<li>Explore integrating interactive user feedback loops after quest completion for more dynamic experiences.</li>
</ul>
<hr>
<p>Congratulations, developer! You’ve successfully refactored your skill set by committing the Architect’s Tome to your knowledge base—your adventure is 25% complete and this milestone is a stellar pull request to your professional growth! 🚀⚡📡</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-3.html" class="next-quest-btn">Next: Quest 3: The Scribe’s Lens: Code Analysi... →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>