#!/usr/bin/env node

/**
 * Integration tests for the new targeted file extraction functionality
 * Tests the complete flow: adventure generation â†’ codeFiles â†’ targeted repomix â†’ LLM
 */

import { AdventureManager } from '../../packages/core/dist/adventure/adventure-manager.js';
import { repoAnalyzer } from '../../packages/core/dist/analyzer/repo-analyzer.js';
import { StoryGenerator } from '../../packages/core/dist/adventure/story-generator.js';
import { 
  createTestRunner, 
  realProjectInfo, 
  assert, 
  TestHelpers 
} from '../shared/test-utils.js';

// Mock console.log to capture targeted extraction logs
const originalLog = console.log;
const logMessages: string[] = [];
console.log = (...args: any[]) => {
  const message = args.join(' ');
  logMessages.push(message);
  originalLog(...args);
};

async function runTests() {
  console.log('ðŸŽ¯ Running Targeted File Extraction Integration Tests');
  console.log('');
  const { test, stats, printResults } = await createTestRunner('Targeted Extraction Tests');

  // Test 1: Adventure generation includes codeFiles
  console.log('ðŸ“‚ Adventure Generation Tests');
  console.log('-'.repeat(40));

  await test('Adventures generated by LLM include codeFiles property', async () => {
    const manager = new AdventureManager();
    
    // Initialize adventure with real project
    const projectPath = process.cwd();
    const storyResult = await manager.initializeAdventure(realProjectInfo, 'space', projectPath);
    
    assert(typeof storyResult === 'string', 'Should return story string');
    assert(storyResult.length > 100, 'Story should be substantial');
    
    // Get progress to access the generated adventures
    const progress = manager.getProgress();
    assert(progress.choices && progress.choices.length > 0, 'Should have adventures');
    
    // Access the internal adventure state to check codeFiles
    // Note: This requires accessing private state for testing
    const adventures = (manager as any).state.adventures;
    assert(Array.isArray(adventures), 'Should have adventures array');
    assert(adventures.length > 0, 'Should have at least one adventure');
    
    // Check if any adventure has codeFiles (not all adventures may have them)
    const adventuresWithFiles = adventures.filter((adv: any) => 
      adv.codeFiles && Array.isArray(adv.codeFiles) && adv.codeFiles.length > 0
    );
    
    console.log(`\nðŸ” Adventure Analysis:`);
    console.log(`   Total adventures: ${adventures.length}`);
    console.log(`   Adventures with codeFiles: ${adventuresWithFiles.length}`);
    
    adventures.forEach((adv: any, i: number) => {
      const fileCount = adv.codeFiles?.length || 0;
      console.log(`   ${i + 1}. "${adv.title}" - ${fileCount} files`);
      if (adv.codeFiles && adv.codeFiles.length > 0) {
        adv.codeFiles.forEach((file: string, j: number) => {
          console.log(`      ${j + 1}. ${file}`);
        });
      }
    });
    
    // At least some adventures should have codeFiles for a real project
    assert(adventuresWithFiles.length > 0, 'At least one adventure should have codeFiles for analysis');
    
    // Verify codeFiles contain reasonable file paths
    const allCodeFiles = adventuresWithFiles.flatMap((adv: any) => adv.codeFiles);
    const hasValidPaths = allCodeFiles.some((file: string) => 
      file.includes('.ts') || file.includes('.js') || file.includes('.json')
    );
    assert(hasValidPaths, 'codeFiles should contain valid file extensions');
    
  }, { timeout: 30000 });

  // Test 2: Targeted repomix extraction works
  console.log('');
  console.log('ðŸŽ¯ Targeted Repomix Extraction Tests');
  console.log('-'.repeat(40));

  await test('Targeted repomix extraction generates focused content', async () => {
    const projectPath = process.cwd();
    const targetFiles = [
      'src/adventure/adventure-manager.ts',
      'src/adventure/story-generator.ts'
    ];
    
    // Test targeted extraction directly
    const targetedContent = await repoAnalyzer.generateTargetedContent(projectPath, targetFiles);
    
    assert(typeof targetedContent === 'string', 'Should return string content');
    assert(targetedContent.length > 1000, 'Should have substantial content');
    assert(targetedContent.length < 50000, 'Should be smaller than full project content');
    
    // Verify content contains expected files
    const hasAdventureManager = targetedContent.includes('AdventureManager');
    const hasStoryGenerator = targetedContent.includes('StoryGenerator');
    assert(hasAdventureManager, 'Should contain AdventureManager content');
    assert(hasStoryGenerator, 'Should contain StoryGenerator content');
    
    // Verify it doesn't contain unrelated content
    const hasUnrelatedContent = targetedContent.includes('package.json') || 
                               targetedContent.includes('README.md');
    assert(!hasUnrelatedContent, 'Should not contain unrelated files');
    
    console.log(`\nðŸ“Š Targeted Content Stats:`);
    console.log(`   Content length: ${targetedContent.length} characters`);
    console.log(`   Estimated tokens: ~${Math.round(targetedContent.length / 4)}`);
    console.log(`   Target files: ${targetFiles.length}`);
    
  }, { timeout: 15000 });

  // Test 3: Adventure exploration triggers targeted extraction
  console.log('');
  console.log('ðŸš€ Adventure Exploration with Targeted Content Tests');
  console.log('-'.repeat(40));

  await test('Adventure exploration uses targeted content when codeFiles exist', async () => {
    const manager = new AdventureManager();
    const projectPath = process.cwd();
    
    // Clear previous log messages
    logMessages.length = 0;
    
    // Initialize adventure
    await manager.initializeAdventure(realProjectInfo, 'mythical', projectPath);
    
    // Get adventures to find one with codeFiles
    const adventures = (manager as any).state.adventures;
    const adventureWithFiles = adventures.find((adv: any) => 
      adv.codeFiles && adv.codeFiles.length > 0
    );
    
    if (!adventureWithFiles) {
      console.log('âš ï¸  No adventures with codeFiles found, skipping targeted extraction test');
      return;
    }
    
    console.log(`\nðŸŽ¯ Testing adventure: "${adventureWithFiles.title}"`);
    console.log(`   Target files: ${adventureWithFiles.codeFiles.join(', ')}`);
    
    // Explore the adventure - this should trigger targeted extraction
    const result = await manager.exploreQuest('1');
    
    assert(typeof result === 'object', 'Should return adventure result object');
    assert(typeof result.narrative === 'string', 'Should have narrative');
    assert(result.narrative.length > 100, 'Narrative should be substantial');
    
    // Check if targeted extraction was triggered by looking for log messages
    const targetedExtractionTriggered = logMessages.some(msg => 
      msg.includes('ðŸŽ¯ Generating targeted content') || 
      msg.includes('Targeted repomix content generation completed')
    );
    
    console.log(`\nðŸ“‹ Extraction Log Analysis:`);
    const relevantLogs = logMessages.filter(msg => 
      msg.includes('targeted') || msg.includes('repomix') || msg.includes('ðŸŽ¯')
    );
    relevantLogs.forEach(log => console.log(`   ${log}`));
    
    if (targetedExtractionTriggered) {
      console.log('âœ… Targeted extraction was triggered as expected');
    } else {
      console.log('â„¹ï¸  Targeted extraction may have used cache or fallen back to full content');
    }
    
    // The result should still be valid regardless of whether cache was used
    assert(result.narrative.includes('adventure') || result.narrative.includes('explore'), 
           'Should contain adventure-related content');
    
  }, { timeout: 45000 });

  // Test 4: Story coherence verification
  console.log('');
  console.log('ðŸ“– Story Coherence Tests');
  console.log('-'.repeat(40));

  await test('Adventure content maintains coherence with main story theme', async () => {
    const manager = new AdventureManager();
    const projectPath = process.cwd();
    
    // Test with ancient theme for clear thematic elements
    const mainStory = await manager.initializeAdventure(realProjectInfo, 'ancient', projectPath);
    
    // Extract theme elements from main story
    const ancientWords = ['temple', 'ancient', 'wisdom', 'sacred', 'pyramid', 'priest', 'ritual'];
    const mainStoryWords = TestHelpers.getFoundWords(mainStory.toLowerCase(), ancientWords);
    
    assert(mainStoryWords.length > 0, `Main story should contain ancient theme elements. Found: ${mainStoryWords}`);
    
    // Explore first adventure and check theme consistency
    const adventureResult = await manager.exploreQuest('1');
    const adventureWords = TestHelpers.getFoundWords(adventureResult.narrative.toLowerCase(), ancientWords);
    
    assert(adventureWords.length > 0, `Adventure content should maintain ancient theme. Found: ${adventureWords}`);
    
    console.log(`\nðŸ›ï¸  Theme Coherence Analysis:`);
    console.log(`   Main story ancient words: ${mainStoryWords.join(', ')}`);
    console.log(`   Adventure ancient words: ${adventureWords.join(', ')}`);
    console.log(`   Theme consistency: ${adventureWords.length > 0 ? 'âœ… Maintained' : 'âŒ Lost'}`);
    
    // Check that both reference the same project elements
    const projectElements = ['file', 'code', 'function', 'class', 'typescript', 'javascript'];
    const mainProjectRefs = TestHelpers.getFoundWords(mainStory.toLowerCase(), projectElements);
    const adventureProjectRefs = TestHelpers.getFoundWords(adventureResult.narrative.toLowerCase(), projectElements);
    
    assert(mainProjectRefs.length > 0, 'Main story should reference project elements');
    assert(adventureProjectRefs.length > 0, 'Adventure should reference project elements');
    
    console.log(`   Main story project refs: ${mainProjectRefs.join(', ')}`);
    console.log(`   Adventure project refs: ${adventureProjectRefs.join(', ')}`);
    
  }, { timeout: 60000 });

  // Restore original console.log
  console.log = originalLog;

  printResults();
  return stats;
}

// Allow this test to be run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runTests().then(stats => {
    process.exit(stats.failed > 0 ? 1 : 0);
  }).catch(error => {
    console.error('Test runner failed:', error);
    process.exit(1);
  });
}

export { runTests };