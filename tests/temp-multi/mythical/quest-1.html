<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: MCP Tool Interface - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Enchanted Repository</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: MCP Tool Interface</h1>
<hr>
<p>In the citadel of code, you approach a gleaming console where spellbound scripts hum like dragon wings. The royal scribe whispers: the guild halls at <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/mcp/src/server.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/mcp/src/server.ts</code></a> and <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/mcp/src/tools.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/mcp/src/tools.ts</code></a> channel your commands into enchanted actions. <code class="inline-code">server.ts</code> raises a watchful sentinel that lists mystical implements and invokes them by true name, while <code class="inline-code">tools.ts</code> arrays the guild‚Äôs artifacts for your selection. With each incantation, quests unfurl like banners in a castle wind. Ready your focus, brave coder-knight; today you learn to commune with the MCP‚Äôs living runes.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Circuit of Invocation: How does <code class="inline-code">RepoAdventureServer.setupHandlers</code> transform tool definitions into both discoverable listings and safely invocable actions, and what validation patterns secure the ritual?</li>
<li>‚ö° Hearthfire of Operation: In what order does <code class="inline-code">RepoAdventureServer.run</code> establish transport, announce readiness, and pre-generate analysis, and why does this flow benefit responsiveness?</li>
<li>üõ°Ô∏è Ward against Chaos: How do <code class="inline-code">main</code> and the call handler differentiate recoverable faults from fatal ones, and what shutdown rites ensure cleanup without abrupt collapse?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> The sentinel that binds tools to transport and safeguards their execution</h3>
<p>This file crafts the MCP sentinel, embodied in the <code class="inline-code">RepoAdventureServer</code> <code class="inline-code">Class</code>, to host and invoke your guild‚Äôs tools. The constructor inscribes server identity and capabilities before calling <code class="inline-code">setupHandlers</code>, the grimoire where two vital bindings are forged. First, a dynamic listing rite uses <code class="inline-code">ListToolsRequestSchema</code> so clients can scry available implements. It translates each tool‚Äôs <code class="inline-code">schema</code> from Zod into JSON Schema via <code class="inline-code">zodToJsonSchema</code>, ensuring clients can present exact forms and constraints, not vague descriptions. Second, a guarded execution path binds <code class="inline-code">CallToolRequestSchema</code> to a dispatcher that checks a tool‚Äôs existence and validates incoming arguments with <code class="inline-code">schema.safeParse</code>, returning rich path-aware error messages when parameters misalign. The handler neatly separates <code class="inline-code">McpError</code> from unknown exceptions, rewrapping the latter in a protocol-friendly <code class="inline-code">InternalError</code>. Beyond the bindings, <code class="inline-code">run</code> invokes <code class="inline-code">StdioServerTransport</code>, establishing the castle gates of communication, logs its banner cry, and quietly warms caches by calling <code class="inline-code">repoAnalyzer.preGenerate</code> for the current project path. The outer <code class="inline-code">main</code> function crowns the ceremony: it installs graceful shutdown signals that call <code class="inline-code">repoAnalyzer.cleanup</code>, and listens for unhandled rejections without toppling the keep‚Äîfavoring continuity while still alerting the operator. Altogether, this file shapes reliable ingress, defensive execution, and stable lifecycle stewardship.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAdventureServer.setupHandlers</code> binds dynamic tool listing and execution, with Zod-driven validation and structured <code class="inline-code">McpError</code> handling to maintain protocol integrity.</li>
<li><code class="inline-code">RepoAdventureServer.run</code> activates <code class="inline-code">StdioServerTransport</code>, announces readiness, and pre-generates repository context to reduce latency for the first real command.</li>
<li><code class="inline-code">main</code> orchestrates lifecycle: constructing the server, registering signal traps for cleanup, tolerating unhandled rejections, and enforcing fail-fast on startup errors.</li>
</ul>
<h3><span class="header-prefix">packages/mcp/src/tools.ts:</span> The guild armory that registers and exports magical implements</h3>
<p>This armory gathers and names the guild‚Äôs implements for the sentinel to expose. It imports <code class="inline-code">adventureManager</code>‚Äîshared lore that tools can draw upon‚Äîand four distinct artifacts: <code class="inline-code">startAdventure</code>, <code class="inline-code">chooseTheme</code>, <code class="inline-code">exploreQuest</code>, and <code class="inline-code">viewProgress</code>. To fit the MCP dialect, each is re-exported with underscore names: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, and <code class="inline-code">view_progress</code>. The final <code class="inline-code">tools</code> <code class="inline-code">variable</code> collects them into a single registry, which <code class="inline-code">server.ts</code> consumes to produce listings and route invocation. While the internals of the imported handlers reside in separate files, this nexus is crucial: it maintains consistent naming, centralizes exposure, and ensures every tool carries a <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code> for discovery and safe execution. The presence of <code class="inline-code">adventureManager</code> hints at shared state and orchestration available to all tools, allowing quests to evolve across calls. In effect, this file is the curated shelf of enchanted items, presenting a clean, predictable interface for the sentinel to reflect outward and for clients to operate‚Äîno guesswork, only clearly typed incantations backed by Zod schemas.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">start_adventure.handler</code> entrypoint exposed via <code class="inline-code">start_adventure</code> enables initiation of the narrative journey using structured input and a known <code class="inline-code">schema</code>.</li>
<li><code class="inline-code">choose_theme.handler</code> exposed via <code class="inline-code">choose_theme</code> selects thematic runes for the saga, aligning future quests with a style the adventurer prefers.</li>
<li><code class="inline-code">explore_quest.handler</code> exposed via <code class="inline-code">explore_quest</code> delves into a chosen challenge, likely progressing state through <code class="inline-code">adventureManager</code>.</li>
<li><code class="inline-code">view_progress.handler</code> exposed via <code class="inline-code">view_progress</code> reveals current advancement, letting adventurers track accomplishments and remaining trials.</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">class RepoAdventureServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: &#39;repo-adventure&#39;,
        version: &#39;1.0.0&#39;,
        description: &#39;A gamified MCP server for exploring code repositories through interactive storytelling&#39;
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
}
</code></pre>
<ul>
<li>This code defines how tools are listed and executed through MCP request handlers, ensuring clients can discover capabilities and invoke safely.</li>
<li>It uses Zod validation (<code class="inline-code">schema.safeParse</code>) and converts schemas to JSON Schema for client interoperability via <code class="inline-code">zodToJsonSchema</code>.</li>
<li><code class="inline-code">McpError</code> paths provide precise error feedback, improving usability and preventing vague failures.</li>
<li>Dynamic dispatch via the <code class="inline-code">tools</code> registry keeps registration centralized and avoids hardcoding route logic.</li>
<li>Separating listing and execution clarifies responsibilities and aligns with MCP protocol structures.</li>
</ul>
<hr>
<pre><code class="language-typescript">  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
</code></pre>
<ul>
<li>Establishes <code class="inline-code">StdioServerTransport</code> to open the castle gates for MCP communication.</li>
<li>Logs readiness, aiding observability for operators and clients.</li>
<li>Warms repository context using <code class="inline-code">repoAnalyzer.preGenerate</code>, improving first-command latency.</li>
<li>Non-blocking pre-generation balances responsiveness with preparedness.</li>
<li>Ties execution environment to <code class="inline-code">process.cwd()</code>, a sensible default for local adventures.</li>
</ul>
<hr>
<pre><code class="language-typescript">async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<ul>
<li><code class="inline-code">main</code> configures lifecycle: constructs the server, wires signal traps, and starts the run loop.</li>
<li>Signal handling calls <code class="inline-code">gracefulShutdown</code>, ensuring <code class="inline-code">repoAnalyzer.cleanup</code> is attempted before exit.</li>
<li>Unhandled rejections are logged without immediate shutdown, prioritizing availability.</li>
<li>Startup failures are treated as fatal, exiting with code 1 to signal operational issues.</li>
<li>The final catch adds a safety net for unexpected top-level errors.</li>
</ul>
<hr>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<ul>
<li>Collects tool modules and re-exports them using MCP-friendly names with underscores.</li>
<li>Exposes <code class="inline-code">adventureManager</code> for shared orchestration across tools.</li>
<li>Centralizes the <code class="inline-code">tools</code> registry used by the server to list and dispatch tool calls.</li>
<li>Enforces consistent interface: each tool must provide <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code>.</li>
<li>Simplifies maintenance by decoupling tool implementation files from the registration surface.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Trace the flow from <code class="inline-code">tools</code> registration to <code class="inline-code">setupHandlers</code> to see how invocation is routed and validated.</li>
<li>Compare Zod <code class="inline-code">schema.safeParse</code> results with the formatted error messages to understand client error ergonomics.</li>
<li>Send a tool call with missing fields to observe how <code class="inline-code">InvalidParams</code> responses surface precise issue paths.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Huzzah, brave hero‚Äîby mastering Quest 1: MCP Tool Interface, you have forged the first sigil of knowledge in the kingdom‚Äôs grimoire, a shining milestone that heralds your epic ascent through the remaining quests with valor and arcane mastery!</p>

</div>


    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>