<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 1: Command Bridge Synchronization - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Starship Repo Odyssey</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: Command Bridge Synchronization</h1>
<hr>
<p>Your starship slips into orbit above a code galaxy, command bridge lights pulsing as ground control hails your crew. The AI navigator loads repository charts while sensors hum, compressing signals into charts for your next leap. In this chapter, you align the command bridge interfaces with tool consoles, ensuring the engine room‚Äôs story-forge can ignite on cue. Trace request flows, validate tool calls, and secure shutdown vectors. Bring scanners, calibrate beacons, and ready the crew. The cosmos of code awaits precise synchronization. Adventure Awaits ‚Äì Choose your quest wisely, brave adventurer!</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç Scanner Calibration: How does <code class="inline-code">setupHandlers</code> transform Zod schemas into JSON Schema for clients, and what pattern ensures tools are listed dynamically?</li>
<li>‚ö° Launch Sequence Mapping: In what order do <code class="inline-code">main</code> and <code class="inline-code">run</code> prepare transport, register shutdown handlers, and warm the analyzer cache, and why is work offloaded asynchronously?</li>
<li>üõ°Ô∏è Fault Constellation Analysis: How are <code class="inline-code">McpError</code> codes chosen in <code class="inline-code">setupHandlers</code> for missing tools and invalid parameters, and what resilience is provided for unhandled rejections?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/server.ts:</span> Command bridge server and transport orchestration</h3>
<p>This file is the command bridge of the mission, building a <code class="inline-code">Server</code> that connects via <code class="inline-code">StdioServerTransport</code> and orchestrating tool discovery and execution. The <code class="inline-code">RepoAdventureServer</code> constructor configures the MCP identity and capabilities, then delegates to <code class="inline-code">setupHandlers</code> to register two critical flows: tool listing and tool invocation. For listing, it composes tool metadata from <code class="inline-code">tools</code>, converting each tool‚Äôs Zod <code class="inline-code">schema</code> into JSON Schema through <code class="inline-code">zodToJsonSchema</code>, ensuring clients receive exact parameter contracts. For execution, it validates input strictly with <code class="inline-code">schema.safeParse</code>, translating violations into <code class="inline-code">McpError</code> with <code class="inline-code">InvalidParams</code>. Unknown tool names return <code class="inline-code">MethodNotFound</code>, while unexpected exceptions map to <code class="inline-code">InternalError</code>, preserving predictable protocol semantics. The <code class="inline-code">run</code> method initiates stdio transport and performs a background warmup using <code class="inline-code">repoAnalyzer.preGenerate(process.cwd())</code>, aligning sensors and engine caches without blocking command readiness. Outside the class, <code class="inline-code">main</code> creates the server, binds signal handlers for graceful shutdown, and logs unhandled promise rejections without tearing down the process, supporting continuous operation. The <code class="inline-code">gracefulShutdown</code> routine calls <code class="inline-code">repoAnalyzer.cleanup()</code> to release resources before exit. Together, these flows synchronize the bridge, tools console, and sensor priming to launch stellar quests.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">setupHandlers</code> registers dynamic tool listing and validated execution, mapping Zod schemas to JSON Schema and enforcing strict <code class="inline-code">McpError</code> responses</li>
<li><code class="inline-code">run</code> activates stdio transport and schedules analyzer pre-generation to warm caches while remaining responsive</li>
<li><code class="inline-code">main</code> wires graceful shutdown signals and unhandled rejection logging, then starts the server with robust startup error handling</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/mcp/src/tools.ts:</span> Tool manifest and export console</h3>
<p>This file is the tools console docked to the bridge. It imports specialized tool modules and re-exports them with MCP-compliant names, forming the definitive <code class="inline-code">tools</code> registry consumed by the server‚Äôs handlers. The comments document the intended user journey: <code class="inline-code">start_adventure</code>, <code class="inline-code">choose_theme</code>, <code class="inline-code">explore_quest</code>, and <code class="inline-code">view_progress</code>. It also exports <code class="inline-code">adventureManager</code> for shared state or orchestration needs inside tool handlers. The crucial pattern is the plain-object <code class="inline-code">tools</code> map with keys matching tool names; this enables <code class="inline-code">server.ts</code> to enumerate available tools and to resolve a handler by name during execution. Schemas and descriptions live with each tool module, and the server converts those schemas to JSON Schema for clients. Although the handler implementations reside in subfiles, the manifest here is the single source of truth for listing and invocation. Because <code class="inline-code">server.ts</code> validates against each tool‚Äôs <code class="inline-code">schema</code>, maintainers must ensure that every entry exported here carries a <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code>. This map is the nexus where engine room craftsmanship connects to the bridge‚Äôs dynamic discovery and call flow, ensuring the navigator can chart quests accurately.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">start_adventure.handler</code> orchestrated from this registry; its presence enables discovery and invocation through the <code class="inline-code">tools</code> map</li>
<li><code class="inline-code">choose_theme.handler</code> exposed for theme selection; listed and validated dynamically via the bridge handlers</li>
<li><code class="inline-code">explore_quest.handler</code> available for iterative quest dives; resolved by name at call time</li>
<li><code class="inline-code">view_progress.handler</code> included for mission status checks; participates in listing and schema validation</li>
</ul>
<h2>Code</h2>
<h3>packages/mcp/src/server.ts</h3>
<pre><code class="language-typescript">class RepoAdventureServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: &#39;repo-adventure&#39;,
        version: &#39;1.0.0&#39;,
        description: &#39;A gamified MCP server for exploring code repositories through interactive storytelling&#39;
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    // Dynamic tool listing
    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {
      const toolList = Object.entries(tools).map(([name, tool]) =&gt; ({
        name,
        description: tool.description,
        inputSchema: zodToJsonSchema(tool.schema, { 
          target: &#39;jsonSchema7&#39;,
          $refStrategy: &#39;none&#39;
        })
      }));

      return { tools: toolList };
    });

    // Dynamic tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {
      try {
        const { name, arguments: args } = request.params;

        if (!(name in tools)) {
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
        }

        const tool = tools[name as keyof typeof tools];
        
        // Validate arguments using the tool&#39;s Zod schema
        const validationResult = tool.schema.safeParse(args);
        if (!validationResult.success) {
          const errorMessages = validationResult.error.issues.map((err) =&gt; 
            `${err.path.join(&#39;.&#39;)}: ${err.message}`
          ).join(&#39;, &#39;);
          throw new McpError(ErrorCode.InvalidParams, `Invalid parameters: ${errorMessages}`);
        }

        // Execute the tool handler with validated arguments
        return await tool.handler(validationResult.data as any);

      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
</code></pre>
<ul>
<li>This code defines the bridge server, then configures dynamic tool listing and execution via MCP request handlers.</li>
<li>It converts Zod schemas into JSON Schema with <code class="inline-code">zodToJsonSchema</code>, ensuring clients receive precise parameter contracts.</li>
<li>It validates inputs using <code class="inline-code">safeParse</code>, translating issues into <code class="inline-code">McpError</code> with <code class="inline-code">InvalidParams</code>; unknown tools map to <code class="inline-code">MethodNotFound</code>.</li>
<li>The pattern centralizes error normalization, isolating protocol-level errors from internal exceptions via <code class="inline-code">InternalError</code>.</li>
<li>It connects directly to the <code class="inline-code">tools</code> registry, making the manifest the single source for discovery and invocation.</li>
</ul>
<hr>
<pre><code class="language-typescript">  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error(&#39;Repo Adventure MCP server running on stdio&#39;);
    
    // Pre-generate repomix content for the current working directory to warm up the cache
    // This happens in the background while waiting for user commands
    const projectPath = process.cwd();
    console.error(`Pre-generating repomix content for project at ${projectPath}...`);
    repoAnalyzer.preGenerate(projectPath);
  }
}
</code></pre>
<ul>
<li>Core function initiating stdio transport and connecting the MCP server for immediate command readiness.</li>
<li>Performs a non-blocking warmup by calling <code class="inline-code">repoAnalyzer.preGenerate</code>, improving first-use responsiveness.</li>
<li>Uses <code class="inline-code">process.cwd()</code> to target the current project path, aligning sensors with the active workspace.</li>
<li>Logs operational status to stderr for visibility in CLI environments.</li>
<li>Separates transport activation from background caching, preserving fast startup.</li>
</ul>
<hr>
<pre><code class="language-typescript">function gracefulShutdown() {
  console.error(&#39;\nShutting down MCP server...&#39;);
  try {
    repoAnalyzer.cleanup();
  } catch (e) {
    console.error(&#39;Cleanup error:&#39;, e);
  }
  process.exit(0);
}

async function main() {
  try {
    const server = new RepoAdventureServer();
    
    // Handle graceful shutdown for both signals
    [&#39;SIGINT&#39;, &#39;SIGTERM&#39;].forEach(sig =&gt; 
      process.on(sig as NodeJS.Signals, gracefulShutdown)
    );
    
    // Handle unhandled promise rejections - log but don&#39;t shutdown during normal operation
    process.on(&#39;unhandledRejection&#39;, (reason) =&gt; {
      console.error(&#39;Unhandled promise rejection:&#39;, reason);
      console.error(&#39;MCP server continuing to run. Please report this error.&#39;);
      // Don&#39;t call gracefulShutdown() here as it may be a recoverable error
    });
    
    await server.run();
  } catch (error) {
    console.error(&#39;Fatal error starting MCP server:&#39;, error);
    process.exit(1);
  }
}

main().catch((error) =&gt; {
  console.error(&#39;Unhandled error:&#39;, error);
  process.exit(1);
});
</code></pre>
<ul>
<li><code class="inline-code">main</code> orchestrates lifecycle: constructs the server, wires signal handlers, logs unhandled rejections, and starts the run loop.</li>
<li><code class="inline-code">gracefulShutdown</code> ensures resources are cleaned via <code class="inline-code">repoAnalyzer.cleanup()</code> before exiting.</li>
<li>Unhandled rejections are logged without immediate shutdown, prioritizing uptime and recoverability.</li>
<li>Startup failures trigger a fatal path with exit code 1, maintaining clear operational semantics.</li>
<li>The final <code class="inline-code">main().catch(...)</code> captures unexpected top-level errors, providing a safety net.</li>
</ul>
<hr>
<h3>packages/mcp/src/tools.ts</h3>
<pre><code class="language-typescript">import { adventureManager } from &#39;@ai-repo-adventures/core/adventure&#39;;
import { startAdventure } from &#39;./tools/start-adventure.js&#39;;
import { chooseTheme } from &#39;./tools/choose-theme.js&#39;;
import { exploreQuest } from &#39;./tools/explore-quest.js&#39;;
import { viewProgress } from &#39;./tools/view-progress.js&#39;;

// Export the shared adventure manager for tools that need it
export { adventureManager };

// Re-export tools with MCP naming convention
export const start_adventure = startAdventure;
export const choose_theme = chooseTheme;
export const explore_quest = exploreQuest;
export const view_progress = viewProgress;


// Export all tools for easy registration
export const tools = {
  start_adventure,
  choose_theme,
  explore_quest,
  view_progress
};
</code></pre>
<ul>
<li>This is the tool manifest: it maps internal tool modules to MCP-friendly names and exports a <code class="inline-code">tools</code> registry.</li>
<li>The <code class="inline-code">tools</code> object is the authoritative source used by the server to list and execute tools.</li>
<li>By exporting <code class="inline-code">adventureManager</code>, tools can share orchestration state across calls.</li>
<li>The comment block outlines the intended user flow across the four tools, guiding client behavior.</li>
<li>Ensuring each tool exposes <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code> is essential, as <code class="inline-code">server.ts</code> relies on them for validation and execution.</li>
</ul>
<h2>Helpful Hints</h2>
<ul>
<li>Confirm each tool entry includes <code class="inline-code">description</code>, <code class="inline-code">schema</code>, and <code class="inline-code">handler</code> so listing and validation succeed.</li>
<li>Trace a tool call from <code class="inline-code">CallToolRequestSchema</code> through schema validation to <code class="inline-code">tool.handler</code> to understand full flow.</li>
<li>Test signal handling locally by sending <code class="inline-code">SIGINT</code> to observe <code class="inline-code">gracefulShutdown</code> cleanup behavior.</li>
</ul>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries.</p>
<p>Mission update: With Quest 1: Command Bridge Synchronization successfully completed, your starship‚Äôs command systems are aligned and primed for the journey‚Äîstellar work, Commander‚Äîignite the thrusters and set course for the next objective! üöÄ‚≠ê‚ö°üì°</p>

</div>


    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>