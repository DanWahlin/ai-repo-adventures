import * as path from 'path';
import * as fs from 'fs';
import { BaseFormatStrategy, AdventureData } from '../format-strategy.js';
import type { HtmlBuilder, AssetManager, QuestInfo } from '../format-types.js';

/**
 * HTML format strategy - generates interactive website with multiple pages
 * This is a special strategy that generates multiple files instead of a single file
 */
export class HtmlStrategy extends BaseFormatStrategy {
  private outputDir: string;
  private theme: string;
  private htmlBuilder: HtmlBuilder;
  private assetManager: AssetManager;
  private isMultiTheme: boolean;
  private questContents: Map<string, string>;
  private keyConcepts?: string;

  constructor(
    outputDir: string,
    theme: string,
    htmlBuilder: HtmlBuilder,
    assetManager: AssetManager,
    questContents: Map<string, string>,
    isMultiTheme: boolean = false,
    keyConcepts?: string
  ) {
    super();
    this.outputDir = outputDir;
    this.theme = theme;
    this.htmlBuilder = htmlBuilder;
    this.assetManager = assetManager;
    this.questContents = questContents;
    this.isMultiTheme = isMultiTheme;
    this.keyConcepts = keyConcepts;
  }

  getFileExtension(): string {
    return 'html';
  }

  /**
   * HTML strategy generates multiple files
   */
  isMultiFile(): boolean {
    return true;
  }

  /**
   * Generate all HTML files for the adventure
   */
  async generateFiles(): Promise<void> {
    // Generate theme CSS
    await this.generateThemeCSS();

    // Copy quest navigator
    if (!this.isMultiTheme) {
      this.assetManager.copyQuestNavigator(this.outputDir);
    }

    // Copy images
    if (!this.isMultiTheme) {
      this.assetManager.copyImages(this.outputDir, this.isMultiTheme);
    }

    // Generate index.html
    this.generateIndexHTML();

    // Generate quest pages (content already generated and in questContents map)
    this.generateQuestPages();

    // Generate summary page
    await this.generateSummaryHTML();
  }

  private async generateThemeCSS(): Promise<void> {
    const themeCSS = this.assetManager.loadThemeCSS(this.theme);
    const baseCSS = this.assetManager.loadBaseCSS();
    const animationsCSS = this.assetManager.loadAnimationsCSS();

    let combinedCSS = themeCSS + '\n\n' + baseCSS + '\n\n' + animationsCSS;

    const imagePath = this.isMultiTheme ? '../../assets/images/' : 'images/';
    combinedCSS = combinedCSS.replace(/url\('images\//g, `url('${imagePath}`);

    const cssPath = path.join(this.outputDir, 'assets', 'theme.css');
    fs.writeFileSync(cssPath, combinedCSS);
  }

  private generateIndexHTML(): void {
    const html = this.htmlBuilder.buildIndexHTML();
    const indexPath = path.join(this.outputDir, 'index.html');
    fs.writeFileSync(indexPath, html);
  }

  private generateQuestPages(): void {
    // Quest content has already been generated by ContentGenerator
    // We just need to build HTML pages from the content
    const quests = this.htmlBuilder.quests; // Access quests from htmlBuilder

    quests.forEach((questInfo: QuestInfo, index: number) => {
      const questContent = this.questContents.get(questInfo.id) || 'Quest content not available.';
      const html = this.htmlBuilder.buildQuestHTML(questInfo, questContent, index);
      const questPath = path.join(this.outputDir, questInfo.filename);
      fs.writeFileSync(questPath, html);
    });
  }

  private async generateSummaryHTML(): Promise<void> {
    // Use provided keyConcepts or empty string as fallback
    const keyConcepts = this.keyConcepts || '';
    const html = await this.htmlBuilder.buildSummaryHTML(keyConcepts);
    const summaryPath = path.join(this.outputDir, 'summary.html');
    fs.writeFileSync(summaryPath, html);
  }
}

