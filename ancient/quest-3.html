<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Analyzing Monolith - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'ancient' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Lost Codex of Repositories</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Analyzing Monolith</h1>
<hr>
<p>In the heart of the temple&#39;s labyrinth lies the Analyzing Monolith, a towering structure inscribed with shifting glyphs and intricate patterns. Each etching seems to pulse with incomprehensible logic—holding the ability to decode the most chaotic of systems. To unveil its secrets, one must employ both technical acumen and a sense of ancient reverence. The monolith demands understanding of the tools of analysis, for it holds the power to interpret and organize the knowledge buried within the Lost Codex of Repositories. Sharpen your mind, adventurer, for precision is your ally and haste is your foe.</p>
<h2>File Exploration</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a>: Repomix integration for codebase analysis</h3>
<p>This file contains the mighty <code class="inline-code">RepoAnalyzer</code> class, which serves as the treasure map for extracting the encoded wisdom of a repository. Like a scholar meticulously decoding sacred texts, this class uses <code class="inline-code">repomix</code>—a tool for consolidating and analyzing large-scale codebases—to generate valuable insights. The <code class="inline-code">generateRepomixContext()</code> method processes entire repositories, applying strict path validation and caching mechanisms to ensure efficiency and security. For adventurers seeking focused knowledge, <code class="inline-code">generateTargetedContent()</code> allows the exploration of specific files. Central to its operation is <code class="inline-code">captureRepomixStdout()</code>, which invokes <code class="inline-code">repomix</code> in a subprocess, carefully structuring the content and safeguarding against overflows and timeouts. Each layer of its wisdom is treated with reverence, preventing accidental mishaps with rigorous checks like <code class="inline-code">validateProjectPath()</code>.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAnalyzer.generateRepomixContext()</code>: Analyzes a repository comprehensively while ensuring cache integrity.  </li>
<li><code class="inline-code">RepoAnalyzer.generateTargetedContent()</code>: Enables precise extraction of knowledge by focusing on selected files.  </li>
<li><code class="inline-code">captureRepomixStdout()</code>: Conducts the heart of the process, capturing the wisdom of <code class="inline-code">repomix</code> safely.  </li>
<li><code class="inline-code">validateAndNormalizeTargetFiles()</code>: Shields the realm from dangers like path traversal vulnerabilities.  </li>
<li><code class="inline-code">validateProjectPath()</code>: Ensures adventurers don&#39;t stray into forbidden lands (invalid directories).</li>
</ul>
<hr>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a>: Multi-provider LLM integration</h3>
<p>This file establishes the contract between the adventurer and the ancient oracle—the Large Language Models (LLMs). <code class="inline-code">LLMClient</code> serves as the conduit, supporting providers like OpenAI and Azure OpenAI. The heart of this file lies in <code class="inline-code">generateResponse()</code>, which crafts inquiries to the LLM and extracts its encoded wisdom, handling scenarios like timeouts or incomplete revelations. The constructor automatically detects the right deity—Azure or OpenAI—and configures it appropriately. Through this provider-agnostic integration, the client ensures that adventurers are equipped with the tools of the ancients to interpret and elaborate on the Monolith&#39;s riddles. Special care is taken to validate responses, ensuring that empty or malformed responses are caught and addressed.  </p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">LLMClient.generateResponse()</code>: A key to unlocking insights from the LLM, it handles prompt delivery and result interpretation.  </li>
<li><code class="inline-code">LLMClient.getApiKey()</code>: Determines the correct token of access, whether for Azure OpenAI or OpenAI.  </li>
<li><code class="inline-code">LLMClient.validateResponse()</code>: Safeguards against incomplete or nonsensical answers, ensuring clarity.  </li>
<li><code class="inline-code">isAzureOpenAI()</code>: Distinguishes between the various provider realms to configure the client accordingly.  </li>
<li><code class="inline-code">cleanJsonResponse()</code>: Extracts meaning even when responses are wrapped in ancient wrappings, like Markdown code blocks.</li>
</ul>
<h2>Code</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a></h3>
<pre><code class="language-typescript">  async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
    this.validateProjectPath(projectPath);
    
    const configuredFiles = extractUniqueFilePaths(projectPath);
    
    if (configuredFiles.length &gt; 0) {
      try {
        return await this.generateTargetedContent(projectPath, configuredFiles);
      } catch (error) {
        console.warn(`Failed to generate targeted content, falling back to full repomix content: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    
    const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
    const cached = this.cache.get(cacheKey);
    if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
      return cached.content;
    }
    
    try {
      const ignorePatterns = [&#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;, &#39;coverage&#39;, &#39;.nyc_output&#39;];
      
      if (!options.includeTests) {
        ignorePatterns.push(&#39;**/*.test.ts&#39;, &#39;**/*.spec.ts&#39;, &#39;**/tests/**&#39;, &#39;**/test/**&#39;);
      }

      const cliOptions: CliOptions = {
        style: options.style || &#39;markdown&#39;,
        stdout: true,
        compress: options.compress !== false,
        ignore: ignorePatterns.join(&#39;,&#39;),
        removeComments: true,
        removeEmptyLines: true,
        noDirectoryStructure: true
      };

      const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
      this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
      
      return context;
    } catch (error) {
      throw new Error(`Repomix execution failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
</code></pre>
<p>This function ensures that no treasure is wasted, caching results and analyzing only what&#39;s necessary to uncover the repository&#39;s secrets.  </p>
<hr>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a></h3>
<pre><code class="language-typescript">  private validateResponse(completion: any): string {
    const choice = completion.choices[0];
    const content = choice?.message?.content;
    
    if (!choice) {
      throw new Error(&#39;LLM returned no choices in response&#39;);
    }
    
    if (!choice.message) {
      throw new Error(&#39;LLM returned choice without message&#39;);
    }
    
    if (!content || content.trim() === &#39;&#39;) {
      this.handleEmptyResponse(choice);
    }
    
    return content;
  }

  private handleEmptyResponse(choice: any): never {
    console.error(&#39;🚨 LLM Empty Response Debug Info:&#39;);
    console.error(&#39;- Model:&#39;, this.model);
    console.error(&#39;- Choice finish_reason:&#39;, choice.finish_reason);
    console.error(&#39;- Message role:&#39;, choice.message.role);
    console.error(&#39;- Content null/empty:&#39;, content === null ? &#39;null&#39; : &#39;empty string&#39;);
    
    if (choice.finish_reason === &#39;length&#39;) {
      throw new Error(&#39;LLM response was truncated due to token limit. Try reducing prompt size or increasing maxTokens option.&#39;);
    }
    
    throw new Error(`LLM returned empty response. Finish reason: ${choice.finish_reason || &#39;unknown&#39;}`);
  }
</code></pre>
<p>These functions ensure that the adventurer’s inquiries are answered fully and clearly, catching errors to avoid wasted queries to the oracle.  </p>
<h2>Helpful Hints</h2>
<ul>
<li>Examine <code class="inline-code">captureRepomixStdout()</code> in <code class="inline-code">repo-analyzer.ts</code> closely; its subprocess handling ensures the safety of exploration.  </li>
<li>When using <code class="inline-code">LLMClient</code>, always verify why a specific provider selection matters (e.g., Azure vs. OpenAI).  </li>
<li>Explore the <code class="inline-code">adventure-config</code> module for precise guidance on extracting specified files—this ensures efficiency in analyzing vast repositories.</li>
</ul>
<hr>
<p>By the sacred light of the eternal stars, thou hast ascended with wisdom unbound, unraveling the enigmatic truths of the Analyzing Monolith—press forward, seeker, for thy journey to ancient mastery is now 40% illumined! ⚡💎🗺️👁️</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4: The Shrine of Sacred Themes →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>