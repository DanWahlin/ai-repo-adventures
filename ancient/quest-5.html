<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 5: The Scroll of Configurations - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'ancient' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <a href="index.html">The Lost Codex of Repositories</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 5: The Scroll of Configurations</h1>
<hr>
<p>The temple‚Äôs innermost chamber trembled as you advanced toward a glimmering pedestal cloaked in mist. Atop it rested the enigmatic Scroll of Configurations, rumored to hold ancient wisdom on orchestrating complex systems into harmonious alignment. Surrounding you were glyph-carved walls whispering forgotten secrets of structure and order. Yet, as you reached for the scroll, intricate puzzles began to emerge, testing your resolve to uncover the sacred techniques encoded within. Harness its knowledge wisely, adventurer‚Äîchaos waits for no one.</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Central Configuration Logic</h3>
<p>Nestled in the heart of the repository, the <a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/shared/adventure-config.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/shared/adventure-config.ts</code></a> file serves as the foundation for orchestrating quests and crafting guidance configurations for explorers like yourself. It first deciphers the mysterious <code class="inline-code">adventure.config.json</code> file, parsing its content to unveil the structure behind the quests and sacred file analyses. Through meticulous logic, it ensures only valid and purposeful data is retained. With the <code class="inline-code">extractUniqueFilePaths()</code> function, this file becomes a mapmaker‚Äîtraversing every stroke of the configuration to uncover pathways towards the files referenced. Meanwhile, the <code class="inline-code">formatAdventureConfigForPrompt()</code> transforms the raw configurations into eloquent scripts ready to harmonize with an LLM, ensuring structured file analyses remain sacred and unified.</p>
<p>Here, ancient and modern wisdom blend seamlessly. Think of this file as the scroll that guides adventurers, ensuring no stray path leads to chaos and each exploration step maintains clarity. It safeguards the repository‚Äôs labyrinth, leaving behind trails illuminated by purpose.</p>
<h4>Highlights</h4>
<ul>
<li>Parses <code class="inline-code">adventure.config.json</code> with care using the <code class="inline-code">parseAdventureConfig()</code> function.</li>
<li>Traverses intricate hierarchies to map referenced file locations via <code class="inline-code">extractUniqueFilePaths()</code>.</li>
<li>Formats the configuration into structured prompts for storytelling through <code class="inline-code">formatAdventureConfigForPrompt()</code>.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">function readFileIfExists(filePath: string): string | null {
  try {
    return fs.readFileSync(filePath, &#39;utf-8&#39;);
  } catch {
    // Missing or unreadable file is non-fatal
    return null;
  }
}
</code></pre>
<p>Much like deciphering an ancient scroll, this function delicately unfolds a file‚Äôs contents, returning it only if it exists in the repository‚Äôs depths.</p>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<p>This code transforms raw, unreadable hieroglyphs into structured insights while protecting against the risk of deciphering errors.</p>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    // Extract and validate path
    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    // Add children to stack
    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<p>This function acts as an explorer‚Äôs mapmaker, marking every referenced file path with pristine precision, ensuring no treasure goes undiscovered.</p>
<pre><code class="language-typescript">export function formatAdventureConfigForPrompt(projectPath: string): string {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) {
    return &#39;&#39;;
  }

  const adventure = (parsed as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) {
    return &#39;&#39;;
  }

  let formatted = `## Quest Structure Guidelines\n\n`;
  formatted += `**CRITICAL: Each quest MUST include dedicated file analysis sections**\n\n`;

  for (const quest of adventure.quests) {
    if (!quest.title || !Array.isArray(quest.files)) continue;

    formatted += `### ${quest.title}\n`;
    formatted += `${quest.description}\n\n`;
    formatted += `**Required File Analysis Sections:**\n`;

    for (const file of quest.files) {
      if (!file.path || !file.description) continue;

      formatted += `\n**File: \`${file.path}\`**\n`;
      formatted += `- Description: ${file.description}\n`;
      
      if (Array.isArray(file.highlights)) {
        formatted += `- Key Functions/Areas to Highlight:\n`;
        for (const highlight of file.highlights) {
          if (highlight.name &amp;&amp; highlight.description) {
            formatted += `  ‚Ä¢ **${highlight.name}**: ${highlight.description}\n`;
          }
        }
      }
    }
    formatted += `\n`;
  }

  formatted += `\n**FORMATTING INSTRUCTIONS:**\n`;
  formatted += `- Each file mentioned in the quest structure above MUST have its own dedicated analysis section\n`;
  formatted += `- **MANDATORY**: Include at least 2-3 separate code snippet sections (## filename) with real code blocks\n`;
  formatted += `- Show actual function signatures, imports, class definitions, or key methods from the files\n`;
  formatted += `- Include real code snippets from the actual files (never invent code)\n`;
  formatted += `- Provide practical explanations using real-world analogies\n`;
  formatted += `- End with helpful hints and next steps\n`;

  return formatted;
}
</code></pre>
<p>This constructs an ancient scroll-like narrative, compiling all quests and their file analyses into one harmonious script ready for an LLM‚Äôs storytelling symphony.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">extractUniqueFilePaths()</code> to validate referenced paths and avoid chaotic errors in incomplete configurations.</li>
<li>When exploring quest generation code, focus on how formatted prompts in <code class="inline-code">formatAdventureConfigForPrompt()</code> structure files for clarity.</li>
<li>Next, delve into files containing quest orchestration logic, such as <code class="inline-code">adventure-manager.ts</code>, to see how these paths integrate into the storytelling flow.</li>
</ul>
<hr>
<p>Upon this sacred juncture, with Quest 5: The Scroll of Configurations etched into the annals of triumph, thou art anointed as a seeker of wisdom whose resolve illuminates the path to the final constellation! ‚≠ê‚ö°üó∫Ô∏èüíé</p>

</div>


    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">
                <img src="assets/images/github-mark-white.svg" alt="GitHub" width="20" height="20" style="vertical-align: middle; margin-right: 8px;">
                MCP Repo Adventure
            </a>
        </div>
    </footer>
</body>
</html>