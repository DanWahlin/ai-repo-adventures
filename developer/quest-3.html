<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: Quest Design and Content Engineering - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Repository Chronicles: Exploring Modular Systems</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest Design and Content Engineering</h1>
<hr>
<p>This stage of your technical journey delves into the intricacies of constructing robust quest content for AI-driven systems. By examining the Quest Generation Engine, you&#39;ll uncover how a modular codebase integrates storytelling with developer-centric workflows. Your mission is to explore key files and understand how they work together to generate dynamic quests that adapt to projects and themes. Sharpen your skills in design patterns, content formatting, and system architectures as you progress.</p>
<h2>Quest Objectives</h2>
<p>As you explore the code below, investigate these key questions:</p>
<ul>
<li>üîç <strong>Dynamic Configuration</strong>: How does <code class="inline-code">loadAdventureConfig</code> facilitate modular file-based adventure configurations?</li>
<li>‚ö° <strong>Story-Quest Integration</strong>: How do <code class="inline-code">initializeAdventure</code> and <code class="inline-code">generateQuestContent</code> bridge the gap between story generation and actionable quest objectives?</li>
<li>üõ°Ô∏è <strong>Error Handling Paradigms</strong>: What mechanisms are in place to ensure safe parsing and validation in <code class="inline-code">parseAdventureConfig</code> and <code class="inline-code">generateStoryAndQuests</code>?</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/shared/adventure-config.ts:</span> Config utility for quest parameterization</h3>
<p>This file handles the loading, parsing, and validation of adventure configurations. It lays the foundation for modular quests through functions that extract file references, validate paths, and format data for consumption by the Quest Generation Engine.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">loadAdventureConfig</code>: Retrieves the raw configuration JSON file as plain text for further processing.</li>
<li><code class="inline-code">parseAdventureConfig</code>: Parses and validates the JSON configuration, ensuring only valid objects are considered.</li>
<li><code class="inline-code">extractUniqueFilePaths</code>: Scours the configuration to identify deduplicated, valid file paths referenced across quests.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/adventure/adventure-manager.ts:</span> Quest lifecycle and execution</h3>
<p>This central module orchestrates the creation and execution of quests. It integrates story generation with configuration files, validates user input choices, and dynamically generates content for AI-based quests.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">initializeAdventure</code>: Resets state, selects themes, and generates story + quests based on project input and configuration.</li>
<li><code class="inline-code">exploreQuest</code>: Executes a specific quest selected by the user, caching completed quests for efficiency.</li>
<li><code class="inline-code">mergeQuestFilesFromConfig</code>: Integrates user-defined quest file structures with generated content for richer journeys.</li>
</ul>
<hr>
<h3><span class="header-prefix">packages/core/src/adventure/story-generator.ts:</span> Story and quest generation logic</h3>
<p>This file focuses on generating story narratives and detailed quest objectives using AI tools. It combines structured response parsing with user-generated content for dynamic output.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateStoryAndQuests</code>: Creates an overarching story and populates it with quests based on the given project and theme.</li>
<li><code class="inline-code">generateQuestContent</code>: Generates detailed markdown content for a single quest, optimized for clarity and engagement.</li>
<li><code class="inline-code">parseMarkdownToStoryResponse</code>: Extracts structured data like story titles, narratives, and quests from LLM-prompted markdown.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/shared/adventure-config.ts</h3>
<pre><code class="language-typescript">export function loadAdventureConfig(projectPath: string): string | null {
  const configPath = path.join(projectPath, ADVENTURE_CONFIG_FILE);
  return readFileIfExists(configPath);
}
</code></pre>
<ul>
<li>Simple utility to fetch raw adventure configuration based on file paths.</li>
<li>Keeps file operations reusable and accessible by other modules.</li>
<li>Promotes separation of concerns by isolating file I/O from parsing logic.</li>
</ul>
<pre><code class="language-typescript">export function parseAdventureConfig(projectPath: string): unknown | null {
  const raw = loadAdventureConfig(projectPath);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
</code></pre>
<ul>
<li>Parses and validates the JSON configuration into structured data.</li>
<li>Centralized JSON error handling for safer processing across the system.</li>
<li>Ensures only valid configurations propagate to story-generation components.</li>
</ul>
<pre><code class="language-typescript">export function extractUniqueFilePaths(projectPath: string): string[] {
  const parsed = parseAdventureConfig(projectPath);
  if (!parsed || typeof parsed !== &#39;object&#39;) return [];

  const unique = new Set&lt;string&gt;();
  const stack: any[] = [parsed];

  while (stack.length) {
    const node = stack.pop();
    if (!node || typeof node !== &#39;object&#39;) continue;

    if (typeof node.path === &#39;string&#39; &amp;&amp; node.path.trim()) {
      const rel = node.path.trim();
      if (fs.existsSync(path.resolve(projectPath, rel))) {
        unique.add(rel);
      }
    }

    const children = Array.isArray(node) ? node : Object.values(node);
    children.forEach(child =&gt; {
      if (child &amp;&amp; typeof child === &#39;object&#39;) stack.push(child);
    });
  }

  return Array.from(unique);
}
</code></pre>
<ul>
<li>Uses depth-first traversal to identify valid file paths across the configuration.</li>
<li>Employs <code class="inline-code">Set</code> for deduplication and ensures path validity through <code class="inline-code">fs.existsSync</code>.</li>
<li>Enables dynamic file discovery for quests without overwhelming the system.</li>
</ul>
<hr>
<h3>packages/core/src/adventure/adventure-manager.ts</h3>
<pre><code class="language-typescript">async initializeAdventure(
  projectInfo: ProjectInfo, 
  theme: AdventureTheme, 
  projectPath?: string,
  customThemeData?: CustomThemeData
): Promise&lt;string&gt; {
  this.state.reset();
  this.state.projectInfo = projectInfo;
  this.state.currentTheme = theme;
  this.state.projectPath = projectPath || process.cwd();
  if (theme === &#39;custom&#39; &amp;&amp; customThemeData) {
    this.storyGenerator.setCustomTheme(customThemeData);
  }
  const storyResponse = await this.storyGenerator.generateStoryAndQuests(projectInfo, theme, this.state.projectPath);
  this.state.title = storyResponse.title;
  this.state.story = storyResponse.story;
  this.state.quests = this.mergeQuestFilesFromConfig(storyResponse.quests, this.state.projectPath);
  this.state.quests = this.enforceConfigQuestCount(this.state.quests, this.state.projectPath);
  return this.formatStoryWithQuests({
    ...storyResponse,
    quests: this.state.quests
  });
}
</code></pre>
<ul>
<li>Coordinates initialization of the adventure, including story generation and file configuration.</li>
<li>Supports project-specific paths and themes, allowing flexible user-defined input.</li>
<li>Serves as the entry point for setting up a new adventure sequence.</li>
</ul>
<pre><code class="language-typescript">async exploreQuest(choice: string): Promise&lt;AdventureResult&gt; {
  const sanitizedChoice = this.validateAndSanitizeChoice(choice);
  if (this.isProgressRequest(sanitizedChoice)) {
    return this.getProgress();
  }
  const quest = this.findQuest(sanitizedChoice);
  if (!quest) {
    return this.createNotFoundResult();
  }
  return await this.executeQuest(quest);
}
</code></pre>
<ul>
<li>Manages quest execution based on user input, validating and locating quests dynamically.</li>
<li>Handles progress views and fallbacks for missing quests gracefully.</li>
<li>Leverages a modular <code class="inline-code">executeQuest</code> method for efficient handling of functionality.</li>
</ul>
<pre><code class="language-typescript">private mergeQuestFilesFromConfig(quests: Quest[], projectPath: string | undefined): Quest[] {
  if (!projectPath) return quests;
  const config = parseAdventureConfig(projectPath);
  if (!config || typeof config !== &#39;object&#39;) return quests;

  const adventure = (config as any).adventure;
  if (!adventure || !Array.isArray(adventure.quests)) return quests;

  const configQuestFiles = new Map&lt;string, string[]&gt;();
  for (const configQuest of adventure.quests) {
    if (configQuest.title &amp;&amp; Array.isArray(configQuest.files)) {
      const filePaths = configQuest.files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (filePaths.length &gt; 0) {
        configQuestFiles.set(configQuest.title.toLowerCase(), filePaths);
      }
    }
  }

  return quests.map((quest, index) =&gt; {
    if (index &lt; adventure.quests.length &amp;&amp; adventure.quests[index].files) {
      const files = adventure.quests[index].files
        .filter((f: any) =&gt; f.path)
        .map((f: any) =&gt; f.path);
      if (files.length &gt; 0) {
        return { ...quest, codeFiles: files };
      }
    }
    const questTitleLower = quest.title.toLowerCase();
    for (const [configTitle, files] of configQuestFiles.entries()) {
      if (questTitleLower.includes(configTitle) || configTitle.includes(questTitleLower)) {
        return { ...quest, codeFiles: files };
      }
    }
    return quest;
  });
}
</code></pre>
<ul>
<li>Integrates configuration-specified files into the dynamically generated quest list.</li>
<li>Prioritizes matching by index and falls back to title-based checks for flexibility.</li>
<li>Balances user-specified constraints with dynamically generated content.</li>
</ul>
<hr>
<h3>packages/core/src/adventure/story-generator.ts</h3>
<pre><code class="language-typescript">async generateStoryAndQuests(projectInfo: ProjectInfo, theme: AdventureTheme, projectPath?: string): Promise&lt;StoryResponse&gt; {
  this.currentProject = projectInfo;
  this.projectPath = projectPath;
  const validatedTheme = this.validateTheme(theme);
  return await this.generateWithLLM(projectInfo, validatedTheme);
}
</code></pre>
<ul>
<li>Coordinates story and quest generation, ensuring the selected theme is valid and consistent.</li>
<li>Centralizes logic for effectively utilizing project context during content creation.</li>
<li>Applies robust fallback mechanisms in case of LLM-related failures.</li>
</ul>
<pre><code class="language-typescript">async generateQuestContent(config: QuestGenerationConfig): Promise&lt;QuestContent&gt; {
  const { quest, theme, codeContent, questPosition, totalQuests } = config;
  let adventureGuidance = &#39;&#39;;
  let customInstructions = &#39;&#39;;
  if (this.projectPath) {
    const formattedConfig = formatAdventureConfigForPrompt(this.projectPath);
    if (formattedConfig) {
      adventureGuidance = formattedConfig;
    }
    const customInstructionsFromConfig = extractCustomInstructions(this.projectPath);
    if (customInstructionsFromConfig) {
      customInstructions = customInstructionsFromConfig;
    }
  }

  const prompt = loadQuestContentPrompt({
    theme,
    adventureTitle: quest.title,
    codeContent,
    storyContent: this.currentStoryContent || &#39;No story context available.&#39;,
    adventureGuidance: adventureGuidance || &#39;&#39;,
    ...(customInstructions &amp;&amp; { customInstructions }),
    questPosition,
    totalQuests,
    ...(this.customThemeData &amp;&amp; { customThemeData: this.customThemeData })
  });
  const response = await this.withTimeout(
    this.llmClient.generateResponse(prompt, { maxTokens: LLM_MAX_TOKENS_QUEST })
  );
  if (!response.content || response.content.trim() === &#39;&#39;) {
    throw new Error(&#39;LLM returned empty response for quest content&#39;);
  }
  let cleanContent = response.content.trim();
  const beginMarker = &#39;---BEGIN MARKDOWN---&#39;;
  const endMarker = &#39;

Congratulations on successfully deploying Quest 3: Quest Design and Content Engineering‚Äîyour codebase of skills is now 40% compiled; keep optimizing your logic and prepare to refactor any challenges into opportunities‚Äîonward to the next milestone! üöÄ‚≠êüì°
</code></pre>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
</body>
</html>