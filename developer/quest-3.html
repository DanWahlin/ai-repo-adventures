<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Mystic Lens - Analyzing the Repository's Fate - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Set theme-aware CSS variables for animations
        document.addEventListener('DOMContentLoaded', function() {
            // Manually trigger Prism highlighting after page load
            if (window.Prism) {
                window.Prism.highlightAll();
            }
            // Detect theme from current CSS variables or default to space
            const root = document.documentElement;
            
            // Simple theme detection based on page content or default to space
            const theme = 'developer' || 'space';
            
            // Set display variables for animated elements
            root.style.setProperty('--space-display', theme === 'space' ? 'block' : 'none');
            root.style.setProperty('--ancient-display', theme === 'ancient' ? 'block' : 'none');
            root.style.setProperty('--mythical-display', theme === 'mythical' ? 'block' : 'none');
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">Chronicles of the Code Repository: The Architect's Adventure</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Mystic Lens - Analyzing the Repository&#39;s Fate</h1>
<hr>
<p>The Essence Core glimmers as you approach its next challenge, &quot;The Mystic Lens - Analyzing the Repository&#39;s Fate.&quot; The Repository ripples with energy, concealing secrets that intertwine its lifeblood—its files, adventures, and story-generating algorithms. Guided by the Architect&#39;s masterful design, you must now peer into the Repository&#39;s depths, using the Mystic Lens to decipher its core systems. Will you unlock its enigmas and chart the fate of this digital realm? Adventure awaits!</p>
<h2>File Exploration</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a>: Repomix Analysis and File Security Enforcer</h3>
<p>This file is the powerhouse behind the system&#39;s ability to distill insights from the Repository, converting the intricate labyrinth of project directories into structured, usable knowledge. Acting as the bridge between raw codebases and their adventure-ready representation, the <code class="inline-code">RepoAnalyzer</code> leverages the Repomix tool to dissect repositories. With functions like <code class="inline-code">generateRepomixContext()</code> and <code class="inline-code">captureRepomixStdout()</code>, it wraps the Repomix CLI, ensuring it executes securely and efficiently. It includes crucial validation methods, like <code class="inline-code">validateProjectPath()</code> and <code class="inline-code">validateAndNormalizeTargetFiles()</code>, to protect against path traversal attacks and other security risks. The cache system boosts efficiency by ensuring frequently analyzed projects don’t relaunch expensive operations repeatedly.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateRepomixContext()</code> produces a global snapshot of the project while respecting cache and performance constraints.</li>
<li><code class="inline-code">validateAndNormalizeTargetFiles()</code> ensures user-specified files are safe and properly scoped.</li>
<li><code class="inline-code">captureRepomixStdout()</code> encapsulates the raw interaction with Repomix while handling subprocess timeouts and memory caps.</li>
</ul>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a>: Multi-Provider LLM Orchestrator</h3>
<p>This file orchestrates interaction with large language models (LLMs) like OpenAI and Azure OpenAI. The <code class="inline-code">LLMClient</code> class is responsible for setting up the communication, managing API keys, detecting the correct provider, and handling requests with functions like <code class="inline-code">generateResponse()</code> and <code class="inline-code">buildRequestParams()</code>. Special attention is given to differentiating provider-specific configurations (e.g., Azure vs OpenAI) via utilities like <code class="inline-code">isAzureOpenAI()</code> and ensuring prompt formatting aligns with the model’s requirements. Timeout handling, token efficiency (<code class="inline-code">formatTokenCount()</code>), and verbosity options ensure robust and user-friendly interaction with LLM services.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">generateResponse()</code> processes prompts and retrieves formatted LLM outputs while logging token usage.</li>
<li><code class="inline-code">getApiKey()</code> distinguishes between <code class="inline-code">LLM_API_KEY</code> and <code class="inline-code">GITHUB_TOKEN</code>, prioritizing correct configuration.</li>
<li><code class="inline-code">logTokenUsage()</code> reveals token breakdowns, key for understanding budget consumption in API requests.</li>
</ul>
<h2>Code</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a></h3>
<pre><code class="language-typescript">/**
 * Basic validation for project path - minimal checks for actual use case
 */
private validateProjectPath(projectPath: string): void {
  if (!projectPath || typeof projectPath !== &#39;string&#39;) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  const trimmedPath = projectPath.trim();
  if (!trimmedPath) {
    throw new Error(&#39;Project path must be a non-empty string&#39;);
  }

  // Basic safety check for null bytes (can break file system operations)
  if (trimmedPath.includes(&#39;\0&#39;)) {
    throw new Error(&#39;Project path contains invalid null bytes&#39;);
  }
}
</code></pre>
<p>This is like guarding the front gate of a castle, ensuring the path travelers take doesn’t lead to traps or malicious paths.</p>
<pre><code class="language-typescript">/**
 * Generate repomix context for a project
 */
async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);

  // Check if adventure.config.json has specific files to include
  const configuredFiles = extractUniqueFilePaths(projectPath);

  if (configuredFiles.length &gt; 0) {
    // Use configured files with targeted content generation
    console.log(`Using adventure.config.json: analyzing ${configuredFiles.length} configured files`);
    try {
      return await this.generateTargetedContent(projectPath, configuredFiles);
    } catch (error) {
      console.warn(`Failed to generate targeted content, falling back to full repomix content: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // Fallback: use existing behavior with all files (compressed)
  console.log(&#39;No adventure.config.json found: analyzing full codebase (compressed)&#39;);

  return await this.generateTargetedContent(projectPath, []);
}
</code></pre>
<p>This works like scanning an enchanted map—either use the highlighted paths or fall back to explore the entire region thoroughly.</p>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a></h3>
<pre><code class="language-typescript">/**
 * Generate a response from the LLM
 */
async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);

    // Post-process JSON responses that might be wrapped in markdown
    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }

    this.logTokenUsage(completion);

    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);

    const message = error instanceof Error ? error.message : &#39;Unknown error&#39;;
    throw new Error(`LLM request failed: ${message}`);
  }
}
</code></pre>
<p>This is like consulting an oracle with a specific question—the oracle ensures your request is valid, interprets the answer, and logs what it learned.</p>
<pre><code class="language-typescript">/**
 * Clean JSON responses that might be wrapped in markdown code blocks
 */
private cleanJsonResponse(content: string): string {
  // Remove markdown code block wrappers if present
  const jsonBlockPattern = /^\s*```(?:json)?\s*\n?([\s\S]*?)\n?\s*```\s*$/;
  const match = content.match(jsonBlockPattern);

  if (match) {
    return match[1].trim();
  }

  // If no markdown wrapper, return original content
  return content.trim();
}
</code></pre>
<p>This is like unwrapping a scroll from a fancy wax seal, ensuring only the important message inside is preserved.</p>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">generateRepomixContext()</code> to create contextual summaries for large projects efficiently, leveraging caching for frequent runs.</li>
<li>Refactor configuration-detection logic in the <code class="inline-code">LLMClient</code> to make detecting Azure vs OpenAI providers even clearer and centralized.</li>
<li>Dive deeper into <code class="inline-code">adventure-config.js</code> to understand how files are prioritized for adventure prompts and structured output.</li>
</ul>
<hr>
<p>Quest 3 complete: You&#39;ve successfully refactored the Repository&#39;s logic, resolved all dependency issues, and unlocked the next level at 40%—stellar work, developer! ⭐🚀⚡</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4: The Scrolls of Configuration - ... →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
</body>
</html>