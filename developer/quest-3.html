<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Analyzer’s Nexus - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="assets/quest-navigator.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Codebound Chronicles</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Analyzer’s Nexus</h1>
<hr>
<p>A storm swirls around you as you step into the Analyzer&#39;s Nexus—the heart of code comprehension. Here lies your next challenge: to unravel the mysteries of two pivotal components that transform raw repositories into structured insights. The <code class="inline-code">RepoAnalyzer</code> and <code class="inline-code">LLMClient</code> are code constructs that hold the key to deciphering project paths and generating responses from sophisticated language models. But beware, adventurer, for the path forward requires precision and systematic exploration.</p>
<h2>File Exploration</h2>
<h3><span class="header-prefix">packages/core/src/analyzer/repo-analyzer.ts:</span> RepoAnalyzer Class Implementation</h3>
<p>The <code class="inline-code">RepoAnalyzer</code> class is the core mechanism behind optimized code content generation and validation in project repositories. It works closely with repomix tools and provides robust features such as cache management, targeted content extraction, and safe file normalization. Configurable options allow the analyzer to specify whether to include comments and empty lines or focus solely on critical code. The methods are designed to prevent path traversal, ensure security in handling files, and generate compressed representations of code contexts.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RepoAnalyzer.generateRepomixContext</code>: Builds the overarching repository context, leveraging configuration options.</li>
<li><code class="inline-code">RepoAnalyzer.generateTargetedContent</code>: Generates content focused on specific files with compression options.</li>
<li><code class="inline-code">RepoAnalyzer.captureRepomixStdout</code>: Enables subprocess interaction to dynamically extract repository data under strict safety constraints.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/analyzer/repo-analyzer.ts</h3>
<pre><code class="language-typescript">async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  const configuredFiles = extractUniqueFilePaths(projectPath);

  if (configuredFiles.length &gt; 0) {
    try {
      return await this.generateOptimizedContent(projectPath, configuredFiles);
    } catch (error) {
      // Fallback to targeted content generation when optimization fails
      return await this.generateTargetedContent(projectPath, configuredFiles);
    }
  }
  console.log(&#39;Analyzing full codebase (compressed)&#39;);
  const cacheKey = `${path.resolve(projectPath)}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);

  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
      
  try {
    const ignorePatterns = [&#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;, &#39;coverage&#39;];
    const cliOptions: CliOptions = {
      style: options.style || &#39;markdown&#39;,
      stdout: true,
      compress: options.compress !== false,
      ignore: ignorePatterns.join(&#39;,&#39;)
    };
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<p>Like building a puzzle, this function connects repository segments for content generation based on user and environmental configurations.</p>
<pre><code class="language-typescript">async generateTargetedContent(projectPath: string, targetFiles: string[], compress: boolean = true): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  const safeFiles = this.validateAndNormalizeTargetFiles(projectPath, targetFiles);
  if (safeFiles.length === 0) {
    throw new Error(&#39;No valid target files found after validation&#39;);
  }

  const cacheKey = `${path.resolve(projectPath)}:targeted:${safeFiles.join(&#39;,&#39;)}:compress=${compress}`;
  const cached = this.cache.get(cacheKey);

  if (cached &amp;&amp; (Date.now() - cached.timestamp) &lt; REPOMIX_CACHE_TTL) {
    return cached.content;
  }
    
  try {
    const cliOptions: CliOptions = {
      style: &#39;markdown&#39;,
      stdout: true,
      compress: compress,
      include: safeFiles.join(&#39;,&#39;),
      removeComments: compress,
      removeEmptyLines: compress
    };
    const context = await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
    this.cache.set(cacheKey, { content: context, timestamp: Date.now() });
    return context;
  } catch (error) {
    throw new Error(`Targeted repomix execution failed: ${error.message}`);
  }
}
</code></pre>
<p>This is like focusing a magnifying glass on specific files to extract compressed content for efficient processing.</p>
<pre><code class="language-typescript">private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [
      ...directories,
      &#39;--stdout&#39;,
      &#39;--style&#39;, options.style || &#39;markdown&#39;,
      options.compress &amp;&amp; &#39;--compress&#39;
    ].filter(Boolean);
    
    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], {
      cwd,
      stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]
    });
  
    let stdout = &#39;&#39;;
    let stderr = &#39;&#39;;
    let stdoutSize = 0;

    const timeout = setTimeout(() =&gt; {
      reject(new Error(`Repomix subprocess timed out after ${REPOMIX_SUBPROCESS_TIMEOUT}ms (${cwd})`));
      repomix.kill(&#39;SIGKILL&#39;);
    }, REPOMIX_SUBPROCESS_TIMEOUT);

    repomix.stdout.on(&#39;data&#39;, (data) =&gt; {
      stdoutSize += data.length;
      stdout += data.toString();
    });

    repomix.on(&#39;close&#39;, (code) =&gt; {
      clearTimeout(timeout);
      code === 0 ? resolve(stdout.trim()) : reject(new Error(stderr));
    });
  });
}
</code></pre>
<p>This function is akin to taking a snapshot of repository contents through a controlled subprocess interaction.</p>
<hr>
<h3><span class="header-prefix">packages/core/src/llm/llm-client.ts:</span> LLMClient Class for Language Model Interaction</h3>
<p>The <code class="inline-code">LLMClient</code> class acts as the bridge between the application and sophisticated language models, such as GPT-4 or GPT-5. It provides methods for API key validation, response generation, and model-specific adjustments. Important checks are in place to ensure secure communication with both OpenAI and Azure endpoints, enabling dynamic interaction based on the configuration. The class features advanced error handling and token usage logging for robust diagnostics.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">LLMClient.generateResponse</code>: Manages prompts and builds model-specific requests.</li>
<li><code class="inline-code">LLMClient.constructor</code>: Initializes the client with proper model settings and API validation.</li>
<li><code class="inline-code">LLMClient.getApiKey</code>: Safely retrieves API keys based on model and endpoint requirements.</li>
</ul>
<h2>Code</h2>
<h3>packages/core/src/llm/llm-client.ts</h3>
<pre><code class="language-typescript">async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);

    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }
    this.logTokenUsage(completion);
    return { content };
  } catch (error) {
    this.logDetailedError(error, prompt);
    throw new Error(`LLM request failed: ${error.message}`);
  }
}
</code></pre>
<p>This function is like sending a well-packaged message to the oracle and interpreting its cryptic reply.</p>
<pre><code class="language-typescript">constructor() {
  this.model = LLM_MODEL;
  const apiKey = this.getApiKey();

  if (this.isAzureOpenAI()) {
    const azureEndpoint = LLM_BASE_URL.split(&#39;/openai/deployments&#39;)[0];
    this.client = new AzureOpenAI({
      endpoint: azureEndpoint,
      apiKey,
      apiVersion: LLM_API_VERSION,
      deployment: this.model
    });
  } else {
    this.client = new OpenAI({
      apiKey,
      baseURL: LLM_BASE_URL
    });
  }
}
</code></pre>
<p>Much like selecting the perfect toolbox, this constructor sets the model and API configuration parameters meticulously.</p>
<pre><code class="language-typescript">private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;models.inference.ai.azure.com&#39;)) {
    if (!GITHUB_TOKEN) throw new Error(&#39;GITHUB_TOKEN required for GitHub Models.&#39;);
    return GITHUB_TOKEN;
  }
  
  if (!LLM_API_KEY) throw new Error(&#39;LLM_API_KEY required.&#39;);
  return LLM_API_KEY;
}
</code></pre>
<p>Imagine unlocking a chest—the function checks the proper key credentials before granting access.</p>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Use <code class="inline-code">generateRepomixContext</code> for overarching project-level insights.</li>
<li>Leverage <code class="inline-code">generateResponse</code> for interactive LLM-based scenario generation.</li>
<li>Combine validated paths from <code class="inline-code">RepoAnalyzer</code> with crafted LLM prompts for efficient workflows.</li>
</ul>
<hr>
<p>The Analyzer’s Nexus reveals its knowledge. Continue onward, technomancer, to harness this newfound power and safeguard the sacred archives.</p>
<p>Achievement Unlocked: Quest 3: The Analyzer’s Nexus successfully merged into main—your algorithmic precision has hit a breakpoint of brilliance; onward to 100% deployment! ⚡🚀💎</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">← Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script -->
    <script src="assets/quest-navigator.js"></script>
</body>
</html>