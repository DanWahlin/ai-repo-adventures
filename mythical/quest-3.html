<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3: The Scrying Eye of Code Analysis - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }
        
        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body>

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="index.html">The Enchanted Repository of Code and Quests</a>
            </div>
            <div class="nav-right">
                <a href="https://github.com/danwahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="assets/images/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Scrying Eye of Code Analysis</h1>
<hr>
<p>In the mystical forests of Codoria, a coven of Codemasters once enchanted an artifact known as the Scrying Eye, capable of unraveling the most intricate spells of code. The artifact harmonizes with Repomix and LLMs, guiding heroic coders to analyze repositories and forge customized quests for adventurers. The path to unlocking this artifact requires grasping the underlying magical framework of its core—analyzing the harmonized powers of Repomix and the LLM client.</p>
<h2>File Exploration</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a>: Repomix Wrangling and Content Extraction</h3>
<p>This file contains the magical incantations that enable the Codemasters to extract actionable insights from sprawling repositories. The <code class="inline-code">RepoAnalyzer</code> class orchestrates the invocation of Repomix, a powerful spell used for assessing and compressing code repositories. Its methods ensure cache stability, secure path validation, and subprocess control to prevent wild magic (errors stemming from improper configurations). These safeguards protect the sanctity of Codoria&#39;s enchanted repository.</p>
<h4>Highlights</h4>
<ul>
<li><strong><code class="inline-code">generateRepomixContext</code></strong>: Generates full content context for a repository, caching results and enforcing security measures.</li>
<li><strong><code class="inline-code">generateTargetedContent</code></strong>: Extracts selective content based on provided file paths, compressing the output while validating inputs.</li>
<li><strong><code class="inline-code">captureRepomixStdout</code></strong>: A subprocess handler building Repomix CLI commands and collecting outputs under strict safeguards.</li>
<li><strong><code class="inline-code">validateProjectPath</code></strong>: Ensures safe path usage, preventing any attempts to access forbidden realms (system directories).</li>
</ul>
<h2>Code</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/analyzer/repo-analyzer.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/analyzer/repo-analyzer.ts</code></a></h3>
<pre><code class="language-typescript">/**
 * Generate repomix context for a project
 */
async generateRepomixContext(projectPath: string, options: RepomixOptions = {}): Promise&lt;string&gt; {
  this.validateProjectPath(projectPath);
  
  // Check if adventure.config.json has specific files to include
  const configuredFiles = extractUniqueFilePaths(projectPath);
  
  if (configuredFiles.length &gt; 0) {
    return await this.generateTargetedContent(projectPath, configuredFiles);
  }

  // Fallback to a full repomix content generation
  const cliOptions: CliOptions = {
    style: options.style || &#39;markdown&#39;,
    stdout: true,
    compress: options.compress !== false,
    ignore: [&#39;node_modules&#39;, &#39;dist&#39;, &#39;build&#39;, &#39;.git&#39;].join(&#39;,&#39;),
    removeComments: true,
    removeEmptyLines: true,
    noDirectoryStructure: true
  };
  return await this.captureRepomixStdout([&#39;.&#39;], projectPath, cliOptions);
}
</code></pre>
<p>The <code class="inline-code">generateRepomixContext</code> method acts like a seasoned scribe, comprehensively scouring the Codorian archives with Repomix to provide summaries of the repository, tailored to the scribe&#39;s tools.</p>
<pre><code class="language-typescript">/**
 * Harden and validate target files
 */
private validateAndNormalizeTargetFiles(projectPath: string, targetFiles: string[]): string[] {
  const MAX_TARGET_FILES = 50;
  const safeFiles = [...new Set(targetFiles)]
    .slice(0, MAX_TARGET_FILES)
    .map(file =&gt; {
      const trimmed = file.trim();
      if (trimmed.includes(&#39;\0&#39;) || trimmed.includes(&#39;..&#39;)) {
        console.warn(`Rejecting potentially unsafe file path: ${trimmed}`);
        return null;
      }

      const fullPath = path.resolve(projectPath, file);
      if (!fullPath.startsWith(path.resolve(projectPath) + path.sep)) {
        console.warn(`Rejecting file outside project directory: ${file}`);
        return null;
      }

      return path.relative(projectPath, fullPath);
    })
    .filter((file): file is string =&gt; file !== null)
    .sort();
    
  return safeFiles;
}
</code></pre>
<p>The <code class="inline-code">validateAndNormalizeTargetFiles</code> function is like a vigilant castle guard, ensuring no unworthy or ill-intended files enter the magical forge for content generation.</p>
<pre><code class="language-typescript">/**
 * Use repomix CLI as subprocess to capture stdout
 */
private async captureRepomixStdout(directories: string[], cwd: string, options: CliOptions): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    const args = [...directories, &#39;--stdout&#39;, &#39;--style&#39;, options.style || &#39;markdown&#39;];
    if (options.compress) args.push(&#39;--compress&#39;);
    if (options.removeComments) args.push(&#39;--remove-comments&#39;);
    if (options.ignore) args.push(&#39;--ignore&#39;, options.ignore);

    const repomix = spawn(&#39;npx&#39;, [&#39;repomix&#39;, ...args], { cwd });
    let stdout = &#39;&#39;;
    let isResolved = false;

    const timeout = setTimeout(() =&gt; {
      if (!isResolved) {
        repomix.kill(&#39;SIGTERM&#39;);
        isResolved = true;
        reject(new Error(`Repomix subprocess timed out`));
      }
    }, REPOMIX_SUBPROCESS_TIMEOUT);

    repomix.stdout.on(&#39;data&#39;, (data) =&gt; (stdout += data.toString()));
    repomix.on(&#39;close&#39;, (code) =&gt; {
      if (!isResolved) {
        clearTimeout(timeout);
        resolve(stdout.trim());
      }
    });
    repomix.on(&#39;error&#39;, (error) =&gt; {
      if (!isResolved) {
        clearTimeout(timeout);
        reject(error);
      }
    });
  });
}
</code></pre>
<p>The <code class="inline-code">captureRepomixStdout</code> function is the spellcaster, casting a subprocess incantation that channels Repomix’s power into Codoria’s codex with protective barriers against uncontrolled magic (timeouts and memory limits).</p>
<hr>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a>: Magical Conversations with the LLM Oracle</h3>
<p>The <code class="inline-code">LLMClient</code> file defines the Codorian interface to the mystical Oracle of Language Models. This class enables interaction with diverse LLM portals, supporting OpenAI, Azure, and GitHub’s GPT models. It gracefully handles the complexities of communication—including timeouts, response formats, and model-specific quirks—ensuring adventurers receive coherent guidance in their quests. Wisdom is curated via precise prompts, token management, and failure recovery.</p>
<h4>Highlights</h4>
<ul>
<li><strong><code class="inline-code">generateResponse</code></strong>: Central method for invoking the Oracle to obtain heroic answers, managing response formats and fallbacks.</li>
<li><strong><code class="inline-code">constructor</code></strong>: Determines the correct invocation portal (OpenAI or Azure) and establishes secure communication.</li>
<li><strong><code class="inline-code">getApiKey</code></strong>: Ensures valid access keys are provided for the chosen portal.</li>
<li><strong><code class="inline-code">isAzureOpenAI</code></strong>: Special handling for Azure-specific configurations, enabling seamless function across realms.</li>
</ul>
<h2>Code</h2>
<h3><a href="https://github.com/danwahlin/ai-repo-adventures/blob/main/packages/core/src/llm/llm-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">packages/core/src/llm/llm-client.ts</code></a></h3>
<pre><code class="language-typescript">/**
 * Generate a response from the LLM
 */
async generateResponse(prompt: string, options?: LLMRequestOptions): Promise&lt;LLMResponse&gt; {
  try {
    const requestParams = this.buildRequestParams(prompt, options);
    const completion = await this.executeRequest(requestParams);
    let content = this.validateResponse(completion);

    if (options?.responseFormat === &#39;json_object&#39;) {
      content = this.cleanJsonResponse(content);
    }

    return { content };
  } catch (error) {
    throw new Error(`LLM request failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}
</code></pre>
<p>This function acts as a knight’s messenger, carrying inquiries to the Oracle and returning its wisdom to inform quest decisions, with a fallback plan for errors.</p>
<pre><code class="language-typescript">/**
 * Initialize message parameters
 */
private buildRequestParams(prompt: string, options?: LLMRequestOptions): OpenAIRequestParams {
  const requestParams: OpenAIRequestParams = {
    model: this.model,
    messages: [{ role: &#39;user&#39;, content: prompt }],
    temperature: LLM_TEMPERATURE,
    max_tokens: options?.maxTokens || LLM_MAX_TOKENS_DEFAULT
  };

  if (this.isAzureOpenAI()) {
    requestParams.verbosity = options?.verbosity || GPT5_VERBOSITY;
    requestParams.reasoning_effort = options?.reasoningEffort || GPT5_REASONING_EFFORT;
  }

  return requestParams;
}
</code></pre>
<p>The <code class="inline-code">buildRequestParams</code> function forges the magical scroll (prompt) that delivers inquiries to the Oracle, ensuring clarity and structure in every call.</p>
<pre><code class="language-typescript">/**
 * Determine correct API key for the provider
 */
private getApiKey(): string {
  if (LLM_BASE_URL.includes(&#39;azure.com&#39;)) {
    if (!GITHUB_TOKEN) {
      throw new Error(&#39;GITHUB_TOKEN required for Azure Models.&#39;);
    }
    return GITHUB_TOKEN;
  }
  if (!LLM_API_KEY) {
    throw new Error(&#39;LLM_API_KEY required. Set LLM_API_KEY environment variable.&#39;);
  }
  return LLM_API_KEY;
}
</code></pre>
<p>The <code class="inline-code">getApiKey</code> method ensures that the adventurers have the required enchanted sigils (API keys) to unlock hidden knowledge.</p>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li><strong>Practical tip</strong>: Leverage the Scrying Eye’s cache capabilities to avoid repetitive magical invocations.</li>
<li><strong>Exploration recommendation</strong>: Experiment with targeted content generation using <code class="inline-code">adventure.config.json</code> for context-specific quests.</li>
<li><strong>Next steps</strong>: Investigate how themes and prompts are structured—these lie at the heart of crafting meaningful adventures.</li>
</ul>
<hr>
<p>As you grasp the essence of the Scrying Eye of Code Analysis, the repository hums with magical energy, ready to shape your next quests with unrivaled precision. Journey forth, brave coder!</p>
<p>With the luminous power of the Scrying Eye now mastered, you ascend as a starbound champion ⚡, unveiling the sacred threads of code analysis and claiming your rightful place in the kingdom&#39;s charts of progress—halfway to triumph!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4: The Sacred Codex of Themes and ... →</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
</body>
</html>